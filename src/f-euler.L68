00002000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/16/2023 5:51:37 PM

00000000                             1  *,______________________________________________________,
00000000                             2  *|__________  ______________  ________________________  |
00000000                             3  *|___  ____/  ___  ____/_  / / /__  /___  ____/__  __ \ |
00000000                             4  *|__  /_________  __/  _  / / /__  / __  __/  __  /_/ / |
00000000                             5  *|_  __//_____/  /___  / /_/ / _  /___  /___  _  _, _/  |
00000000                             6  *|/_/         /_____/  \____/  /_____/_____/  /_/ |_|   |
00000000                             7  *|                                                      |
00000000                             8  *|            The 68k high-speed racing game            |
00000000                             9  *|                                                      |
00000000                            10  *|  Made By: Austin Smith        Date Started: 10/7/23  |
00000000                            11  *|______________________________________________________|
00000000                            12  *`                                                      `
00000000                            13  
00001000                            14      ORG $1000
00001000                            15  
00001000                            16  *,__________________________________________________,
00001000                            17  *| Constants
00001000                            18  
00001000                            19  ALL_REG             REG D0-D7/A0-A6
00001000                            20  TRAP_REG            REG D0-D1/A0-A2
00001000                            21  
00001000                            22  *| Vectors
00001000  =00000280                 23  SCREEN_WIDTH        EQU 640
00001000  =000001E0                 24  SCREEN_HEIGHT       EQU 480
00001000                            25  
00001000                            26  *| TRAP Codes
00001000  =00000013                 27  GET_KEY_INPUT_COMMAND   EQU 19
00001000                            28  
00001000  =00000050                 29  SET_PIXEL_COLOR     EQU 80
00001000  =00000052                 30  PRINT_PIXEL         EQU 82
00001000                            31  
00001000  =0000005E                 32  SWAP_BUFFER         EQU 94
00001000                            33  
00001000                            34  *,__________________________________________________,
00001000                            35  *| Includes
00001000                            36      INCLUDE "./file_loader.x68"   ; Handles loading of files during preload phase
00001000                            37  
00001000  =0000048A                 38  SHIP_BMP_SIZE       EQU 1162    ; The number of bytes betwen each ship file
00001000  =00000404                 39  SHIP_PG_SIZE        EQU 1028     ; The size of a ship sprite in memory
00001000                            40  
00001000                            41  fl_LoadFiles:
00001000                            42      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001000  207C 00002090             43      move.l #BackgroundBmpFile, a0   *| file_root
00001006  227C 001329BA             44      move.l #pg_Background, a1       *| output_image
0000100C  4EB9 00001044             45      jsr fl_LoadBitmap
00001012                            46  
00001012  4EB9 0000101A             47      jsr fl_LoadShipRotations
00001018                            48      
00001018  4E75                      49      rts
0000101A                            50  
0000101A                            51  fl_LoadShipRotations:
0000101A  207C 0012E11A             52      move.l #ShipBmpFiles, a0
00001020  227C 0025E9BE             53      move.l #pg_ShipRotations, a1
00001026                            54  
00001026                            55  .LoadBmp:
00001026  4EB9 00001044             56      jsr fl_LoadBitmap
0000102C                            57  
0000102C  D1FC 0000048A             58      add.l #SHIP_BMP_SIZE, a0
00001032  D3FC 00000404             59      add.l #SHIP_PG_SIZE, a1
00001038                            60  
00001038  B1FC 001329BA             61      cmp.l #EndShipBmpFiles, a0  ; Are we past the end?
0000103E  6D00 FFE6                 62      blt.l .LoadBmp              ; If not, keep on loading.
00001042                            63  
00001042  4E75                      64      rts
00001044                            65  
00001044                            66  fl_LoadBitmap:
00001044  48E7 FFFE                 67      movem.l ALL_REG, -(sp) *| Push registers to stack
00001048                            68  
00001048                            69  ParseBitmapHeader: ; Gather essential information from the bitmap's header
00001048                            70      ; This will need to be converted to Big Endian later based on the Color Range
00001048  2648                      71      move.l a0, a3
0000104A  D7FC 0000000A             72      add.l #$A, a3               ; Offset to pixel array
00001050  2213                      73      move.l (a3), d1
00001052                            74          
00001052  4EB9 00001108             75      jsr ParseLittleEndianLong
00001058                            76          
00001058  D288                      77      add.l a0, d1
0000105A  2801                      78      move.l d1, d4               ; Offset to Pixel Array
0000105C                            79          
0000105C  2648                      80      move.l a0, a3
0000105E  D7FC 00000012             81      add.l #$12, a3              ; Offset to image width
00001064  2213                      82      move.l (a3), d1             ; Image Width
00001066  4EB9 00001108             83      jsr ParseLittleEndianLong
0000106C  2A01                      84      move.l d1, d5
0000106E                            85          
0000106E  2648                      86      move.l a0, a3
00001070  D7FC 00000016             87      add.l #$16, a3              ; Offset to image height
00001076  2213                      88      move.l (a3), d1             ; Image Height
00001078  4EB9 00001108             89      jsr ParseLittleEndianLong
0000107E  2C01                      90      move.l d1, d6
00001080                            91      
00001080  3285                      92      move.w d5, (a1)             ; Push width & height to pixel grid
00001082  5489                      93      add.l #2, a1
00001084  3286                      94      move.w d6, (a1)
00001086  5489                      95      add.l #2, a1                ; Offset to start of pixel data in pixel grid
00001088                            96          
00001088  5C8B                      97      add.l #$6, a3
0000108A  3213                      98      move.w (a3), d1             ; ColorRange
0000108C  E159                      99      rol.w #8, d1
0000108E                           100  
0000108E                           101  GetBitmapChunks:                ; Get the desired chunks of the bitmap
0000108E                           102                                  ; Finding starting address
0000108E  2006                     103      move.l d6, d0               ; Height (H)
00001090  5380                     104      sub.l #1, d0                ; Sub by 1 to get column H - 1
00001092  2205                     105      move.l d5, d1
00001094  C0C1                     106      mulu.w d1, d0               ; Multiply by width to get last index of column CY - 1
00001096                           107          
00001096  2200                     108      move.l d0, d1               ; Storing in a separate variable so we can keep the index for other calculations
00001098  E589                     109      lsl.l #2, d1                ; Multiply by size of each pixel (Long Word).
0000109A  D284                     110      add.l d4, d1                ; Beginning of Pixel Array + Offset to Chunk Start
0000109C  2041                     111      move.l d1, a0               ; Current Pixel Address
0000109E                           112          
0000109E                           113      ; Finding end-of-row index
0000109E  D085                     114      add.l d5, d0                ; Add Chunk Width to push it to the end of the desired chunk's first row.
000010A0  E588                     115      lsl.l #2, d0                ; Multiply by size of each pixel (Long Word).
000010A2  D084                     116      add.l d4, d0                ; Beginning of Pixel Array + Offset to End-Of-Row
000010A4  2440                     117      move.l d0, a2               ; End Of Row Pixel Address
000010A6                           118          
000010A6                           119      ; Finding ending address
000010A6  2644                     120      move.l d4, a3   ; Represents the end row of the chunk's Address.
000010A8                           121  
000010A8                           122  GetSinglePixel:
000010A8                           123      ; Get pixel data
000010A8  2210                     124      move.l (a0), d1
000010AA                           125          
000010AA  4EB9 00001108            126      jsr ParseLittleEndianLong ; Convert to big endian
000010B0  2001                     127      move.l d1, d0   ; Move back to d0 after conversion
000010B2                           128         
000010B2  2200                     129      move.l d0, d1   ; Red
000010B4  E089                     130      lsr.l #8, d1    ; Red is the 3rd element, so we shift it 2 bytes over        
000010B6  E089                     131      lsr.l #8, d1    ; Have to cut it in byte increments.
000010B8  C2BC 000000FF            132      and.l #$FF, d1  ; Chopping off the channel bits that remain to the left.
000010BE                           133      
000010BE  2400                     134      move.l d0, d2   ; Green
000010C0  E08A                     135      lsr.l #8, d2    ; Green is the 2nd element, so we shift it 1 byte.
000010C2  C4BC 000000FF            136      and.l #$FF, d2  ; Chopping off the channel bits that remain to the left.
000010C8                           137          
000010C8  2600                     138      move.l d0, d3   ; Blue
000010CA  C6BC 000000FF            139      and.l #$FF, d3  ; Chopping off the channel bits that remain to the left.
000010D0                           140          
000010D0                           141      ; Shift these bits to the correct location for when we read it in BGR
000010D0  E18B                     142      lsl.l #8, d3    ; Blue is first, so we're shifting it to the 3rd byte
000010D2  E18B                     143      lsl.l #8, d3
000010D4                           144        
000010D4  E18A                     145      lsl.l #8, d2    ; Green is next, which goes to the 2nd byte.
000010D6                           146          
000010D6                           147      ; Red stays in place, now we merge the three variables into one
000010D6  C0BC FF000000            148      and.l #$FF000000, d0
000010DC  8081                     149      or.l d1, d0
000010DE  8082                     150      or.l d2, d0
000010E0  8083                     151      or.l d3, d0
000010E2                           152          
000010E2                           153      ; Push to BitmapChunk location
000010E2  2280                     154      move.l d0, (a1)
000010E4                           155          
000010E4                           156      ; Move Bitmap Chunk Pointer to next pixel
000010E4  5889                     157      add.l #4, a1
000010E6                           158          
000010E6                           159      ; Move Pixel Array Pointer to the next pixel
000010E6  5888                     160      add.l #4, a0            ; Move over 1 pixel
000010E8  B5C8                     161      cmp.l a0, a2            ; Is current Pixel Array Pointer past End of Row?
000010EA  6E00 FFBC                162      bgt.l GetSinglePixel    ; If not, continue the loop 
000010EE                           163          
000010EE                           164      ; If so, let's move the End of Row to the next row (backwards)
000010EE  2005                     165      move.l d5, d0
000010F0  E588                     166      lsl.l #2, d0    ; Multiply by size of each index
000010F2  95C0                     167      sub.l d0, a2
000010F4                           168          
000010F4                           169      ; Let's also move the Current Pixel Address to the start of the next row.
000010F4  2005                     170      move.l d5, d0           ; Move pointer back by 2xImageWidth
000010F6  D085                     171      add.l d5, d0
000010F8  E588                     172      lsl.l #2, d0
000010FA  91C0                     173      sub.l d0, a0
000010FC                           174          
000010FC                           175      ; Have we passed the end of the chunk?
000010FC  B7C8                     176      cmp.l a0, a3            ; Is Current Pixel Address past the index of End of Chunk index?
000010FE  6F00 FFA8                177      ble.l GetSinglePixel    ; If not, continue the loop
00001102                           178          
00001102                           179      ; If so, we've finished sorting.
00001102  4CDF 7FFF                180      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001106                           181  
00001106  4E75                     182      rts
00001108                           183  
00001108                           184  ParseLittleEndianLong:  ; Simple function to convert d1 LW from Little Endian to Big Endian
00001108  E159                     185      rol.w #8, d1
0000110A  4841                     186      swap d1
0000110C  E159                     187      rol.w #8, d1
0000110E                           188          
0000110E  4E75                     189      rts
00001110                           190  
00001110                           191  
00001110                           192  -------------------- end include --------------------
00001110                           193      INCLUDE "./renderer.x68"      ; Handles printing sprites & affine transformations.
00001110                           194  
00001110                           195  r_PrintImage: 
00001110  48E7 FFFE                196      movem.l ALL_REG, -(sp)  *| Push registers to stack
00001114                           197  
00001114                           198      *| Move starting variables to non-volatile positions
00001114  2400                     199      move.l d0, d2           ; offset: vec2
00001116  2010                     200      move.l (a0), d0         ; Image dimensions
00001118                           201  
00001118  B2BC 00000000            202      cmp.l #0, d1    ; Is this a sprite?
0000111E  6700 0014                203      beq.l .LoadVarsToRegisters            ; If not, let's skip this step.
00001122                           204      *| We need to store the offset: vec2 and image dimensions: vec2
00001122                           205      *| for clearing next frame's data.
00001122                           206      
00001122  2279 00262EA2            207      move.l pixel_clear_length, a1
00001128  2282                     208      move.l d2, (a1)  ; Move image offset to pixel_clear_zones
0000112A  5889                     209      add.l #4, a1     ; Move to next word
0000112C  2280                     210      move.l d0, (a1)  ; Move image dimensions to pixel_clear_zones
0000112E  50B9 00262EA2            211      add.l #8, pixel_clear_length     ; Move to next word
00001134                           212  
00001134                           213  .LoadVarsToRegisters:
00001134                           214  
00001134                           215      *| Set up the starting variables for printing pixels
00001134  2602                     216      move.l d2, d3
00001136  E08B                     217      lsr.l #8, d3            ; Offset X
00001138  E08B                     218      lsr.l #8, d3
0000113A  C4BC 0000FFFF            219      and.l #$0000FFFF, d2    ; Offset Y
00001140                           220         
00001140  2200                     221      move.l d0, d1
00001142  E088                     222      lsr.l #8, d0            ; Image Width (left word)
00001144  E088                     223      lsr.l #8, d0
00001146  2800                     224      move.l d0, d4           ; Store width in d4 to prevent destruction
00001148  C2BC 0000FFFF            225      and.l #$0000FFFF, d1    ; Image Height (right word)
0000114E                           226          
0000114E  2A03                     227      move.l d3, d5           ; Start X Position
00001150                           228      
00001150  4286                     229      clr.l d6
00001152  3C03                     230      move.w d3, d6           ; End X Position
00001154  DC80                     231      add.l d0, d6
00001156  5386                     232      sub.l #1, d6
00001158                           233          
00001158  4287                     234      clr.l d7
0000115A  3E02                     235      move.w d2, d7           ; End Y Position
0000115C  DE81                     236      add.l d1, d7
0000115E  5387                     237      sub.l #1, d7
00001160                           238      
00001160  5888                     239      add.l #4, a0
00001162                           240          
00001162                           241  .PrintPixel:
00001162  2210                     242      move.l (a0), d1             ; Get current pixel color
00001164                           243  
00001164  B2BC 00FFFFFF            244      cmp.l #$00FFFFFF, d1        ; Is pixel color transparent?
0000116A  6300 0012                245      bls.l .NoPrint              ; If so, let's skip printing
0000116E                           246      
0000116E  7050                     247      move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
00001170                           248  
00001170  C2BC 00FFFFFF            249      and.l #$00FFFFFF, d1        ; Chop off alpha
00001176                           250          
00001176  4E4F                     251      TRAP #15
00001178                           252                 
00001178  7052                     253      move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
0000117A  2203                     254      move.l d3, d1               ; Pixel X location must be extracted 
0000117C                           255     
0000117C  4E4F                     256      TRAP #15
0000117E                           257        
0000117E                           258  .NoPrint:
0000117E                           259      ; Calculate the next target pixel.
0000117E  5888                     260      add.l #4, a0            ; Move pointer to next color pixel
00001180                           261          
00001180  5283                     262      add.l #1, d3            ; Move X to the next column
00001182  B686                     263      cmp.l d6, d3            ; Is X past End X Position?
00001184  6300 FFDC                264      bls.l .PrintPixel        ; If not, keep on printing
00001188                           265          
00001188                           266      ; Otherwise, we move to the next row
00001188  9684                     267      sub.l d4, d3            ; Move X back to the starting column
0000118A  5282                     268      add.l #1, d2            ; Move Y down a row
0000118C                           269          
0000118C  B487                     270      cmp.l d7, d2            ; Is Y past End Y Position?
0000118E  6F00 FFD2                271      ble.l .PrintPixel         ; If not, keep printing.
00001192                           272  
00001192                           273  .Return:
00001192                           274  
00001192  4CDF 7FFF                275      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001196                           276  
00001196  4E75                     277      rts
00001198                           278  
00001198                           279  
00001198                           280  r_ClearSprites:
00001198  48E7 FFFE                281      movem.l ALL_REG, -(sp) *| Push registers to stack
0000119C                           282  
0000119C                           283  .LoadRegister:
0000119C  207C 00262E02            284      move.l #pixel_clear_zones, a0    ; Current sprite index
000011A2  2279 00262EA2            285      move.l (pixel_clear_length), a1   ; End sprite index
000011A8  247C 001329BA            286      move.l #pg_Background, a2        ; Background
000011AE                           287  
000011AE                           288      ; Is pixel clear zones empty?
000011AE  B3C8                     289      cmp.l a0, a1
000011B0  6700 006E                290      beq.l .Return                ; If list is empty, simply return.
000011B4                           291  
000011B4                           292  .GetSprite:
000011B4                           293      *| Extracting offset into registers for processing.
000011B4  2610                     294      move.l (a0), d3                 ; offset: vec2
000011B6                           295      
000011B6  2403                     296      move.l d3, d2                   ; Separate into two registers
000011B8                           297  
000011B8  E08B                     298      lsr.l #8, d3                    ; Offset X: int
000011BA  E08B                     299      lsr.l #8, d3                    ; Will be used as Current X for loop
000011BC                           300  
000011BC  C4BC 0000FFFF            301      and.l #$0000FFFF, d2            ; Offset Y: int
000011C2                           302                                      ; Will be used as Current Y for loop
000011C2                           303  
000011C2                           304      *| Extracting dimensions to registers for processing
000011C2  5888                     305      add.l #4, a0                    ; Push to next long
000011C4  2810                     306      move.l (a0), d4                 ; dimensions: vec2
000011C6  2A04                     307      move.l d4, d5                   ; Separate into two registers
000011C8                           308  
000011C8  E08C                     309      lsr.l #8, d4                    ; Width: int
000011CA  E08C                     310      lsr.l #8, d4
000011CC                           311  
000011CC  CABC 0000FFFF            312      and.l #$0000FFFF, d5            ; Height: int
000011D2                           313  
000011D2                           314      *| Get ending x and y positions
000011D2  2C03                     315      move.l d3, d6                   ; X Offset
000011D4  DC84                     316      add.l d4, d6                    ; Plus Width
000011D6                           317                                      ; = End X Pos
000011D6                           318      
000011D6  2E02                     319      move.l d2, d7                   ; Y Offset
000011D8  DE85                     320      add.l d5, d7                    ; Plus Height
000011DA                           321                                      ; = End Y Pos
000011DA                           322  
000011DA                           323  .ClearSprite:
000011DA                           324      *,__________________________________________________,
000011DA                           325      *| For Loop: for x = Offset X, x < Offset X + Width, x++
000011DA                           326  .ClearPixel:
000011DA                           327              *| Get Background Pixel
000011DA  2202                     328              move.l d2, d1   ; Get offset to pixel address of background.
000011DC  C2FC 0280                329              mulu.w #SCREEN_WIDTH, d1   ; multiplied by width
000011E0  D283                     330              add.l d3, d1    ; plus X offset
000011E2                           331              
000011E2  5281                     332              add.l #1, d1    ; + 1 to account for dimension data in Pixel Grid 
000011E4  E589                     333              lsl.l #2, d1    ; Multiplied by size of Long
000011E6                           334  
000011E6  264A                     335              move.l a2, a3   ; Add this to the address of the pixel grid
000011E8  D7C1                     336              add.l d1, a3    ; Shifting offset to the desired pixel
000011EA  2213                     337              move.l (a3), d1 ; Overwrite d1 to save register space
000011EC                           338                              ; d1 now stores the hex color of the pixel
000011EC                           339              
000011EC                           340  .PrintBgPixel:
000011EC                           341              *| Note that we set up the previous registers so all data
000011EC                           342              *| is in the right location. X is in d3 but will be moved to d1
000011EC                           343              *| once the first trap is done.
000011EC  7050                     344              move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
000011EE                           345                  
000011EE                           346              ; TODO: Make backround have no alpha so we can remove this line
000011EE  C2BC 00FFFFFF            347              and.l #$00FFFFFF, d1        ; Chop off alpha
000011F4                           348  
000011F4  4E4F                     349              TRAP #15
000011F6                           350  
000011F6  2203                     351              move.l d3, d1               ; Move X pos to correct register
000011F8                           352                                          ; Y pos is already in correct register.   
000011F8                           353                      
000011F8  7052                     354              move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
000011FA                           355          
000011FA  4E4F                     356              TRAP #15
000011FC                           357  
000011FC  5283                     358              add.l #1, d3    ; x += 1
000011FE  B686                     359              cmp.l d6, d3    ; is x past end x pos?
00001200  6F00 FFD8                360              ble.l .ClearPixel ; if not, continue parsing pixels
00001204                           361      *| End For Loop
00001204                           362  
00001204  9684                     363      sub.l d4, d3    ; Move x back to start location
00001206  5383                     364      sub.l #1, d3    ; - 1 for extra space moved past width.
00001208                           365  
00001208  5282                     366      add.l #1, d2    ; y += 1
0000120A  B487                     367      cmp.l d7, d2    ; Is y past end Y pos?
0000120C  6300 FFCC                368      bls.l .ClearSprite  ; If not, continue to next loop
00001210                           369  
00001210                           370  .CheckEndOfSprites:
00001210  B3C8                     371      cmp.l a0, a1                    ; Is current sprite index at or past end sprite index?
00001212  6300 FFA0                372      bls.l .GetSprite                ; If not, let's keep on going.
00001216                           373  
00001216                           374      ; If we're done, we reset the clear zones as we have emptied it out
00001216  23FC 00262E02 00262EA2   375      move.l #pixel_clear_zones, pixel_clear_length
00001220                           376  
00001220                           377  .Return:
00001220                           378  
00001220  4CDF 7FFF                379      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001224                           380  
00001224  4E75                     381      rts
00001226                           382  
00001226                           383  SwapBuffer:
00001226  2F00                     384      move.l d0, -(sp)
00001228                           385      
00001228  705E                     386      move.l #SWAP_BUFFER, d0
0000122A                           387      
0000122A  4E4F                     388      TRAP #15
0000122C                           389  
0000122C  201F                     390      move.l (sp)+, d0
0000122E                           391  
0000122E  4E75                     392      rts
00001230                           393  
00001230                           394  -------------------- end include --------------------
00001230                           395      INCLUDE "./inputs.x68"        ; Handles player inputs for processing
00001230                           396  
00001230  =0000000D                397  ENTER               EQU $D
00001230  =0000001B                398  ESC                 EQU $1B
00001230  =00000010                399  SHIFT               EQU $10
00001230  =00000020                400  SPACE               EQU $20
00001230                           401  
00001230                           402  i_CaptureInputs:
00001230  48E7 C0E0                403      movem.l TRAP_REG, -(sp) *| Push registers to stack
00001234                           404  
00001234  7013                     405      move.l #GET_KEY_INPUT_COMMAND, d0
00001236  223C 57415344            406      move.l #'W'<<24+'A'<<16+'S'<<8+'D', d1   ; WASD Inputs
0000123C                           407      
0000123C  4E4F                     408      TRAP #15
0000123E                           409      
0000123E  2601                     410      move.l d1, d3   ; d3 stores WASD Inputs for later processing
00001240                           411      
00001240  223C 0D1B1020            412      move.l #ENTER<<24+ESC<<16+SHIFT<<8+SPACE, d1   ; Enter, Esc, Shift, and Space Inputs
00001246                           413      
00001246  4E4F                     414      TRAP #15
00001248                           415      
00001248  2801                     416      move.l d1, d4   ; d4 stores other Inputs for later processing
0000124A                           417      
0000124A                           418  .Return:
0000124A  4CDF 0703                419      movem.l (sp)+, TRAP_REG *| Pull registers from stack
0000124E                           420  
0000124E  4E75                     421      rts
0000124E  4E75                     422  -------------------- end include --------------------
00001250                           423  * INCLUDE "./gameplay.x68"      ; Handles in-game timer, lap counter, and game states
00001250                           424      INCLUDE "./physics.x68"       ; Calculates player acceleration, velocity, and collisions.
00001250                           425  
00001250  =00030000                426  MAX_VELOCITY        EQU $00030000
00001250  =01680000                427  FP_360              EQU $01680000   ; Hex value for 360 degrees in 16.16 fixed point
00001250  =00168000                428  FP_22P5             EQU $00168000   ; Hex value for 22.5 degrees in 16.16 fixed point
00001250  =000B4000                429  FP_11P25            EQU $000B4000   ; Hex value for 11.25 degrees in 16.16 fixed point
00001250                           430  
00001250  =00000100                431  ACCEL_AMOUNT        EQU $00000100   ; Increases speed at 0.125 pixels per frame 
00001250  =00000100                432  DECEL_AMOUNT        EQU $00000100   ; Increases speed at 0.0625 pixels per frame 
00001250                           433  
00001250  =00001000                434  MAX_SPEED           EQU $00001000
00001250                           435  
00001250                           436  ph_CalculateRotation:
00001250  48E7 C0E0                437      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001254                           438  
00001254  2003                     439      move.l d3, d0   ; Copying WASD inputs to extract A & D
00001256  2200                     440      move.l d0, d1
00001258                           441  
00001258  E088                     442      lsr.l #8, d0            ; A key input
0000125A  E088                     443      lsr.l #8, d0
0000125C  C0BC 000000FF            444      and.l #$000000FF, d0    ; Chopping off W input
00001262                           445  
00001262  C2BC 000000FF            446      and.l #$000000FF, d1    ; D key input
00001268                           447  
00001268  B280                     448      cmp.l d0, d1            ; Are A & D both pressed or not pressed?
0000126A  6700 004A                449      beq.l .Return           ; If so, let's skip to the end.
0000126E                           450  
0000126E                           451  .TurnLeft:
0000126E  B0BC 00000000            452      cmp.l #0, d0
00001274  6700 000E                453      beq.l .TurnRight
00001278                           454  
00001278  0482 00013880            455      sub.l #00080000, d2
0000127E                           456  
0000127E  4EF9 0000128A            457      jmp .FixAngle
00001284                           458  
00001284                           459  .TurnRight:
00001284  0682 00013880            460      add.l #00080000, d2
0000128A                           461      
0000128A                           462  .FixAngle:
0000128A  B4BC 01680000            463      cmp.l #FP_360, d2       ; Is d2 greater than 360?
00001290  6E00 0012                464      bgt.l .AngleOver
00001294  B4BC 00000000            465      cmp.l #0, d2            ; Is d2 negative?
0000129A  6D00 0014                466      blt.l .AngleUnder
0000129E                           467  
0000129E  4EF9 000012B6            468      jmp .Return
000012A4                           469  
000012A4                           470  .AngleOver:
000012A4  0482 01680000            471      sub.l #FP_360, d2          
000012AA                           472  
000012AA  4EF9 000012B6            473      jmp .Return
000012B0                           474  
000012B0                           475  .AngleUnder:
000012B0  0682 01680000            476      add.l #FP_360, d2
000012B6                           477  
000012B6                           478  .Return
000012B6  4CDF 0703                479      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000012BA                           480  
000012BA  4E75                     481      rts
000012BC                           482  
000012BC                           483  ph_SelectShipRotation:
000012BC  48E7 C0E0                484      movem.l TRAP_REG, -(sp)  *| Push registers to stack
000012C0                           485  
000012C0  2002                     486      move.l d2, d0   ; Take angle to temporary variable
000012C2  7200                     487      move.l #0, d1   ; d1 stores ship index
000012C4  0480 000B4000            488      sub.l #FP_11P25, d0 ; Subtract angle by 11.25
000012CA                           489  
000012CA                           490  .NextRot:
000012CA  5281                     491      add.l #1, d1        
000012CC                           492  
000012CC  0480 00168000            493      sub.l #FP_22P5, d0  ; Subtract angle by 11.25
000012D2  B0BC 00000000            494      cmp.l #0, d0        ; Is angle under 0?
000012D8  6C00 FFF0                495      bge.l .NextRot      ; If not, get next rotation
000012DC                           496  
000012DC                           497      ; We de-increment by 1 to go back to the desired index
000012DC  5381                     498      sub.l #1, d1
000012DE                           499  
000012DE  B2BC 00000010            500      cmp.l #16, d1       ; Is d1 greater than 15?
000012E4  6D00 0004                501      blt.l .GetFile      ; If not, we ignore the next step
000012E8                           502  
000012E8  7200                     503      move.l #0, d1       ; If we went past 15, we reset back to the first index
000012EA                           504  
000012EA                           505  .GetFile:
000012EA  C2FC 0404                506      mulu.w #1028, d1     ; Multiply by size of ship's pixel grid
000012EE  0681 0025E9BE            507      add.l #pg_ShipRotations, d1
000012F4  2641                     508      move.l d1, a3
000012F6                           509  
000012F6                           510  .Return
000012F6  4CDF 0703                511      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000012FA                           512  
000012FA  4E75                     513      rts
000012FC                           514  
000012FC                           515  ph_CalcVelMagnitude:
000012FC  48E7 C0E0                516      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001300                           517  
00001300  2003                     518      move.l d3, d0           ; Copying WASD inputs to extract A & D
00001302  2200                     519      move.l d0, d1
00001304                           520  
00001304  E088                     521      lsr.l #8, d0            ; W key input
00001306  E088                     522      lsr.l #8, d0
00001308  E088                     523      lsr.l #8, d0
0000130A                           524  
0000130A  E089                     525      lsr.l #8, d1            ; S key input
0000130C  C2BC 000000FF            526      and.l #$000000FF, d1    
00001312                           527  
00001312  B280                     528      cmp.l d0, d1            ; Are S & S both pressed or not pressed?
00001314  6700 0046                529      beq.l .Fric             ; If so, let's apply friction.
00001318                           530  
00001318  B0BC 00000000            531      cmp.l #0, d0            ; Are we accelerating?
0000131E  6700 000E                532      beq.l .Decel            ; If not, then we must be decelerating. 
00001322                           533  
00001322                           534  .Accel: ; Move forwards
00001322  0687 00000100            535      add.l #ACCEL_AMOUNT, d7 
00001328                           536  
00001328                           537      ; if boosting, add more?
00001328                           538  
00001328  4EF9 00001334            539      jmp .Clamp
0000132E                           540  
0000132E                           541  .Decel: ; Move backwards
0000132E  0487 00000100            542      sub.l #DECEL_AMOUNT, d7 
00001334                           543  
00001334                           544  .Clamp:
00001334                           545  .ClampMin:
00001334  BEBC 00000000            546      cmp.l #0, d7    
0000133A  6C00 000A                547      bge.l .ClampMax
0000133E                           548  
0000133E  7E00                     549      move.l #0, d7
00001340                           550  
00001340  4EF9 0000136A            551      jmp .Return
00001346                           552  
00001346                           553  .ClampMax:
00001346  BEBC 00001000            554      cmp.l #MAX_SPEED, d7
0000134C  6F00 001C                555      ble.l .Return
00001350                           556  
00001350  2E3C 00001000            557      move.l #MAX_SPEED, d7
00001356                           558  
00001356  4EF9 0000136A            559      jmp .Return
0000135C                           560  
0000135C                           561  .Fric:  ; Return to 0 over time while not boosting
0000135C  E387                     562      asl.l #1, d7
0000135E  BEBC FFFFFFFF            563      cmp.l #$FFFFFFFF, d7    ; Is d7 at its lowest possible value?
00001364  6600 0004                564      bne.l .Return           ; If not, skip this next step
00001368                           565  
00001368  7E00                     566      move.l #0, d7           ; Return to 0 rather than being stuck at almost -0
0000136A                           567  
0000136A                           568  .Return:
0000136A  4CDF 0703                569      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
0000136E                           570  
0000136E  4E75                     571      rts
00001370                           572  
00001370                           573  ph_CalcVelDir:
00001370  48E7 C0E0                574      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001374                           575  
00001374  2002                     576      move.l d2, d0           ; Move angle to register for processing
00001376  E088                     577      lsr.l #8, d0
00001378  E088                     578      lsr.l #8, d0
0000137A  80FC 0168                579      divu.w #360, d0         ; Modulo to keep within 360 degrees
0000137E  C0BC FFFF0000            580      and.l #$FFFF0000, d0
00001384                           581      
00001384  4EB9 000014A0            582      jsr ph_Sine             ; sin
0000138A                           583  
0000138A                           584      ; We're done with WASD inputs so we can now use d3 for operations
0000138A  2600                     585      move.l d0, d3           ; Storing sin(theta)
0000138C  2002                     586      move.l d2, d0           ; Move angle to d0 again    
0000138E  0680 005A0000            587      add.l #$005A0000, d0    ; Add pi / 2 to get cosine
00001394  E088                     588      lsr.l #8, d0
00001396  E088                     589      lsr.l #8, d0
00001398  80FC 0168                590      divu.w #360, d0         ; Modulo to keep within 360 degrees
0000139C  C0BC FFFF0000            591      and.l #$FFFF0000, d0
000013A2                           592  
000013A2  4EB9 000014A0            593      jsr ph_Sine             ;cos
000013A8                           594  
000013A8                           595      ; Now d3 holds sin(theta) and d0 holds cos(theta)
000013A8                           596  
000013A8                           597      ; Multiply velocity magnitude by x component
000013A8  2C07                     598      move.l d7, d6
000013AA  E08E                     599      lsr.l #8, d6
000013AC  CCBC 0000FFFF            600      and.l #$0000FFFF, d6
000013B2                           601  
000013B2  CDC3                     602      muls.w d3, d6   ; d6 now holds 8.8 x component
000013B4  E08E                     603      lsr.l #8, d6
000013B6  CCBC 0000FFFF            604      and.l #$0000FFFF, d6 ; Reduce to 4.4
000013BC  2606                     605      move.l d6, d3   ; Store x component in d3
000013BE  E18B                     606      lsl.l #8, d3
000013C0  E18B                     607      lsl.l #8, d3    ; Move over to left side for eventual merge
000013C2                           608  
000013C2                           609      ; Multiply velocity magnitude by y component    
000013C2  2C07                     610      move.l d7, d6
000013C4  E08E                     611      lsr.l #8, d6
000013C6  CCBC 0000FFFF            612      and.l #$0000FFFF, d6
000013CC                           613      
000013CC  CDC0                     614      muls.w d0, d6   ; d5 now holds 8.8 y component
000013CE  E08E                     615      lsr.l #8, d6
000013D0  CCBC 0000FFFF            616      and.l #$0000FFFF, d6 ; Reduce to 4x4
000013D6  2006                     617      move.l d6, d0   ; Store y component in d0
000013D8                           618      
000013D8  8083                     619      or.l d3, d0 ; Merge x and y to form final vector
000013DA                           620  
000013DA  2C00                     621      move.l d0, d6   ; Move final result to final location for processing
000013DC                           622  
000013DC                           623  .Return:
000013DC  4CDF 0703                624      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000013E0                           625  
000013E0  4E75                     626      rts
000013E2                           627  
000013E2                           628  ph_CalculatePosition:
000013E2  48E7 C0E0                629      movem.l TRAP_REG, -(sp)  *| Push registers to stack
000013E6                           630  
000013E6  2006                     631      move.l d6, d0
000013E8  2200                     632      move.l d0, d1 
000013EA                           633  
000013EA  E088                     634      lsr.l #8, d0
000013EC  E088                     635      lsr.l #8, d0
000013EE  C2BC 0000FFFF            636      and.l #$0000FFFF, d1
000013F4                           637      
000013F4  E140                     638      asl.w #8, d0            ; X adjusted to 16.16
000013F6  80BC FF000000            639      or.l #$FF000000, d0
000013FC                           640  
000013FC  E041                     641      asr.w #8, d1            ; Y adjusted to 16.16
000013FE  82BC FF000000            642      or.l #$FF000000, d1
00001404                           643  
00001404                           644      ; Update precise ship position
00001404  287C 000015E4            645      move.l #ShipPosition, a4
0000140A                           646  
0000140A  D094                     647      add.l (a4), d0  ; Ship X Position 
0000140C  588C                     648      add.l #4, a4
0000140E  D294                     649      add.l (a4), d1  ; Ship Y Position
00001410                           650  
00001410  2881                     651      move.l d1, (a4)
00001412  598C                     652      sub.l #4, a4
00001414  2881                     653      move.l d1, (a4)
00001416                           654  
00001416                           655      ; Now, update integer ship position (pixel)
00001416                           656  
00001416  C0BC FFFF0000            657      and.l #$FFFF0000, d0    ; X is already in position
0000141C  E089                     658      lsr.l #8, d1            ; Y is shifted right, for once.
0000141E  E089                     659      lsr.l #8, d1
00001420                           660  
00001420  8280                     661      or.l d0, d1
00001422                           662  
00001422  2A01                     663      move.l d1, d5
00001424                           664  
00001424                           665  .Return:
00001424  4CDF 0703                666      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
00001428                           667  
00001428  4E75                     668      rts
0000142A                           669  
0000142A                           670  ph_ClampNumber:
0000142A  2F02                     671      move.l d2, -(sp) ; Temporarily move d2 out of the way
0000142C                           672  
0000142C  2401                     673      move.l d1, d2
0000142E  E089                     674      lsr.l #8, d1
00001430  E089                     675      lsr.l #8, d1
00001432  C4BC 0000FFFF            676      and.l #$0000FFFF, d2
00001438                           677  
00001438                           678      *| Compare by word here because it is signed 
00001438  B041                     679      cmp.w d1, d0    ; Is value less than min?
0000143A  6D00 000E                680      blt .Under    
0000143E                           681      
0000143E  B042                     682      cmp.w d2, d0    ; Is value greater than max?
00001440  6E00 0010                683      bgt.l .Over
00001444                           684  
00001444  4EF9 0000145A            685      jmp .Return     ; Within range, do nothing
0000144A                           686  
0000144A                           687  .Under:     ; We need to clamp value to min
0000144A  2001                     688      move.l d1, d0
0000144C                           689  
0000144C  4EF9 0000145A            690      jmp .Return
00001452                           691  
00001452                           692  .Over:      ; We need to clamp value to max
00001452  2002                     693      move.l d2, d0
00001454                           694  
00001454  4EF9 0000145A            695      jmp .Return
0000145A                           696  
0000145A                           697  .Return:
0000145A  241F                     698      move.l (sp)+, d2
0000145C                           699  
0000145C  4E75                     700      rts
0000145E                           701  
0000145E                           702  ph_ClampVector:
0000145E  2F02                     703      move.l d2, -(sp)    ; Temporarily move d2 out of the way
00001460  2F03                     704      move.l d3, -(sp)    ; Temporarily move d3 out of the way
00001462                           705  
00001462  2401                     706      move.l d1, d2       ; Extract X & Y value of vector
00001464  2602                     707      move.l d2, d3
00001466  E08A                     708      lsr.l #8, d2
00001468  E08A                     709      lsr.l #8, d2
0000146A  C6BC 0000FFFF            710      and.l #$0000FFFF, d3
00001470                           711  
00001470  C5C2                     712      muls.w d2, d2   ; x ^ 2
00001472  C7C3                     713      muls.w d3, d3   ; y ^ 2
00001474  D682                     714      add.l d2, d3    ; x ^ 2 + y ^ 2 = c ^ 2
00001476                           715  
00001476                           716      ; (x ^ 2) + (y ^ 2) must be converted from 16.16 to 8.8
00001476  E08B                     717      lsr.l #8, d3
00001478  C6BC 0000FFFF            718      and.l #$0000FFFF, d3
0000147E                           719  
0000147E  B680                     720      cmp.l d0, d3    ; Is magnitude greater than max?
00001480  6F00 0018                721      ble.l .Return   ; If not, carry on as usual
00001484                           722  
00001484                           723      ; If so, let's CUT IT IN HALF muahahaha
00001484  2401                     724      move.l d1, d2
00001486                           725  
00001486  E08A                     726      lsr.l #8, d2
00001488  E08A                     727      lsr.l #8, d2
0000148A  C2BC 0000FFFF            728      and.l #$0000FFFF, d1
00001490                           729      
00001490  E242                     730      asr.w #1, d2            ; X
00001492  E241                     731      asr.w #1, d1            ; Y
00001494                           732      
00001494  E18A                     733      lsl.l #8, d2
00001496  E18A                     734      lsl.l #8, d2
00001498                           735  
00001498  8282                     736      or.l d2, d1
0000149A                           737  
0000149A                           738  .Return:
0000149A  261F                     739      move.l (sp)+, d3
0000149C  241F                     740      move.l (sp)+, d2
0000149E                           741  
0000149E  4E75                     742      rts
000014A0                           743  
000014A0                           744  ph_Sine:
000014A0  E088                     745      lsr.l #8, d0
000014A2  E088                     746      lsr.l #8, d0        ; Chopping off fractional
000014A4                           747  
000014A4  B0BC 0000005A            748      cmp.l #90, d0       ; Is the angle greater than 90?
000014AA  6D00 001C                749      blt.l .Q1           ; If not, we're in quadrant 1
000014AE                           750      
000014AE  B0BC 000000B4            751      cmp.l #180, d0      ; Is the angle greater than 180?
000014B4  6D00 0024                752      blt.l .Q2           ; If not, we're in quadrant 2
000014B8                           753  
000014B8  B0BC 0000010E            754      cmp.l #270, d0      ; Is the angle greater than 270?
000014BE  6D00 0038                755      blt.l .Q3           ; If not, we're in quadrant 3
000014C2                           756      
000014C2  4EF9 00001512            757      jmp .Q4             ; We are in quadrant 4 by process of elimination
000014C8                           758  
000014C8                           759  .Q1:    ; Quadrant 1
000014C8  E388                     760      lsl.l #1, d0        ; Multiply by 2 (length of word)
000014CA                           761  
000014CA  207C 0000152E            762      move.l #sinTable, a0
000014D0  D1C0                     763      add.l d0, a0        ; Offset to desired index of sin table
000014D2                           764  
000014D2  3010                     765      move.w (a0), d0     ; Extract fractional
000014D4                           766  
000014D4  4EF9 0000152C            767      jmp .Return
000014DA                           768  
000014DA                           769  .Q2:    ; Quadrant 2
000014DA  0480 0000005A            770      sub.l #90, d0       ; Start at 90 degrees
000014E0  E388                     771      lsl.l #1, d0        ; Multiply by 2 (length of word)
000014E2                           772  
000014E2  207C 0000152E            773      move.l #sinTable, a0
000014E8  D1FC 000000B4            774      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
000014EE  91C0                     775      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
000014F0                           776  
000014F0  3010                     777      move.w (a0), d0     ; Extract fractional
000014F2                           778  
000014F2  4EF9 0000152C            779      jmp .Return
000014F8                           780  
000014F8                           781  .Q3:    ; Quadrant 3
000014F8  0480 000000B4            782      sub.l #180, d0       ; Start at 180 degrees
000014FE  E388                     783      lsl.l #1, d0        ; Multiply by 2 (length of word)
00001500                           784  
00001500  207C 0000152E            785      move.l #sinTable, a0
00001506  D1C0                     786      add.l d0, a0        ; Offset to desired index of sin table
00001508                           787  
00001508  3010                     788      move.w (a0), d0     ; Extract fractional
0000150A  4440                     789      neg.w d0            ; Flip to negative
0000150C                           790  
0000150C  4EF9 0000152C            791      jmp .Return
00001512                           792  
00001512                           793  .Q4:    ; Quadrant 4
00001512  0480 0000010E            794      sub.l #270, d0       ; Start at 90 degrees
00001518  E388                     795      lsl.l #1, d0         ; Multiply by 2 (length of word)
0000151A                           796  
0000151A  207C 0000152E            797      move.l #sinTable, a0
00001520  D1FC 000000B4            798      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
00001526  91C0                     799      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
00001528                           800  
00001528  3010                     801      move.w (a0), d0     ; Extract fractional
0000152A                           802  
0000152A  4440                     803      neg.w d0            ; Flip to negative
0000152C                           804  
0000152C                           805  .Return:
0000152C                           806  
0000152C  4E75                     807      rts
0000152E                           808  
0000152E= 0000 0047 008E 0...      809  sinTable        dc.w    $0,$47,$8E,$D6,$11D,$164,$1AC,$1F3,$23A,$280,$2C7
00001544= 030D 0353 0399 0...      810                  dc.w    $30D,$353,$399,$3DE,$424,$469,$4AD,$4F1,$535
00001556= 0578 05BB 05FE 0...      811                  dc.w    $578,$5BB,$5FE,$640,$681,$6C3,$703,$743,$782
00001568= 07C1 07FF 083D 0...      812                  dc.w    $7C1,$7FF,$83D,$87A,$8B6,$8F2,$92D,$967,$9A1
0000157A= 09D9 0A11 0A48 0...      813                  dc.w    $9D9,$A11,$A48,$A7F,$AB4,$AE9,$B1D,$B50,$B82
0000158C= 0BB3 0BE3 0C13 0...      814                  dc.w    $BB3,$BE3,$C13,$C41,$C6F,$C9B,$CC7,$CF1,$D1B
0000159E= 0D43 0D6B 0D91 0...      815                  dc.w    $D43,$D6B,$D91,$DB6,$DDB,$DFE,$E20,$E41,$E61
000015B0= 0E80 0E9D 0EBA 0...      816                  dc.w    $E80,$E9D,$EBA,$ED5,$EEF,$F08,$F20,$F37,$F4D
000015C2= 0F61 0F74 0F86 0...      817                  dc.w    $F61,$F74,$F86,$F97,$FA6,$FB4,$FC1,$FCD,$FD8
000015D4= 0FE1 0FE9 0FF0 0...      818                  dc.w    $FE1,$FE9,$FF0,$FF6,$FFA,$FFD,$FFF,$FFF
000015E4                           819  
000015E4  =000000B4                820  SINTABLESIZE            EQU 180 ; 90 * 2 (word size)
000015E4                           821  
000015E4= 02210000 012C0000        822  ShipPosition        dc.l $02210000,$012C0000  ; Position in 16.16 fixed point
000015E4= 02210000 012C0000        823  -------------------- end include --------------------
000015EC                           824  * INCLUDE "./7_segment_led.x68" ; Displays a 7-segment LED with the given parameters.
000015EC                           825  
000015EC                           826  *,__________________________________________________,
000015EC                           827  *| fn Main
000015EC                           828  *| Description: Loads files, sets game state, begins
000015EC                           829  *|              game loop, and handles quit state
00002000                           830  START ORG $2000
00002000                           831  Main:
00002000                           832      ; Initialize pixel_clear_length
00002000  23FC 00262E02 00262EA2   833      move.l #pixel_clear_zones, pixel_clear_length
0000200A                           834  
0000200A  705C                     835      move.l #92, d0
0000200C  7211                     836      move.l #17, d1
0000200E                           837      
0000200E  4E4F                     838      TRAP #15
00002010                           839  
00002010  4EB8 1000                840      jsr fl_LoadFiles
00002014                           841      
00002014  7000                     842      move.l #$00000000, d0   ; Position has no offset
00002016  7200                     843      move.l #$00000000, d1   ; This is not a sprite, it's the background
00002018  207C 001329BA            844      move.l #pg_Background, a0
0000201E  4EB8 1110                845      jsr r_PrintImage
00002022                           846      
00002022                           847      ; Set up start variables for game loop
00002022  2A3C 0221012C            848      move.l #$0221012C, d5   ; Start position of ship   
00002028                           849  
00002028  7008                     850      move.l #8, d0
0000202A  4E4F                     851      TRAP #15
0000202C                           852  
0000202C  4EB9 00002036            853      jsr GameLoop
00002032                           854  
00002032  4E72 3000                855      STOP #$3000
00002036                           856  *| [End of Function] Main
00002036                           857  *|__________________________________________________
00002036                           858  *`                                                  `
00002036                           859  
00002036                           860  *,__________________________________________________,
00002036                           861  *| fn GameLoop
00002036                           862  *| Description: Perpetually runs game until the quit 
00002036                           863  *| command is given.
00002036                           864  *| Persistent Variables:
00002036                           865  *| d2: Rotation, DeltaTime 
00002036                           866  *| d3: WASD Inputs, d4: Enter, Esc, Shift, and Space Inputs
00002036                           867  *| d5: Position, d6: Velocity, d7: Acceleration
00002036                           868  *| a3: Ship model to use
00002036                           869  GameLoop:
00002036  7008                     870      move.l #8, d0  ; Time Code - maybe reuse later?
00002038                           871  
00002038  4E4F                     872      TRAP #15
0000203A                           873  
0000203A  2001                     874      move.l d1, d0
0000203C  90B9 0000208C            875      sub.l LastTime, d0
00002042  B0BC 00000003            876      cmp.l #3, d0            ; Is time elapsed less than 5 seconds?
00002048  6300 FFEC                877      bls.l GameLoop          ; If not, wait
0000204C  23C1 0000208C            878      move.l d1, LastTime     ; Otherwise, this is the new last time
00002052                           879  
00002052                           880      *,___________________________,
00002052                           881      *| STAGE ONE: Capture Inputs |
00002052                           882      *|___________________________|
00002052                           883      *`                           ` 
00002052  4EB8 1230                884      jsr i_CaptureInputs   ; Fills registers d3-d4 (destructively) with player inputs
00002056                           885  
00002056                           886      *,___________________________,
00002056                           887      *| STAGE TWO: Physics Pass   |
00002056                           888      *|___________________________|
00002056                           889      *`                           `
00002056  4EB8 1250                890      jsr ph_CalculateRotation
0000205A  4EB8 12BC                891      jsr ph_SelectShipRotation
0000205E                           892  
0000205E  4EB8 12FC                893      jsr ph_CalcVelMagnitude
00002062  4EB8 1370                894      jsr ph_CalcVelDir
00002066  4EB8 13E2                895      jsr ph_CalculatePosition
0000206A                           896  
0000206A                           897      *,___________________________,
0000206A                           898      *| STAGE THREE: UI Pass      |
0000206A                           899      *|___________________________|
0000206A                           900      *`                           `
0000206A                           901  
0000206A                           902      *,___________________________,
0000206A                           903      *| STAGE FOUR: Rendering     |
0000206A                           904      *|___________________________|
0000206A                           905      *`                           `
0000206A                           906      ; Clear old sprites from screen
0000206A  4EB8 1198                907      jsr r_ClearSprites ; Wipe sprites from screen
0000206E                           908  
0000206E                           909      ; Render ship
0000206E                           910      ; move.l #pg_Ship, a0
0000206E  204B                     911      move.l a3, a0   ; Move ship image address to the correct location
00002070  2005                     912      move.l d5, d0   ; Move position to offset
00002072  4EB8 1110                913      jsr r_PrintImage
00002076                           914  
00002076                           915      ; Render other things
00002076                           916  
00002076                           917      ; Swap Buffer
00002076  4EB8 1226                918      jsr SwapBuffer
0000207A                           919  
0000207A  C8BC 00FF0000            920      and.l #$00FF0000, d4
00002080  B8BC 00FF0000            921      cmp.l #$00FF0000, d4    ; Did player press ESC?
00002086  6600 FFAE                922      bne.l GameLoop  ; If not, continue loop
0000208A                           923  
0000208A  4E75                     924      rts
0000208C                           925  *| [End of Function] GameLoop
0000208C                           926  *|__________________________________________________
0000208C                           927  *`                                                  `
0000208C                           928  
0000208C                           929  *,__________________________________________________,
0000208C                           930  *| Input Variables
0000208C                           931  LastTime    ds.l 1  ; Stores the last frame's start time
00002090                           932  
00002090                           933  BackgroundBmpFile   INCBIN "../resources/background.bmp"
0012E11A                           934  ; RoadCollisionFile   INCBIN "../resources/collision.txt"
0012E11A                           935  
0012E11A                           936  *| Ship Rotations
0012E11A                           937  ShipBmpFiles        INCBIN "../resources/ship_rotations/Ship_R0.bmp"
0012E5A4                           938                      INCBIN "../resources/ship_rotations/Ship_R22.5.bmp"
0012EA2E                           939                      INCBIN "../resources/ship_rotations/Ship_R45.bmp"
0012EEB8                           940                      INCBIN "../resources/ship_rotations/Ship_R67.5.bmp"
0012F342                           941                      INCBIN "../resources/ship_rotations/Ship_R90.bmp"
0012F7CC                           942                      INCBIN "../resources/ship_rotations/Ship_R112.5.bmp"
0012FC56                           943                      INCBIN "../resources/ship_rotations/Ship_R135.bmp"
001300E0                           944                      INCBIN "../resources/ship_rotations/Ship_R157.5.bmp"
0013056A                           945                      INCBIN "../resources/ship_rotations/Ship_R180.bmp"
001309F4                           946                      INCBIN "../resources/ship_rotations/Ship_R202.5.bmp"
00130E7E                           947                      INCBIN "../resources/ship_rotations/Ship_R225.bmp"
00131308                           948                      INCBIN "../resources/ship_rotations/Ship_R247.5.bmp"
00131792                           949                      INCBIN "../resources/ship_rotations/Ship_R270.bmp"
00131C1C                           950                      INCBIN "../resources/ship_rotations/Ship_R292.5.bmp"
001320A6                           951                      INCBIN "../resources/ship_rotations/Ship_R315.bmp"
00132530                           952                      INCBIN "../resources/ship_rotations/Ship_R337.5.bmp"
001329BA                           953  EndShipBmpFiles
001329BA                           954  
001329BA                           955  
001329BA                           956  ; DebrisBmpFile       INCBIN "../resources/debris.bmp"
001329BA                           957  
001329BA                           958  ; 7SegVerticalBmpFile INCBIN "../resources/7SegVertical.bmp"
001329BA                           959  ; 7SegVerticalBmpFile INCBIN "../resources/7SegHorizontal.bmp"
001329BA                           960  
001329BA                           961  *,__________________________________________________,
001329BA                           962  *| Global Variables
001329BA                           963  
001329BA                           964  *| Data Type: Pixel Grid (pg)
001329BA                           965  *| $0 = Width
001329BA                           966  *| $2 = Height
001329BA                           967  *| $4 = ABGR Pixels (List, length x * y)
001329BA                           968  *>Renderer
001329BA                           969  pg_Background   ds.l 307201     ; 1 + 640x480
0025E9BE                           970  
0025E9BE                           971  pg_ShipRotations        ds.l 4112   ; (1 + 16x16) x 16 for 16 unique sprites
002629FE                           972  
002629FE                           973  pg_Debris       ds.l 257        ; 1 + 16x16
00262E02                           974  
00262E02                           975  *| vec2
00262E02                           976  
00262E02                           977  
00262E02                           978  *| Data Type: Pixel Clear Zones -> List<vec2, vec2>
00262E02                           979  *| An array storing the zones that need to be cleared of pixels
00262E02                           980  *| Long 1: Stores a vec2 representing the offset in x, y
00262E02                           981  *| Long 2: Stores a vec2 representing the width and height
00262E02                           982  pixel_clear_zones   ds.l 40     ; Max of 20 zones to clear at any given time
00262EA2                           983  pixel_clear_length   ds.l 1      ; Pointer to the last empty address
00262EA6                           984  
00262EA6                           985  *>7-Segment LED
00262EA6                           986  pg_7SegVertical     ds.l 65     ; 1 + 16x4
00262FAA                           987  pg_7SegHorizontal   ds.l 65     ; 1 + 16x4
002630AE                           988      
002630AE                           989      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACCEL_AMOUNT        100
ALL_REG             7FFF
BACKGROUNDBMPFILE   2090
DECEL_AMOUNT        100
ENDSHIPBMPFILES     1329BA
ENTER               D
ESC                 1B
FL_LOADBITMAP       1044
FL_LOADFILES        1000
FL_LOADSHIPROTATIONS  101A
FL_LOADSHIPROTATIONS:LOADBMP  1026
FP_11P25            B4000
FP_22P5             168000
FP_360              1680000
GAMELOOP            2036
GETBITMAPCHUNKS     108E
GETSINGLEPIXEL      10A8
GET_KEY_INPUT_COMMAND  13
I_CAPTUREINPUTS     1230
I_CAPTUREINPUTS:RETURN  124A
LASTTIME            208C
MAIN                2000
MAX_SPEED           1000
MAX_VELOCITY        30000
PARSEBITMAPHEADER   1048
PARSELITTLEENDIANLONG  1108
PG_7SEGHORIZONTAL   262FAA
PG_7SEGVERTICAL     262EA6
PG_BACKGROUND       1329BA
PG_DEBRIS           2629FE
PG_SHIPROTATIONS    25E9BE
PH_CALCULATEPOSITION  13E2
PH_CALCULATEPOSITION:RETURN  1424
PH_CALCULATEROTATION  1250
PH_CALCULATEROTATION:ANGLEOVER  12A4
PH_CALCULATEROTATION:ANGLEUNDER  12B0
PH_CALCULATEROTATION:FIXANGLE  128A
PH_CALCULATEROTATION:RETURN  12B6
PH_CALCULATEROTATION:TURNLEFT  126E
PH_CALCULATEROTATION:TURNRIGHT  1284
PH_CALCVELDIR       1370
PH_CALCVELDIR:RETURN  13DC
PH_CALCVELMAGNITUDE  12FC
PH_CALCVELMAGNITUDE:ACCEL  1322
PH_CALCVELMAGNITUDE:CLAMP  1334
PH_CALCVELMAGNITUDE:CLAMPMAX  1346
PH_CALCVELMAGNITUDE:CLAMPMIN  1334
PH_CALCVELMAGNITUDE:DECEL  132E
PH_CALCVELMAGNITUDE:FRIC  135C
PH_CALCVELMAGNITUDE:RETURN  136A
PH_CLAMPNUMBER      142A
PH_CLAMPNUMBER:OVER  1452
PH_CLAMPNUMBER:RETURN  145A
PH_CLAMPNUMBER:UNDER  144A
PH_CLAMPVECTOR      145E
PH_CLAMPVECTOR:RETURN  149A
PH_SELECTSHIPROTATION  12BC
PH_SELECTSHIPROTATION:GETFILE  12EA
PH_SELECTSHIPROTATION:NEXTROT  12CA
PH_SELECTSHIPROTATION:RETURN  12F6
PH_SINE             14A0
PH_SINE:Q1          14C8
PH_SINE:Q2          14DA
PH_SINE:Q3          14F8
PH_SINE:Q4          1512
PH_SINE:RETURN      152C
PIXEL_CLEAR_LENGTH  262EA2
PIXEL_CLEAR_ZONES   262E02
PRINT_PIXEL         52
R_CLEARSPRITES      1198
R_CLEARSPRITES:CHECKENDOFSPRITES  1210
R_CLEARSPRITES:CLEARPIXEL  11DA
R_CLEARSPRITES:CLEARSPRITE  11DA
R_CLEARSPRITES:GETSPRITE  11B4
R_CLEARSPRITES:LOADREGISTER  119C
R_CLEARSPRITES:PRINTBGPIXEL  11EC
R_CLEARSPRITES:RETURN  1220
R_PRINTIMAGE        1110
R_PRINTIMAGE:LOADVARSTOREGISTERS  1134
R_PRINTIMAGE:NOPRINT  117E
R_PRINTIMAGE:PRINTPIXEL  1162
R_PRINTIMAGE:RETURN  1192
SCREEN_HEIGHT       1E0
SCREEN_WIDTH        280
SET_PIXEL_COLOR     50
SHIFT               10
SHIPBMPFILES        12E11A
SHIPPOSITION        15E4
SHIP_BMP_SIZE       48A
SHIP_PG_SIZE        404
SINTABLE            152E
SINTABLESIZE        B4
SPACE               20
START               2000
SWAPBUFFER          1226
SWAP_BUFFER         5E
TRAP_REG            703
