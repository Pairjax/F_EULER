00002000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/16/2023 4:14:31 PM

00000000                             1  *,______________________________________________________,
00000000                             2  *|__________  ______________  ________________________  |
00000000                             3  *|___  ____/  ___  ____/_  / / /__  /___  ____/__  __ \ |
00000000                             4  *|__  /_________  __/  _  / / /__  / __  __/  __  /_/ / |
00000000                             5  *|_  __//_____/  /___  / /_/ / _  /___  /___  _  _, _/  |
00000000                             6  *|/_/         /_____/  \____/  /_____/_____/  /_/ |_|   |
00000000                             7  *|                                                      |
00000000                             8  *|            The 68k high-speed racing game            |
00000000                             9  *|                                                      |
00000000                            10  *|  Made By: Austin Smith        Date Started: 10/7/23  |
00000000                            11  *|______________________________________________________|
00000000                            12  *`                                                      `
00000000                            13  
00001000                            14      ORG $1000
00001000                            15  
00001000                            16  *,__________________________________________________,
00001000                            17  *| Constants
00001000                            18  
00001000                            19  ALL_REG             REG D0-D7/A0-A6
00001000                            20  TRAP_REG            REG D0-D1/A0-A2
00001000                            21  
00001000                            22  *| Vectors
00001000  =00000280                 23  SCREEN_WIDTH        EQU 640
00001000  =000001E0                 24  SCREEN_HEIGHT       EQU 480
00001000                            25  
00001000                            26  *| TRAP Codes
00001000  =00000013                 27  GET_KEY_INPUT_COMMAND   EQU 19
00001000                            28  
00001000  =00000050                 29  SET_PIXEL_COLOR     EQU 80
00001000  =00000052                 30  PRINT_PIXEL         EQU 82
00001000                            31  
00001000  =0000005E                 32  SWAP_BUFFER         EQU 94
00001000                            33  
00001000                            34  *,__________________________________________________,
00001000                            35  *| Includes
00001000                            36      INCLUDE "./file_loader.x68"   ; Handles loading of files during preload phase
00001000                            37  
00001000  =0000048A                 38  SHIP_BMP_SIZE       EQU 1162    ; The number of bytes betwen each ship file
00001000  =00000404                 39  SHIP_PG_SIZE        EQU 1028     ; The size of a ship sprite in memory
00001000                            40  
00001000                            41  fl_LoadFiles:
00001000                            42      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001000  207C 00002090             43      move.l #BackgroundBmpFile, a0   *| file_root
00001006  227C 001329BA             44      move.l #pg_Background, a1       *| output_image
0000100C  4EB9 00001044             45      jsr fl_LoadBitmap
00001012                            46  
00001012  4EB9 0000101A             47      jsr fl_LoadShipRotations
00001018                            48      
00001018  4E75                      49      rts
0000101A                            50  
0000101A                            51  fl_LoadShipRotations:
0000101A  207C 0012E11A             52      move.l #ShipBmpFiles, a0
00001020  227C 0025E9BE             53      move.l #pg_ShipRotations, a1
00001026                            54  
00001026                            55  .LoadBmp:
00001026  4EB9 00001044             56      jsr fl_LoadBitmap
0000102C                            57  
0000102C  D1FC 0000048A             58      add.l #SHIP_BMP_SIZE, a0
00001032  D3FC 00000404             59      add.l #SHIP_PG_SIZE, a1
00001038                            60  
00001038  B1FC 001329BA             61      cmp.l #EndShipBmpFiles, a0  ; Are we past the end?
0000103E  6D00 FFE6                 62      blt.l .LoadBmp              ; If not, keep on loading.
00001042                            63  
00001042  4E75                      64      rts
00001044                            65  
00001044                            66  fl_LoadBitmap:
00001044  48E7 FFFE                 67      movem.l ALL_REG, -(sp) *| Push registers to stack
00001048                            68  
00001048                            69  ParseBitmapHeader: ; Gather essential information from the bitmap's header
00001048                            70      ; This will need to be converted to Big Endian later based on the Color Range
00001048  2648                      71      move.l a0, a3
0000104A  D7FC 0000000A             72      add.l #$A, a3               ; Offset to pixel array
00001050  2213                      73      move.l (a3), d1
00001052                            74          
00001052  4EB9 00001108             75      jsr ParseLittleEndianLong
00001058                            76          
00001058  D288                      77      add.l a0, d1
0000105A  2801                      78      move.l d1, d4               ; Offset to Pixel Array
0000105C                            79          
0000105C  2648                      80      move.l a0, a3
0000105E  D7FC 00000012             81      add.l #$12, a3              ; Offset to image width
00001064  2213                      82      move.l (a3), d1             ; Image Width
00001066  4EB9 00001108             83      jsr ParseLittleEndianLong
0000106C  2A01                      84      move.l d1, d5
0000106E                            85          
0000106E  2648                      86      move.l a0, a3
00001070  D7FC 00000016             87      add.l #$16, a3              ; Offset to image height
00001076  2213                      88      move.l (a3), d1             ; Image Height
00001078  4EB9 00001108             89      jsr ParseLittleEndianLong
0000107E  2C01                      90      move.l d1, d6
00001080                            91      
00001080  3285                      92      move.w d5, (a1)             ; Push width & height to pixel grid
00001082  5489                      93      add.l #2, a1
00001084  3286                      94      move.w d6, (a1)
00001086  5489                      95      add.l #2, a1                ; Offset to start of pixel data in pixel grid
00001088                            96          
00001088  5C8B                      97      add.l #$6, a3
0000108A  3213                      98      move.w (a3), d1             ; ColorRange
0000108C  E159                      99      rol.w #8, d1
0000108E                           100  
0000108E                           101  GetBitmapChunks:                ; Get the desired chunks of the bitmap
0000108E                           102                                  ; Finding starting address
0000108E  2006                     103      move.l d6, d0               ; Height (H)
00001090  5380                     104      sub.l #1, d0                ; Sub by 1 to get column H - 1
00001092  2205                     105      move.l d5, d1
00001094  C0C1                     106      mulu.w d1, d0               ; Multiply by width to get last index of column CY - 1
00001096                           107          
00001096  2200                     108      move.l d0, d1               ; Storing in a separate variable so we can keep the index for other calculations
00001098  E589                     109      lsl.l #2, d1                ; Multiply by size of each pixel (Long Word).
0000109A  D284                     110      add.l d4, d1                ; Beginning of Pixel Array + Offset to Chunk Start
0000109C  2041                     111      move.l d1, a0               ; Current Pixel Address
0000109E                           112          
0000109E                           113      ; Finding end-of-row index
0000109E  D085                     114      add.l d5, d0                ; Add Chunk Width to push it to the end of the desired chunk's first row.
000010A0  E588                     115      lsl.l #2, d0                ; Multiply by size of each pixel (Long Word).
000010A2  D084                     116      add.l d4, d0                ; Beginning of Pixel Array + Offset to End-Of-Row
000010A4  2440                     117      move.l d0, a2               ; End Of Row Pixel Address
000010A6                           118          
000010A6                           119      ; Finding ending address
000010A6  2644                     120      move.l d4, a3   ; Represents the end row of the chunk's Address.
000010A8                           121  
000010A8                           122  GetSinglePixel:
000010A8                           123      ; Get pixel data
000010A8  2210                     124      move.l (a0), d1
000010AA                           125          
000010AA  4EB9 00001108            126      jsr ParseLittleEndianLong ; Convert to big endian
000010B0  2001                     127      move.l d1, d0   ; Move back to d0 after conversion
000010B2                           128         
000010B2  2200                     129      move.l d0, d1   ; Red
000010B4  E089                     130      lsr.l #8, d1    ; Red is the 3rd element, so we shift it 2 bytes over        
000010B6  E089                     131      lsr.l #8, d1    ; Have to cut it in byte increments.
000010B8  C2BC 000000FF            132      and.l #$FF, d1  ; Chopping off the channel bits that remain to the left.
000010BE                           133      
000010BE  2400                     134      move.l d0, d2   ; Green
000010C0  E08A                     135      lsr.l #8, d2    ; Green is the 2nd element, so we shift it 1 byte.
000010C2  C4BC 000000FF            136      and.l #$FF, d2  ; Chopping off the channel bits that remain to the left.
000010C8                           137          
000010C8  2600                     138      move.l d0, d3   ; Blue
000010CA  C6BC 000000FF            139      and.l #$FF, d3  ; Chopping off the channel bits that remain to the left.
000010D0                           140          
000010D0                           141      ; Shift these bits to the correct location for when we read it in BGR
000010D0  E18B                     142      lsl.l #8, d3    ; Blue is first, so we're shifting it to the 3rd byte
000010D2  E18B                     143      lsl.l #8, d3
000010D4                           144        
000010D4  E18A                     145      lsl.l #8, d2    ; Green is next, which goes to the 2nd byte.
000010D6                           146          
000010D6                           147      ; Red stays in place, now we merge the three variables into one
000010D6  C0BC FF000000            148      and.l #$FF000000, d0
000010DC  8081                     149      or.l d1, d0
000010DE  8082                     150      or.l d2, d0
000010E0  8083                     151      or.l d3, d0
000010E2                           152          
000010E2                           153      ; Push to BitmapChunk location
000010E2  2280                     154      move.l d0, (a1)
000010E4                           155          
000010E4                           156      ; Move Bitmap Chunk Pointer to next pixel
000010E4  5889                     157      add.l #4, a1
000010E6                           158          
000010E6                           159      ; Move Pixel Array Pointer to the next pixel
000010E6  5888                     160      add.l #4, a0            ; Move over 1 pixel
000010E8  B5C8                     161      cmp.l a0, a2            ; Is current Pixel Array Pointer past End of Row?
000010EA  6E00 FFBC                162      bgt.l GetSinglePixel    ; If not, continue the loop 
000010EE                           163          
000010EE                           164      ; If so, let's move the End of Row to the next row (backwards)
000010EE  2005                     165      move.l d5, d0
000010F0  E588                     166      lsl.l #2, d0    ; Multiply by size of each index
000010F2  95C0                     167      sub.l d0, a2
000010F4                           168          
000010F4                           169      ; Let's also move the Current Pixel Address to the start of the next row.
000010F4  2005                     170      move.l d5, d0           ; Move pointer back by 2xImageWidth
000010F6  D085                     171      add.l d5, d0
000010F8  E588                     172      lsl.l #2, d0
000010FA  91C0                     173      sub.l d0, a0
000010FC                           174          
000010FC                           175      ; Have we passed the end of the chunk?
000010FC  B7C8                     176      cmp.l a0, a3            ; Is Current Pixel Address past the index of End of Chunk index?
000010FE  6F00 FFA8                177      ble.l GetSinglePixel    ; If not, continue the loop
00001102                           178          
00001102                           179      ; If so, we've finished sorting.
00001102  4CDF 7FFF                180      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001106                           181  
00001106  4E75                     182      rts
00001108                           183  
00001108                           184  ParseLittleEndianLong:  ; Simple function to convert d1 LW from Little Endian to Big Endian
00001108  E159                     185      rol.w #8, d1
0000110A  4841                     186      swap d1
0000110C  E159                     187      rol.w #8, d1
0000110E                           188          
0000110E  4E75                     189      rts
00001110                           190  
00001110                           191  
00001110                           192  -------------------- end include --------------------
00001110                           193      INCLUDE "./renderer.x68"      ; Handles printing sprites & affine transformations.
00001110                           194  
00001110                           195  r_PrintImage: 
00001110  48E7 FFFE                196      movem.l ALL_REG, -(sp)  *| Push registers to stack
00001114                           197  
00001114                           198      *| Move starting variables to non-volatile positions
00001114  2400                     199      move.l d0, d2           ; offset: vec2
00001116  2010                     200      move.l (a0), d0         ; Image dimensions
00001118                           201  
00001118  B2BC 00000000            202      cmp.l #0, d1    ; Is this a sprite?
0000111E  6700 0014                203      beq.l .LoadVarsToRegisters            ; If not, let's skip this step.
00001122                           204      *| We need to store the offset: vec2 and image dimensions: vec2
00001122                           205      *| for clearing next frame's data.
00001122                           206      
00001122  2279 00262EA2            207      move.l pixel_clear_length, a1
00001128  2282                     208      move.l d2, (a1)  ; Move image offset to pixel_clear_zones
0000112A  5889                     209      add.l #4, a1     ; Move to next word
0000112C  2280                     210      move.l d0, (a1)  ; Move image dimensions to pixel_clear_zones
0000112E  50B9 00262EA2            211      add.l #8, pixel_clear_length     ; Move to next word
00001134                           212  
00001134                           213  .LoadVarsToRegisters:
00001134                           214  
00001134                           215      *| Set up the starting variables for printing pixels
00001134  2602                     216      move.l d2, d3
00001136  E08B                     217      lsr.l #8, d3            ; Offset X
00001138  E08B                     218      lsr.l #8, d3
0000113A  C4BC 0000FFFF            219      and.l #$0000FFFF, d2    ; Offset Y
00001140                           220         
00001140  2200                     221      move.l d0, d1
00001142  E088                     222      lsr.l #8, d0            ; Image Width (left word)
00001144  E088                     223      lsr.l #8, d0
00001146  2800                     224      move.l d0, d4           ; Store width in d4 to prevent destruction
00001148  C2BC 0000FFFF            225      and.l #$0000FFFF, d1    ; Image Height (right word)
0000114E                           226          
0000114E  2A03                     227      move.l d3, d5           ; Start X Position
00001150                           228      
00001150  4286                     229      clr.l d6
00001152  3C03                     230      move.w d3, d6           ; End X Position
00001154  DC80                     231      add.l d0, d6
00001156  5386                     232      sub.l #1, d6
00001158                           233          
00001158  4287                     234      clr.l d7
0000115A  3E02                     235      move.w d2, d7           ; End Y Position
0000115C  DE81                     236      add.l d1, d7
0000115E  5387                     237      sub.l #1, d7
00001160                           238      
00001160  5888                     239      add.l #4, a0
00001162                           240          
00001162                           241  .PrintPixel:
00001162  2210                     242      move.l (a0), d1             ; Get current pixel color
00001164                           243  
00001164  B2BC 00FFFFFF            244      cmp.l #$00FFFFFF, d1        ; Is pixel color transparent?
0000116A  6300 0012                245      bls.l .NoPrint              ; If so, let's skip printing
0000116E                           246      
0000116E  7050                     247      move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
00001170                           248  
00001170  C2BC 00FFFFFF            249      and.l #$00FFFFFF, d1        ; Chop off alpha
00001176                           250          
00001176  4E4F                     251      TRAP #15
00001178                           252                 
00001178  7052                     253      move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
0000117A  2203                     254      move.l d3, d1               ; Pixel X location must be extracted 
0000117C                           255     
0000117C  4E4F                     256      TRAP #15
0000117E                           257        
0000117E                           258  .NoPrint:
0000117E                           259      ; Calculate the next target pixel.
0000117E  5888                     260      add.l #4, a0            ; Move pointer to next color pixel
00001180                           261          
00001180  5283                     262      add.l #1, d3            ; Move X to the next column
00001182  B686                     263      cmp.l d6, d3            ; Is X past End X Position?
00001184  6300 FFDC                264      bls.l .PrintPixel        ; If not, keep on printing
00001188                           265          
00001188                           266      ; Otherwise, we move to the next row
00001188  9684                     267      sub.l d4, d3            ; Move X back to the starting column
0000118A  5282                     268      add.l #1, d2            ; Move Y down a row
0000118C                           269          
0000118C  B487                     270      cmp.l d7, d2            ; Is Y past End Y Position?
0000118E  6F00 FFD2                271      ble.l .PrintPixel         ; If not, keep printing.
00001192                           272  
00001192                           273  .Return:
00001192                           274  
00001192  4CDF 7FFF                275      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001196                           276  
00001196  4E75                     277      rts
00001198                           278  
00001198                           279  
00001198                           280  r_ClearSprites:
00001198  48E7 FFFE                281      movem.l ALL_REG, -(sp) *| Push registers to stack
0000119C                           282  
0000119C                           283  .LoadRegister:
0000119C  207C 00262E02            284      move.l #pixel_clear_zones, a0    ; Current sprite index
000011A2  2279 00262EA2            285      move.l (pixel_clear_length), a1   ; End sprite index
000011A8  247C 001329BA            286      move.l #pg_Background, a2        ; Background
000011AE                           287  
000011AE                           288      ; Is pixel clear zones empty?
000011AE  B3C8                     289      cmp.l a0, a1
000011B0  6700 006E                290      beq.l .Return                ; If list is empty, simply return.
000011B4                           291  
000011B4                           292  .GetSprite:
000011B4                           293      *| Extracting offset into registers for processing.
000011B4  2610                     294      move.l (a0), d3                 ; offset: vec2
000011B6                           295      
000011B6  2403                     296      move.l d3, d2                   ; Separate into two registers
000011B8                           297  
000011B8  E08B                     298      lsr.l #8, d3                    ; Offset X: int
000011BA  E08B                     299      lsr.l #8, d3                    ; Will be used as Current X for loop
000011BC                           300  
000011BC  C4BC 0000FFFF            301      and.l #$0000FFFF, d2            ; Offset Y: int
000011C2                           302                                      ; Will be used as Current Y for loop
000011C2                           303  
000011C2                           304      *| Extracting dimensions to registers for processing
000011C2  5888                     305      add.l #4, a0                    ; Push to next long
000011C4  2810                     306      move.l (a0), d4                 ; dimensions: vec2
000011C6  2A04                     307      move.l d4, d5                   ; Separate into two registers
000011C8                           308  
000011C8  E08C                     309      lsr.l #8, d4                    ; Width: int
000011CA  E08C                     310      lsr.l #8, d4
000011CC                           311  
000011CC  CABC 0000FFFF            312      and.l #$0000FFFF, d5            ; Height: int
000011D2                           313  
000011D2                           314      *| Get ending x and y positions
000011D2  2C03                     315      move.l d3, d6                   ; X Offset
000011D4  DC84                     316      add.l d4, d6                    ; Plus Width
000011D6                           317                                      ; = End X Pos
000011D6                           318      
000011D6  2E02                     319      move.l d2, d7                   ; Y Offset
000011D8  DE85                     320      add.l d5, d7                    ; Plus Height
000011DA                           321                                      ; = End Y Pos
000011DA                           322  
000011DA                           323  .ClearSprite:
000011DA                           324      *,__________________________________________________,
000011DA                           325      *| For Loop: for x = Offset X, x < Offset X + Width, x++
000011DA                           326  .ClearPixel:
000011DA                           327              *| Get Background Pixel
000011DA  2202                     328              move.l d2, d1   ; Get offset to pixel address of background.
000011DC  C2FC 0280                329              mulu.w #SCREEN_WIDTH, d1   ; multiplied by width
000011E0  D283                     330              add.l d3, d1    ; plus X offset
000011E2                           331              
000011E2  5281                     332              add.l #1, d1    ; + 1 to account for dimension data in Pixel Grid 
000011E4  E589                     333              lsl.l #2, d1    ; Multiplied by size of Long
000011E6                           334  
000011E6  264A                     335              move.l a2, a3   ; Add this to the address of the pixel grid
000011E8  D7C1                     336              add.l d1, a3    ; Shifting offset to the desired pixel
000011EA  2213                     337              move.l (a3), d1 ; Overwrite d1 to save register space
000011EC                           338                              ; d1 now stores the hex color of the pixel
000011EC                           339              
000011EC                           340  .PrintBgPixel:
000011EC                           341              *| Note that we set up the previous registers so all data
000011EC                           342              *| is in the right location. X is in d3 but will be moved to d1
000011EC                           343              *| once the first trap is done.
000011EC  7050                     344              move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
000011EE                           345                  
000011EE                           346              ; TODO: Make backround have no alpha so we can remove this line
000011EE  C2BC 00FFFFFF            347              and.l #$00FFFFFF, d1        ; Chop off alpha
000011F4                           348  
000011F4  4E4F                     349              TRAP #15
000011F6                           350  
000011F6  2203                     351              move.l d3, d1               ; Move X pos to correct register
000011F8                           352                                          ; Y pos is already in correct register.   
000011F8                           353                      
000011F8  7052                     354              move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
000011FA                           355          
000011FA  4E4F                     356              TRAP #15
000011FC                           357  
000011FC  5283                     358              add.l #1, d3    ; x += 1
000011FE  B686                     359              cmp.l d6, d3    ; is x past end x pos?
00001200  6F00 FFD8                360              ble.l .ClearPixel ; if not, continue parsing pixels
00001204                           361      *| End For Loop
00001204                           362  
00001204  9684                     363      sub.l d4, d3    ; Move x back to start location
00001206  5383                     364      sub.l #1, d3    ; - 1 for extra space moved past width.
00001208                           365  
00001208  5282                     366      add.l #1, d2    ; y += 1
0000120A  B487                     367      cmp.l d7, d2    ; Is y past end Y pos?
0000120C  6300 FFCC                368      bls.l .ClearSprite  ; If not, continue to next loop
00001210                           369  
00001210                           370  .CheckEndOfSprites:
00001210  B3C8                     371      cmp.l a0, a1                    ; Is current sprite index at or past end sprite index?
00001212  6300 FFA0                372      bls.l .GetSprite                ; If not, let's keep on going.
00001216                           373  
00001216                           374      ; If we're done, we reset the clear zones as we have emptied it out
00001216  23FC 00262E02 00262EA2   375      move.l #pixel_clear_zones, pixel_clear_length
00001220                           376  
00001220                           377  .Return:
00001220                           378  
00001220  4CDF 7FFF                379      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001224                           380  
00001224  4E75                     381      rts
00001226                           382  
00001226                           383  SwapBuffer:
00001226  2F00                     384      move.l d0, -(sp)
00001228                           385      
00001228  705E                     386      move.l #SWAP_BUFFER, d0
0000122A                           387      
0000122A  4E4F                     388      TRAP #15
0000122C                           389  
0000122C  201F                     390      move.l (sp)+, d0
0000122E                           391  
0000122E  4E75                     392      rts
00001230                           393  
00001230                           394  -------------------- end include --------------------
00001230                           395      INCLUDE "./inputs.x68"        ; Handles player inputs for processing
00001230                           396  
00001230  =0000000D                397  ENTER               EQU $D
00001230  =0000001B                398  ESC                 EQU $1B
00001230  =00000010                399  SHIFT               EQU $10
00001230  =00000020                400  SPACE               EQU $20
00001230                           401  
00001230                           402  i_CaptureInputs:
00001230  48E7 C0E0                403      movem.l TRAP_REG, -(sp) *| Push registers to stack
00001234                           404  
00001234  7013                     405      move.l #GET_KEY_INPUT_COMMAND, d0
00001236  223C 57415344            406      move.l #'W'<<24+'A'<<16+'S'<<8+'D', d1   ; WASD Inputs
0000123C                           407      
0000123C  4E4F                     408      TRAP #15
0000123E                           409      
0000123E  2601                     410      move.l d1, d3   ; d3 stores WASD Inputs for later processing
00001240                           411      
00001240  223C 0D1B1020            412      move.l #ENTER<<24+ESC<<16+SHIFT<<8+SPACE, d1   ; Enter, Esc, Shift, and Space Inputs
00001246                           413      
00001246  4E4F                     414      TRAP #15
00001248                           415      
00001248  2801                     416      move.l d1, d4   ; d4 stores other Inputs for later processing
0000124A                           417      
0000124A                           418  .Return:
0000124A  4CDF 0703                419      movem.l (sp)+, TRAP_REG *| Pull registers from stack
0000124E                           420  
0000124E  4E75                     421      rts
0000124E  4E75                     422  -------------------- end include --------------------
00001250                           423  * INCLUDE "./gameplay.x68"      ; Handles in-game timer, lap counter, and game states
00001250                           424      INCLUDE "./physics.x68"       ; Calculates player acceleration, velocity, and collisions.
00001250                           425  
00001250  =00030000                426  MAX_VELOCITY        EQU $00030000
00001250  =01680000                427  FP_360              EQU $01680000   ; Hex value for 360 degrees in 16.16 fixed point
00001250  =00168000                428  FP_22P5             EQU $00168000   ; Hex value for 22.5 degrees in 16.16 fixed point
00001250  =000B4000                429  FP_11P25            EQU $000B4000   ; Hex value for 11.25 degrees in 16.16 fixed point
00001250                           430  
00001250  =00003000                431  ACCEL_AMOUNT        EQU $00003000   ; Increases speed at 0.125 pixels per frame 
00001250  =00001000                432  DECEL_AMOUNT        EQU $00001000   ; Increases speed at 0.0625 pixels per frame 
00001250                           433  
00001250  =00002000                434  MAX_SPEED           EQU $0002000
00001250                           435  
00001250                           436  ph_CalculateRotation:
00001250  48E7 C0E0                437      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001254                           438  
00001254  2003                     439      move.l d3, d0   ; Copying WASD inputs to extract A & D
00001256  2200                     440      move.l d0, d1
00001258                           441  
00001258  E088                     442      lsr.l #8, d0            ; A key input
0000125A  E088                     443      lsr.l #8, d0
0000125C  C0BC 000000FF            444      and.l #$000000FF, d0    ; Chopping off W input
00001262                           445  
00001262  C2BC 000000FF            446      and.l #$000000FF, d1    ; D key input
00001268                           447  
00001268  B280                     448      cmp.l d0, d1            ; Are A & D both pressed or not pressed?
0000126A  6700 004A                449      beq.l .Return           ; If so, let's skip to the end.
0000126E                           450  
0000126E                           451  .TurnLeft:
0000126E  B0BC 00000000            452      cmp.l #0, d0
00001274  6700 000E                453      beq.l .TurnRight
00001278                           454  
00001278  0482 00013880            455      sub.l #00080000, d2
0000127E                           456  
0000127E  4EF9 0000128A            457      jmp .FixAngle
00001284                           458  
00001284                           459  .TurnRight:
00001284  0682 00013880            460      add.l #00080000, d2
0000128A                           461      
0000128A                           462  .FixAngle:
0000128A  B4BC 01680000            463      cmp.l #FP_360, d2       ; Is d2 greater than 360?
00001290  6E00 0012                464      bgt.l .AngleOver
00001294  B4BC 00000000            465      cmp.l #0, d2            ; Is d2 negative?
0000129A  6D00 0014                466      blt.l .AngleUnder
0000129E                           467  
0000129E  4EF9 000012B6            468      jmp .Return
000012A4                           469  
000012A4                           470  .AngleOver:
000012A4  0482 01680000            471      sub.l #FP_360, d2          
000012AA                           472  
000012AA  4EF9 000012B6            473      jmp .Return
000012B0                           474  
000012B0                           475  .AngleUnder:
000012B0  0682 01680000            476      add.l #FP_360, d2
000012B6                           477  
000012B6                           478  .Return
000012B6  4CDF 0703                479      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000012BA                           480  
000012BA  4E75                     481      rts
000012BC                           482  
000012BC                           483  ph_SelectShipRotation:
000012BC  48E7 C0E0                484      movem.l TRAP_REG, -(sp)  *| Push registers to stack
000012C0                           485  
000012C0  2002                     486      move.l d2, d0   ; Take angle to temporary variable
000012C2  7200                     487      move.l #0, d1   ; d1 stores ship index
000012C4  0480 000B4000            488      sub.l #FP_11P25, d0 ; Subtract angle by 11.25
000012CA                           489  
000012CA                           490  .NextRot:
000012CA  5281                     491      add.l #1, d1        
000012CC                           492  
000012CC  0480 00168000            493      sub.l #FP_22P5, d0  ; Subtract angle by 11.25
000012D2  B0BC 00000000            494      cmp.l #0, d0        ; Is angle under 0?
000012D8  6C00 FFF0                495      bge.l .NextRot      ; If not, get next rotation
000012DC                           496  
000012DC                           497      ; We de-increment by 1 to go back to the desired index
000012DC  5381                     498      sub.l #1, d1
000012DE                           499  
000012DE  B2BC 00000010            500      cmp.l #16, d1       ; Is d1 greater than 15?
000012E4  6D00 0004                501      blt.l .GetFile      ; If not, we ignore the next step
000012E8                           502  
000012E8  7200                     503      move.l #0, d1       ; If we went past 15, we reset back to the first index
000012EA                           504  
000012EA                           505  .GetFile:
000012EA  C2FC 0404                506      mulu.w #1028, d1     ; Multiply by size of ship's pixel grid
000012EE  0681 0025E9BE            507      add.l #pg_ShipRotations, d1
000012F4  2641                     508      move.l d1, a3
000012F6                           509  
000012F6                           510  .Return
000012F6  4CDF 0703                511      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000012FA                           512  
000012FA  4E75                     513      rts
000012FC                           514  
000012FC                           515  ph_CalculateVelocityMagnitude:
000012FC  48E7 C0E0                516      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001300                           517  
00001300  2003                     518      move.l d3, d0           ; Copying WASD inputs to extract A & D
00001302  2200                     519      move.l d0, d1
00001304                           520  
00001304  E088                     521      lsr.l #8, d0            ; W key input
00001306  E088                     522      lsr.l #8, d0
00001308  E088                     523      lsr.l #8, d0
0000130A                           524  
0000130A  E089                     525      lsr.l #8, d1            ; S key input
0000130C  C2BC 000000FF            526      and.l #$000000FF, d1    
00001312                           527  
00001312  B280                     528      cmp.l d0, d1            ; Are S & S both pressed or not pressed?
Line 529 ERROR: Undefined symbol
00001314  6700 AA00                529      beq.l .Fric             ; If so, let's apply friction.
00001318                           530  
00001318  B0BC 00000000            531      cmp.l #0, d0            ; Are we accelerating?
Line 532 ERROR: Undefined symbol
0000131E  6700 A9F6                532      beq.l .Decel            ; If not, then we must be decelerating. 
00001322                           533  
Line 534 WARNING: Label too long
00001322                           534  .Accel: ; Move forwards
00001322  0687 00003000            535      add.l #ACCEL_AMOUNT, d7 
00001328                           536  
00001328                           537      ; if boosting, add more?
00001328                           538  
Line 539 ERROR: Undefined symbol
00001328  4EF9 004DBD16            539      jmp .Return
0000132E                           540  
Line 541 WARNING: Label too long
0000132E                           541  .Decel: ; Move backwards
0000132E  0487 00001000            542      sub.l #DECEL_AMOUNT, d7 
00001334                           543  
Line 544 ERROR: Undefined symbol
00001334  4EF9 004DBD16            544      jmp .Return
0000133A                           545  
Line 546 WARNING: Label too long
0000133A                           546  .Fric:  ; Return to 0 over time while not boosting
0000133A  E387                     547      asl.l #1, d7
0000133C  BEBC FFFFFFFF            548      cmp.l #$FFFFFFFF, d7    ; Is d7 at its lowest possible value?
Line 549 ERROR: Undefined symbol
00001342  6600 A9D2                549      bne.l .Return           ; If not, skip this next step
00001346                           550  
00001346  7E00                     551      move.l #0, d7           ; Return to 0 rather than being stuck at almost -0
00001348                           552  
Line 553 WARNING: Label too long
00001348                           553  .Return:
00001348  4CDF 0703                554      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
0000134C                           555  
0000134C  4E75                     556      rts
0000134E                           557  
0000134E                           558  ph_CalculateVelocityDirection:
0000134E                           559  
Line 560 WARNING: Label too long
0000134E                           560  .Return:
0000134E  4CDF 0703                561      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
00001352                           562  
00001352  4E75                     563      rts
00001354                           564  
00001354                           565  ph_CalculateAcceleration:
00001354  48E7 C0E0                566      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001358                           567  
00001358  2003                     568      move.l d3, d0           ; Copying WASD inputs to extract A & D
0000135A  2200                     569      move.l d0, d1
0000135C                           570  
0000135C  E088                     571      lsr.l #8, d0            ; W key input
0000135E  E088                     572      lsr.l #8, d0
00001360  E088                     573      lsr.l #8, d0
00001362                           574  
00001362  E089                     575      lsr.l #8, d1            ; S key input
00001364  C2BC 000000FF            576      and.l #$000000FF, d1    
0000136A                           577  
0000136A  B280                     578      cmp.l d0, d1            ; Are S & S both pressed or not pressed?
0000136C  6700 005C                579      beq.l .Fric             ; If so, let's apply friction.
00001370                           580  
00001370  B0BC 00000000            581      cmp.l #0, d0            ; Are we accelerating?
00001376  6700 000A                582      beq.l .Decel            ; If not, then we must be decelerating.
0000137A                           583  
0000137A                           584  .Accel:
0000137A  7204                     585      move.l #$00000004, d1   ; magnitude of acceleration (0.5)
0000137C                           586  
0000137C  4EF9 00001384            587      jmp .Vec
00001382                           588  
00001382                           589  .Decel:
00001382  72FE                     590      move.l #$FFFFFFFE, d1   ; magnitude of acceleration (-0.25)
00001384                           591  
00001384                           592  .Vec:  ; Builds a vector of the x and y component
00001384  2002                     593      move.l d2, d0           ; Move angle to register for processing
00001386  0680 00B40000            594      add.l #$00B40000, d0    ; Angle should actually be facing the other way, so +180
0000138C                           595      
0000138C  4EB9 000014D0            596      jsr ph_Sine              ; sin
00001392                           597  
00001392                           598      ; We're done with WASD inputs so we can now use d3 for operations
00001392  2600                     599      move.l d0, d3           ; Storing sin(theta)
00001394  2002                     600      move.l d2, d0           ; Move angle to d0 again    
00001396  0680 00B40000            601      add.l #$00B40000, d0    ; Angle should actually be facing the other way, so +180
0000139C  0680 005A0000            602      add.l #$005A0000, d0    ; Add pi / 2 to get cosine
000013A2                           603  
000013A2  4EB9 000014D0            604      jsr ph_Sine              ;cos
000013A8                           605  
000013A8  C1C1                     606      muls.w d1, d0           ; Multiply both sin and cosine to get x and y component  
000013AA  C7C1                     607      muls.w d1, d3  
000013AC                           608  
000013AC                           609      *| X and Y are now in 12.20. We are going to clamp them back down to 4.12
000013AC                           610      *| X fix
000013AC  E088                     611      lsr.l #8, d0            ; Cut off excess fractional bits
000013AE  C0BC 0000FFFF            612      and.l #$0000FFFF, d0
000013B4                           613  
000013B4  E08B                     614      lsr.l #8, d3            ; Cut off excess fractional bits
000013B6  C6BC 0000FFFF            615      and.l #$0000FFFF, d3
000013BC                           616  
000013BC  E18B                     617      lsl.l #8, d3            ; Move x component to the left side
000013BE  E18B                     618      lsl.l #8, d3
000013C0                           619  
000013C0  8083                     620      or.l d3, d0         ; Merge together into a single vector.
000013C2  DE80                     621      add.l d0, d7        ; Add to existing acceleration
000013C4                           622  
000013C4  4EF9 000013E0            623      jmp .Clamp
000013CA                           624  
000013CA                           625  .Fric:
000013CA  2007                     626      move.l d7, d0           ; Move accel to another register for value extraction
000013CC                           627      
000013CC  E088                     628      lsr.l #8, d0            ; x component
000013CE  E088                     629      lsr.l #8, d0
000013D0                           630  
000013D0  E240                     631      asr.w #1, d0            ; Divide by two
000013D2                           632  
000013D2  E188                     633      lsl.l #8, d0            ; Move back to position for merge
000013D4  E188                     634      lsl.l #8, d0
000013D6                           635  
000013D6  CEBC 0000FFFF            636      and.l #$0000FFFF, d7    ; y component
000013DC  E247                     637      asr.w #1, d7            ; Divide by two
000013DE                           638  
000013DE  8E80                     639      or.l d0, d7            ; New acceleration
000013E0                           640  
000013E0                           641  .Clamp: ; clamps acceleration - TODO
000013E0                           642  
000013E0                           643  .Return:
000013E0  4CDF 0703                644      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000013E4                           645  
000013E4  4E75                     646      rts
000013E6                           647  
000013E6                           648  ph_CalculateVelocity:
000013E6  48E7 C0E0                649      movem.l TRAP_REG, -(sp)  *| Push registers to stack
000013EA                           650      
000013EA  2007                     651      move.l d7, d0           ; Pull acceleration out
000013EC  2200                     652      move.l d0, d1 
000013EE                           653  
000013EE  E088                     654      lsr.l #8, d0            ; Extract to two registers
000013F0  E088                     655      lsr.l #8, d0            ; X value
000013F2  C2BC 0000FFFF            656      and.l #$0000FFFF, d1    ; Y value
000013F8                           657  
000013F8  2606                     658      move.l d6, d3           ; Extract to two registers
000013FA  E08E                     659      lsr.l #8, d6            ; X value
000013FC  E08E                     660      lsr.l #8, d6
000013FE  C6BC 0000FFFF            661      and.l #$0000FFFF, d3    ; Y value
00001404                           662  
00001404  DC40                     663      add.w d0, d6
00001406  D641                     664      add.w d1, d3
00001408                           665  
00001408  E18E                     666      lsl.l #8, d6
0000140A  E18E                     667      lsl.l #8, d6
0000140C                           668  
0000140C  8C83                     669      or.l d3, d6
0000140E                           670  
0000140E                           671  .Fric: ; Apply friction to slow the vehicle down
0000140E                           672  
0000140E                           673  .Apply:
0000140E                           674      *| ClampVector(d0=magnitude_sqr: word, d1=vector) -> d1=clamped_vector
0000140E  2206                     675      move.l d6, d1
00001410  203C 000000FF            676      move.l #$000000FF, d0   *| Max of 1
00001416                           677  
00001416  4EB9 0000148E            678      jsr ph_ClampVector
0000141C                           679      
0000141C  2C01                     680      move.l d1, d6
0000141E                           681  
0000141E                           682  .Return:
0000141E  4CDF 0703                683      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
00001422                           684  
00001422  4E75                     685      rts
00001424                           686  
00001424                           687  ph_CalculatePosition:
00001424  48E7 C0E0                688      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001428                           689  
00001428  2006                     690      move.l d6, d0
0000142A  2200                     691      move.l d0, d1 
0000142C                           692  
0000142C  E088                     693      lsr.l #8, d0
0000142E  E088                     694      lsr.l #8, d0
00001430  C2BC 0000FFFF            695      and.l #$0000FFFF, d1
00001436                           696      
00001436  E040                     697      asr.w #8, d0            ; X adjusted to whole number
00001438  E840                     698      asr.w #4, d0
0000143A  E041                     699      asr.w #8, d1            ; Y adjusted to whole number
0000143C  E841                     700      asr.w #4, d1
0000143E                           701  
0000143E  2605                     702      move.l d5, d3
00001440  E08B                     703      lsr.l #8, d3
00001442  E08B                     704      lsr.l #8, d3
00001444  CABC 0000FFFF            705      and.l #$0000FFFF, d5
0000144A                           706  
0000144A  D640                     707      add.w d0, d3
0000144C  DA41                     708      add.w d1, d5
0000144E  E18B                     709      lsl.l #8, d3
00001450  E18B                     710      lsl.l #8, d3
00001452                           711  
00001452  8A83                     712      or.l d3, d5
00001454                           713  
00001454                           714  .Return:
00001454  4CDF 0703                715      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
00001458                           716  
00001458  4E75                     717      rts
0000145A                           718  
0000145A                           719  ph_ClampNumber:
0000145A  2F02                     720      move.l d2, -(sp) ; Temporarily move d2 out of the way
0000145C                           721  
0000145C  2401                     722      move.l d1, d2
0000145E  E089                     723      lsr.l #8, d1
00001460  E089                     724      lsr.l #8, d1
00001462  C4BC 0000FFFF            725      and.l #$0000FFFF, d2
00001468                           726  
00001468                           727      *| Compare by word here because it is signed 
00001468  B041                     728      cmp.w d1, d0    ; Is value less than min?
0000146A  6D00 000E                729      blt .Under    
0000146E                           730      
0000146E  B042                     731      cmp.w d2, d0    ; Is value greater than max?
00001470  6E00 0010                732      bgt.l .Over
00001474                           733  
00001474  4EF9 0000148A            734      jmp .Return     ; Within range, do nothing
0000147A                           735  
0000147A                           736  .Under:     ; We need to clamp value to min
0000147A  2001                     737      move.l d1, d0
0000147C                           738  
0000147C  4EF9 0000148A            739      jmp .Return
00001482                           740  
00001482                           741  .Over:      ; We need to clamp value to max
00001482  2002                     742      move.l d2, d0
00001484                           743  
00001484  4EF9 0000148A            744      jmp .Return
0000148A                           745  
0000148A                           746  .Return:
0000148A  241F                     747      move.l (sp)+, d2
0000148C                           748  
0000148C  4E75                     749      rts
0000148E                           750  
0000148E                           751  ph_ClampVector:
0000148E  2F02                     752      move.l d2, -(sp)    ; Temporarily move d2 out of the way
00001490  2F03                     753      move.l d3, -(sp)    ; Temporarily move d3 out of the way
00001492                           754  
00001492  2401                     755      move.l d1, d2       ; Extract X & Y value of vector
00001494  2602                     756      move.l d2, d3
00001496  E08A                     757      lsr.l #8, d2
00001498  E08A                     758      lsr.l #8, d2
0000149A  C6BC 0000FFFF            759      and.l #$0000FFFF, d3
000014A0                           760  
000014A0  C5C2                     761      muls.w d2, d2   ; x ^ 2
000014A2  C7C3                     762      muls.w d3, d3   ; y ^ 2
000014A4  D682                     763      add.l d2, d3    ; x ^ 2 + y ^ 2 = c ^ 2
000014A6                           764  
000014A6                           765      ; (x ^ 2) + (y ^ 2) must be converted from 16.16 to 8.8
000014A6  E08B                     766      lsr.l #8, d3
000014A8  C6BC 0000FFFF            767      and.l #$0000FFFF, d3
000014AE                           768  
000014AE  B680                     769      cmp.l d0, d3    ; Is magnitude greater than max?
000014B0  6F00 0018                770      ble.l .Return   ; If not, carry on as usual
000014B4                           771  
000014B4                           772      ; If so, let's CUT IT IN HALF muahahaha
000014B4  2401                     773      move.l d1, d2
000014B6                           774  
000014B6  E08A                     775      lsr.l #8, d2
000014B8  E08A                     776      lsr.l #8, d2
000014BA  C2BC 0000FFFF            777      and.l #$0000FFFF, d1
000014C0                           778      
000014C0  E242                     779      asr.w #1, d2            ; X
000014C2  E241                     780      asr.w #1, d1            ; Y
000014C4                           781      
000014C4  E18A                     782      lsl.l #8, d2
000014C6  E18A                     783      lsl.l #8, d2
000014C8                           784  
000014C8  8282                     785      or.l d2, d1
000014CA                           786  
000014CA                           787  .Return:
000014CA  261F                     788      move.l (sp)+, d3
000014CC  241F                     789      move.l (sp)+, d2
000014CE                           790  
000014CE  4E75                     791      rts
000014D0                           792  
000014D0                           793  ph_Sine:
000014D0  E088                     794      lsr.l #8, d0
000014D2  E088                     795      lsr.l #8, d0        ; Chopping off fractional
000014D4                           796  
000014D4  B0BC 0000005A            797      cmp.l #90, d0       ; Is the angle greater than 90?
000014DA  6D00 001C                798      blt.l .Q1           ; If not, we're in quadrant 1
000014DE                           799      
000014DE  B0BC 000000B4            800      cmp.l #180, d0      ; Is the angle greater than 180?
000014E4  6D00 0024                801      blt.l .Q2           ; If not, we're in quadrant 2
000014E8                           802  
000014E8  B0BC 0000010E            803      cmp.l #270, d0      ; Is the angle greater than 270?
000014EE  6D00 0038                804      blt.l .Q3           ; If not, we're in quadrant 3
000014F2                           805      
000014F2  4EF9 00001542            806      jmp .Q4             ; We are in quadrant 4 by process of elimination
000014F8                           807  
000014F8                           808  .Q1:    ; Quadrant 1
000014F8  E388                     809      lsl.l #1, d0        ; Multiply by 2 (length of word)
000014FA                           810  
000014FA  207C 0000155E            811      move.l #sinTable, a0
00001500  D1C0                     812      add.l d0, a0        ; Offset to desired index of sin table
00001502                           813  
00001502  3010                     814      move.w (a0), d0     ; Extract fractional
00001504                           815  
00001504  4EF9 0000155C            816      jmp .Return
0000150A                           817  
0000150A                           818  .Q2:    ; Quadrant 2
0000150A  0480 0000005A            819      sub.l #90, d0       ; Start at 90 degrees
00001510  E388                     820      lsl.l #1, d0        ; Multiply by 2 (length of word)
00001512                           821  
00001512  207C 0000155E            822      move.l #sinTable, a0
00001518  D1FC 000000B4            823      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
0000151E  91C0                     824      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
00001520                           825  
00001520  3010                     826      move.w (a0), d0     ; Extract fractional
00001522                           827  
00001522  4EF9 0000155C            828      jmp .Return
00001528                           829  
00001528                           830  .Q3:    ; Quadrant 3
00001528  0480 000000B4            831      sub.l #180, d0       ; Start at 180 degrees
0000152E  E388                     832      lsl.l #1, d0        ; Multiply by 2 (length of word)
00001530                           833  
00001530  207C 0000155E            834      move.l #sinTable, a0
00001536  D1C0                     835      add.l d0, a0        ; Offset to desired index of sin table
00001538                           836  
00001538  3010                     837      move.w (a0), d0     ; Extract fractional
0000153A  4440                     838      neg.w d0            ; Flip to negative
0000153C                           839  
0000153C  4EF9 0000155C            840      jmp .Return
00001542                           841  
00001542                           842  .Q4:    ; Quadrant 4
00001542  0480 0000010E            843      sub.l #270, d0       ; Start at 90 degrees
00001548  E388                     844      lsl.l #1, d0         ; Multiply by 2 (length of word)
0000154A                           845  
0000154A  207C 0000155E            846      move.l #sinTable, a0
00001550  D1FC 000000B4            847      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
00001556  91C0                     848      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
00001558                           849  
00001558  3010                     850      move.w (a0), d0     ; Extract fractional
0000155A                           851  
0000155A  4440                     852      neg.w d0            ; Flip to negative
0000155C                           853  
0000155C                           854  .Return:
0000155C                           855  
0000155C  4E75                     856      rts
0000155E                           857  
0000155E= 0000 0047 008E 0...      858  sinTable        dc.w    $0,$47,$8E,$D6,$11D,$164,$1AC,$1F3,$23A,$280,$2C7
00001574= 030D 0353 0399 0...      859                  dc.w    $30D,$353,$399,$3DE,$424,$469,$4AD,$4F1,$535
00001586= 0578 05BB 05FE 0...      860                  dc.w    $578,$5BB,$5FE,$640,$681,$6C3,$703,$743,$782
00001598= 07C1 07FF 083D 0...      861                  dc.w    $7C1,$7FF,$83D,$87A,$8B6,$8F2,$92D,$967,$9A1
000015AA= 09D9 0A11 0A48 0...      862                  dc.w    $9D9,$A11,$A48,$A7F,$AB4,$AE9,$B1D,$B50,$B82
000015BC= 0BB3 0BE3 0C13 0...      863                  dc.w    $BB3,$BE3,$C13,$C41,$C6F,$C9B,$CC7,$CF1,$D1B
000015CE= 0D43 0D6B 0D91 0...      864                  dc.w    $D43,$D6B,$D91,$DB6,$DDB,$DFE,$E20,$E41,$E61
000015E0= 0E80 0E9D 0EBA 0...      865                  dc.w    $E80,$E9D,$EBA,$ED5,$EEF,$F08,$F20,$F37,$F4D
000015F2= 0F61 0F74 0F86 0...      866                  dc.w    $F61,$F74,$F86,$F97,$FA6,$FB4,$FC1,$FCD,$FD8
00001604= 0FE1 0FE9 0FF0 0...      867                  dc.w    $FE1,$FE9,$FF0,$FF6,$FFA,$FFD,$FFF,$FFF
00001614                           868  
00001614  =000000B4                869  SINTABLESIZE            EQU 180 ; 90 * 2 (word size)
00001614  =000000B4                870  -------------------- end include --------------------
00001614                           871  * INCLUDE "./7_segment_led.x68" ; Displays a 7-segment LED with the given parameters.
00001614                           872  
00001614                           873  *,__________________________________________________,
00001614                           874  *| fn Main
00001614                           875  *| Description: Loads files, sets game state, begins
00001614                           876  *|              game loop, and handles quit state
00002000                           877  START ORG $2000
00002000                           878  Main:
00002000                           879      ; Initialize pixel_clear_length
00002000  23FC 00262E02 00262EA2   880      move.l #pixel_clear_zones, pixel_clear_length
0000200A                           881  
0000200A  705C                     882      move.l #92, d0
0000200C  7211                     883      move.l #17, d1
0000200E                           884      
0000200E  4E4F                     885      TRAP #15
00002010                           886  
00002010  4EB8 1000                887      jsr fl_LoadFiles
00002014                           888      
00002014  7000                     889      move.l #$00000000, d0   ; Position has no offset
00002016  7200                     890      move.l #$00000000, d1   ; This is not a sprite, it's the background
00002018  207C 001329BA            891      move.l #pg_Background, a0
0000201E  4EB8 1110                892      jsr r_PrintImage
00002022                           893      
00002022                           894      ; Set up start variables for game loop
00002022  2A3C 0221012C            895      move.l #$0221012C, d5   ; Start position of ship   
00002028                           896  
00002028  7008                     897      move.l #8, d0
0000202A  4E4F                     898      TRAP #15
0000202C                           899  
0000202C  4EB9 00002036            900      jsr GameLoop
00002032                           901  
00002032  4E72 3000                902      STOP #$3000
00002036                           903  *| [End of Function] Main
00002036                           904  *|__________________________________________________
00002036                           905  *`                                                  `
00002036                           906  
00002036                           907  *,__________________________________________________,
00002036                           908  *| fn GameLoop
00002036                           909  *| Description: Perpetually runs game until the quit 
00002036                           910  *| command is given.
00002036                           911  *| Persistent Variables:
00002036                           912  *| d2: Rotation, DeltaTime 
00002036                           913  *| d3: WASD Inputs, d4: Enter, Esc, Shift, and Space Inputs
00002036                           914  *| d5: Position, d6: Velocity, d7: Acceleration
00002036                           915  *| a3: Ship model to use
00002036                           916  GameLoop:
00002036  7008                     917      move.l #8, d0  ; Time Code - maybe reuse later?
00002038                           918  
00002038  4E4F                     919      TRAP #15
0000203A                           920  
0000203A  2001                     921      move.l d1, d0
0000203C  90B9 0000208C            922      sub.l LastTime, d0
00002042  B0BC 00000003            923      cmp.l #3, d0            ; Is time elapsed less than 5 seconds?
00002048  6300 FFEC                924      bls.l GameLoop          ; If not, wait
0000204C  23C1 0000208C            925      move.l d1, LastTime     ; Otherwise, this is the new last time
00002052                           926  
00002052                           927      *,___________________________,
00002052                           928      *| STAGE ONE: Capture Inputs |
00002052                           929      *|___________________________|
00002052                           930      *`                           ` 
00002052  4EB8 1230                931      jsr i_CaptureInputs   ; Fills registers d3-d4 (destructively) with player inputs
00002056                           932  
00002056                           933      *,___________________________,
00002056                           934      *| STAGE TWO: Physics Pass   |
00002056                           935      *|___________________________|
00002056                           936      *`                           `
00002056  4EB8 1250                937      jsr ph_CalculateRotation
0000205A  4EB8 12BC                938      jsr ph_SelectShipRotation
0000205E                           939  
0000205E  4EB8 1354                940      jsr ph_CalculateAcceleration
00002062  4EB8 13E6                941      jsr ph_CalculateVelocity
00002066  4EB8 1424                942      jsr ph_CalculatePosition
0000206A                           943  
0000206A                           944      *,___________________________,
0000206A                           945      *| STAGE THREE: UI Pass      |
0000206A                           946      *|___________________________|
0000206A                           947      *`                           `
0000206A                           948  
0000206A                           949      *,___________________________,
0000206A                           950      *| STAGE FOUR: Rendering     |
0000206A                           951      *|___________________________|
0000206A                           952      *`                           `
0000206A                           953      ; Clear old sprites from screen
0000206A  4EB8 1198                954      jsr r_ClearSprites ; Wipe sprites from screen
0000206E                           955  
0000206E                           956      ; Render ship
0000206E                           957      ; move.l #pg_Ship, a0
0000206E  204B                     958      move.l a3, a0   ; Move ship image address to the correct location
00002070  2005                     959      move.l d5, d0   ; Move position to offset
00002072  4EB8 1110                960      jsr r_PrintImage
00002076                           961  
00002076                           962      ; Render other things
00002076                           963  
00002076                           964      ; Swap Buffer
00002076  4EB8 1226                965      jsr SwapBuffer
0000207A                           966  
0000207A  C8BC 00FF0000            967      and.l #$00FF0000, d4
00002080  B8BC 00FF0000            968      cmp.l #$00FF0000, d4    ; Did player press ESC?
00002086  6600 FFAE                969      bne.l GameLoop  ; If not, continue loop
0000208A                           970  
0000208A  4E75                     971      rts
0000208C                           972  *| [End of Function] GameLoop
0000208C                           973  *|__________________________________________________
0000208C                           974  *`                                                  `
0000208C                           975  
0000208C                           976  *,__________________________________________________,
0000208C                           977  *| Input Variables
0000208C                           978  LastTime    ds.l 1  ; Stores the last frame's start time
00002090                           979  
00002090                           980  BackgroundBmpFile   INCBIN "../resources/background.bmp"
0012E11A                           981  ; RoadCollisionFile   INCBIN "../resources/collision.txt"
0012E11A                           982  
0012E11A                           983  *| Ship Rotations
0012E11A                           984  ShipBmpFiles        INCBIN "../resources/ship_rotations/Ship_R0.bmp"
0012E5A4                           985                      INCBIN "../resources/ship_rotations/Ship_R22.5.bmp"
0012EA2E                           986                      INCBIN "../resources/ship_rotations/Ship_R45.bmp"
0012EEB8                           987                      INCBIN "../resources/ship_rotations/Ship_R67.5.bmp"
0012F342                           988                      INCBIN "../resources/ship_rotations/Ship_R90.bmp"
0012F7CC                           989                      INCBIN "../resources/ship_rotations/Ship_R112.5.bmp"
0012FC56                           990                      INCBIN "../resources/ship_rotations/Ship_R135.bmp"
001300E0                           991                      INCBIN "../resources/ship_rotations/Ship_R157.5.bmp"
0013056A                           992                      INCBIN "../resources/ship_rotations/Ship_R180.bmp"
001309F4                           993                      INCBIN "../resources/ship_rotations/Ship_R202.5.bmp"
00130E7E                           994                      INCBIN "../resources/ship_rotations/Ship_R225.bmp"
00131308                           995                      INCBIN "../resources/ship_rotations/Ship_R247.5.bmp"
00131792                           996                      INCBIN "../resources/ship_rotations/Ship_R270.bmp"
00131C1C                           997                      INCBIN "../resources/ship_rotations/Ship_R292.5.bmp"
001320A6                           998                      INCBIN "../resources/ship_rotations/Ship_R315.bmp"
00132530                           999                      INCBIN "../resources/ship_rotations/Ship_R337.5.bmp"
001329BA                          1000  EndShipBmpFiles
001329BA                          1001  
001329BA                          1002  
001329BA                          1003  ; DebrisBmpFile       INCBIN "../resources/debris.bmp"
001329BA                          1004  
001329BA                          1005  ; 7SegVerticalBmpFile INCBIN "../resources/7SegVertical.bmp"
001329BA                          1006  ; 7SegVerticalBmpFile INCBIN "../resources/7SegHorizontal.bmp"
001329BA                          1007  
001329BA                          1008  *,__________________________________________________,
001329BA                          1009  *| Global Variables
001329BA                          1010  
001329BA                          1011  *| Data Type: Pixel Grid (pg)
001329BA                          1012  *| $0 = Width
001329BA                          1013  *| $2 = Height
001329BA                          1014  *| $4 = ABGR Pixels (List, length x * y)
001329BA                          1015  *>Renderer
001329BA                          1016  pg_Background   ds.l 307201     ; 1 + 640x480
0025E9BE                          1017  
0025E9BE                          1018  pg_ShipRotations        ds.l 4112   ; (1 + 16x16) x 16 for 16 unique sprites
002629FE                          1019  
002629FE                          1020  pg_Debris       ds.l 257        ; 1 + 16x16
00262E02                          1021  
00262E02                          1022  *| vec2
00262E02                          1023  
00262E02                          1024  
00262E02                          1025  *| Data Type: Pixel Clear Zones -> List<vec2, vec2>
00262E02                          1026  *| An array storing the zones that need to be cleared of pixels
00262E02                          1027  *| Long 1: Stores a vec2 representing the offset in x, y
00262E02                          1028  *| Long 2: Stores a vec2 representing the width and height
00262E02                          1029  pixel_clear_zones   ds.l 40     ; Max of 20 zones to clear at any given time
00262EA2                          1030  pixel_clear_length   ds.l 1      ; Pointer to the last empty address
00262EA6                          1031  
00262EA6                          1032  *>7-Segment LED
00262EA6                          1033  pg_7SegVertical     ds.l 65     ; 1 + 16x4
00262FAA                          1034  pg_7SegHorizontal   ds.l 65     ; 1 + 16x4
002630AE                          1035      
002630AE                          1036      END    START

5 errors detected
5 warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACCEL_AMOUNT        3000
ALL_REG             7FFF
BACKGROUNDBMPFILE   2090
DECEL_AMOUNT        1000
ENDSHIPBMPFILES     1329BA
ENTER               D
ESC                 1B
FL_LOADBITMAP       1044
FL_LOADFILES        1000
FL_LOADSHIPROTATIONS  101A
FL_LOADSHIPROTATIONS:LOADBMP  1026
FP_11P25            B4000
FP_22P5             168000
FP_360              1680000
GAMELOOP            2036
GETBITMAPCHUNKS     108E
GETSINGLEPIXEL      10A8
GET_KEY_INPUT_COMMAND  13
I_CAPTUREINPUTS     1230
I_CAPTUREINPUTS:RETURN  124A
LASTTIME            208C
MAIN                2000
MAX_SPEED           2000
MAX_VELOCITY        30000
PARSEBITMAPHEADER   1048
PARSELITTLEENDIANLONG  1108
PG_7SEGHORIZONTAL   262FAA
PG_7SEGVERTICAL     262EA6
PG_BACKGROUND       1329BA
PG_DEBRIS           2629FE
PG_SHIPROTATIONS    25E9BE
PH_CALCULATEACCELERATION  1354
PH_CALCULATEACCELERATION:ACCEL  137A
PH_CALCULATEACCELERATION:CLAMP  13E0
PH_CALCULATEACCELERATION:DECEL  1382
PH_CALCULATEACCELERATION:FRIC  13CA
PH_CALCULATEACCELERATION:RETURN  13E0
PH_CALCULATEACCELERATION:VEC  1384
PH_CALCULATEPOSITION  1424
PH_CALCULATEPOSITION:RETURN  1454
PH_CALCULATEROTATION  1250
PH_CALCULATEROTATION:ANGLEOVER  12A4
PH_CALCULATEROTATION:ANGLEUNDER  12B0
PH_CALCULATEROTATION:FIXANGLE  128A
PH_CALCULATEROTATION:RETURN  12B6
PH_CALCULATEROTATION:TURNLEFT  126E
PH_CALCULATEROTATION:TURNRIGHT  1284
PH_CALCULATEVELOCITY  13E6
PH_CALCULATEVELOCITY:APPLY  140E
PH_CALCULATEVELOCITY:FRIC  140E
PH_CALCULATEVELOCITY:RETURN  141E
PH_CALCULATEVELOCITYDIRECTION  134E
PH_CALCULATEVELOCITYDIRECTION:RET  134E
PH_CALCULATEVELOCITYMAGNITUDE  12FC
PH_CALCULATEVELOCITYMAGNITUDE:ACC  1322
PH_CALCULATEVELOCITYMAGNITUDE:DEC  132E
PH_CALCULATEVELOCITYMAGNITUDE:FRI  133A
PH_CALCULATEVELOCITYMAGNITUDE:RET  1348
PH_CLAMPNUMBER      145A
PH_CLAMPNUMBER:OVER  1482
PH_CLAMPNUMBER:RETURN  148A
PH_CLAMPNUMBER:UNDER  147A
PH_CLAMPVECTOR      148E
PH_CLAMPVECTOR:RETURN  14CA
PH_SELECTSHIPROTATION  12BC
PH_SELECTSHIPROTATION:GETFILE  12EA
PH_SELECTSHIPROTATION:NEXTROT  12CA
PH_SELECTSHIPROTATION:RETURN  12F6
PH_SINE             14D0
PH_SINE:Q1          14F8
PH_SINE:Q2          150A
PH_SINE:Q3          1528
PH_SINE:Q4          1542
PH_SINE:RETURN      155C
PIXEL_CLEAR_LENGTH  262EA2
PIXEL_CLEAR_ZONES   262E02
PRINT_PIXEL         52
R_CLEARSPRITES      1198
R_CLEARSPRITES:CHECKENDOFSPRITES  1210
R_CLEARSPRITES:CLEARPIXEL  11DA
R_CLEARSPRITES:CLEARSPRITE  11DA
R_CLEARSPRITES:GETSPRITE  11B4
R_CLEARSPRITES:LOADREGISTER  119C
R_CLEARSPRITES:PRINTBGPIXEL  11EC
R_CLEARSPRITES:RETURN  1220
R_PRINTIMAGE        1110
R_PRINTIMAGE:LOADVARSTOREGISTERS  1134
R_PRINTIMAGE:NOPRINT  117E
R_PRINTIMAGE:PRINTPIXEL  1162
R_PRINTIMAGE:RETURN  1192
SCREEN_HEIGHT       1E0
SCREEN_WIDTH        280
SET_PIXEL_COLOR     50
SHIFT               10
SHIPBMPFILES        12E11A
SHIP_BMP_SIZE       48A
SHIP_PG_SIZE        404
SINTABLE            155E
SINTABLESIZE        B4
SPACE               20
START               2000
SWAPBUFFER          1226
SWAP_BUFFER         5E
TRAP_REG            703
