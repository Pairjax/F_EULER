00002000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/17/2023 9:32:40 PM

00000000                             1  *,______________________________________________________,
00000000                             2  *|__________  ______________  ________________________  |
00000000                             3  *|___  ____/  ___  ____/_  / / /__  /___  ____/__  __ \ |
00000000                             4  *|__  /_________  __/  _  / / /__  / __  __/  __  /_/ / |
00000000                             5  *|_  __//_____/  /___  / /_/ / _  /___  /___  _  _, _/  |
00000000                             6  *|/_/         /_____/  \____/  /_____/_____/  /_/ |_|   |
00000000                             7  *|                                                      |
00000000                             8  *|            The 68k high-speed racing game            |
00000000                             9  *|                                                      |
00000000                            10  *|  Made By: Austin Smith        Date Started: 10/7/23  |
00000000                            11  *|______________________________________________________|
00000000                            12  *`                                                      `
00000000                            13  
00001000                            14      ORG $1000
00001000                            15  
00001000                            16  *,__________________________________________________,
00001000                            17  *| Constants
00001000                            18  
00001000                            19  ALL_REG             REG D0-D7/A0-A6
00001000                            20  TRAP_REG            REG D0-D1/A0-A2
00001000                            21  
00001000                            22  *| Vectors
00001000  =00000280                 23  SCREEN_WIDTH        EQU 640
00001000  =000001E0                 24  SCREEN_HEIGHT       EQU 480
00001000                            25  
00001000                            26  *| TRAP Codes
00001000  =00000013                 27  GET_KEY_INPUT_COMMAND   EQU 19
00001000                            28  
00001000  =00000050                 29  SET_PIXEL_COLOR     EQU 80
00001000  =00000052                 30  PRINT_PIXEL         EQU 82
00001000                            31  
00001000  =00000008                 32  GET_TIME            EQU 8
00001000                            33  
00001000  =0000005E                 34  SWAP_BUFFER         EQU 94
00001000                            35  
00001000                            36  *,__________________________________________________,
00001000                            37  *| Includes
00001000                            38      INCLUDE "./file_loader.x68"   ; Handles loading of files during preload phase
00001000                            39  
00001000  =0000048A                 40  SHIP_BMP_SIZE       EQU 1162    ; The number of bytes betwen each ship file
00001000  =00000404                 41  SHIP_PG_SIZE        EQU 1028     ; The size of a ship sprite in memory
00001000                            42  
00001000                            43  fl_LoadFiles:
00001000                            44      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001000  207C 00001198             45      move.l #BackgroundBmpFile, a0   *| file_root
00001006  227C 0017D046             46      move.l #pg_Background, a1       *| output_image
0000100C  4EB9 0000106E             47      jsr fl_LoadBitmap
00001012                            48  
00001012                            49      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001012  207C 002ADA16             50      move.l #SevenSegVerticalBmpFile, a0   *| file_root
00001018  227C 002ADC7C             51      move.l #pg_7SegVertical, a1       *| output_image
0000101E  4EB9 0000106E             52      jsr fl_LoadBitmap
00001024                            53  
00001024                            54      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001024  207C 002ADB30             55      move.l #SevenSegHorizontalBmpFile, a0   *| file_root
0000102A  227C 002ADD80             56      move.l #pg_7SegHorizontal, a1       *| output_image
00001030  4EB9 0000106E             57      jsr fl_LoadBitmap
00001036                            58  
00001036  4EB9 0000113A             59      jsr fl_LoadCollisionMap     ; No inputs needed because there is only one
0000103C                            60  
0000103C  4EB9 00001044             61      jsr fl_LoadShipRotations
00001042                            62      
00001042  4E75                      63      rts
00001044                            64  
00001044                            65  fl_LoadShipRotations:
00001044  207C 001785E2             66      move.l #ShipBmpFiles, a0
0000104A  227C 002A904A             67      move.l #pg_ShipRotations, a1
00001050                            68  
00001050                            69  .LoadBmp:
00001050  4EB9 0000106E             70      jsr fl_LoadBitmap
00001056                            71  
00001056  D1FC 0000048A             72      add.l #SHIP_BMP_SIZE, a0
0000105C  D3FC 00000404             73      add.l #SHIP_PG_SIZE, a1
00001062                            74  
00001062  B1FC 0017CE82             75      cmp.l #EndShipBmpFiles, a0  ; Are we past the end?
00001068  6D00 FFE6                 76      blt.l .LoadBmp              ; If not, keep on loading.
0000106C                            77  
0000106C  4E75                      78      rts
0000106E                            79  
0000106E                            80  fl_LoadBitmap:
0000106E  48E7 FFFE                 81      movem.l ALL_REG, -(sp) *| Push registers to stack
00001072                            82  
00001072                            83  ParseBitmapHeader: ; Gather essential information from the bitmap's header
00001072                            84      ; This will need to be converted to Big Endian later based on the Color Range
00001072  2648                      85      move.l a0, a3
00001074  D7FC 0000000A             86      add.l #$A, a3               ; Offset to pixel array
0000107A  2213                      87      move.l (a3), d1
0000107C                            88          
0000107C  4EB9 00001132             89      jsr ParseLittleEndianLong
00001082                            90          
00001082  D288                      91      add.l a0, d1
00001084  2801                      92      move.l d1, d4               ; Offset to Pixel Array
00001086                            93          
00001086  2648                      94      move.l a0, a3
00001088  D7FC 00000012             95      add.l #$12, a3              ; Offset to image width
0000108E  2213                      96      move.l (a3), d1             ; Image Width
00001090  4EB9 00001132             97      jsr ParseLittleEndianLong
00001096  2A01                      98      move.l d1, d5
00001098                            99          
00001098  2648                     100      move.l a0, a3
0000109A  D7FC 00000016            101      add.l #$16, a3              ; Offset to image height
000010A0  2213                     102      move.l (a3), d1             ; Image Height
000010A2  4EB9 00001132            103      jsr ParseLittleEndianLong
000010A8  2C01                     104      move.l d1, d6
000010AA                           105      
000010AA  3285                     106      move.w d5, (a1)             ; Push width & height to pixel grid
000010AC  5489                     107      add.l #2, a1
000010AE  3286                     108      move.w d6, (a1)
000010B0  5489                     109      add.l #2, a1                ; Offset to start of pixel data in pixel grid
000010B2                           110          
000010B2  5C8B                     111      add.l #$6, a3
000010B4  3213                     112      move.w (a3), d1             ; ColorRange
000010B6  E159                     113      rol.w #8, d1
000010B8                           114  
000010B8                           115  GetBitmapChunks:                ; Get the desired chunks of the bitmap
000010B8                           116                                  ; Finding starting address
000010B8  2006                     117      move.l d6, d0               ; Height (H)
000010BA  5380                     118      sub.l #1, d0                ; Sub by 1 to get column H - 1
000010BC  2205                     119      move.l d5, d1
000010BE  C0C1                     120      mulu.w d1, d0               ; Multiply by width to get last index of column CY - 1
000010C0                           121          
000010C0  2200                     122      move.l d0, d1               ; Storing in a separate variable so we can keep the index for other calculations
000010C2  E589                     123      lsl.l #2, d1                ; Multiply by size of each pixel (Long Word).
000010C4  D284                     124      add.l d4, d1                ; Beginning of Pixel Array + Offset to Chunk Start
000010C6  2041                     125      move.l d1, a0               ; Current Pixel Address
000010C8                           126          
000010C8                           127      ; Finding end-of-row index
000010C8  D085                     128      add.l d5, d0                ; Add Chunk Width to push it to the end of the desired chunk's first row.
000010CA  E588                     129      lsl.l #2, d0                ; Multiply by size of each pixel (Long Word).
000010CC  D084                     130      add.l d4, d0                ; Beginning of Pixel Array + Offset to End-Of-Row
000010CE  2440                     131      move.l d0, a2               ; End Of Row Pixel Address
000010D0                           132          
000010D0                           133      ; Finding ending address
000010D0  2644                     134      move.l d4, a3   ; Represents the end row of the chunk's Address.
000010D2                           135  
000010D2                           136  GetSinglePixel:
000010D2                           137      ; Get pixel data
000010D2  2210                     138      move.l (a0), d1
000010D4                           139          
000010D4  4EB9 00001132            140      jsr ParseLittleEndianLong ; Convert to big endian
000010DA  2001                     141      move.l d1, d0   ; Move back to d0 after conversion
000010DC                           142         
000010DC  2200                     143      move.l d0, d1   ; Red
000010DE  E089                     144      lsr.l #8, d1    ; Red is the 3rd element, so we shift it 2 bytes over        
000010E0  E089                     145      lsr.l #8, d1    ; Have to cut it in byte increments.
000010E2  C2BC 000000FF            146      and.l #$FF, d1  ; Chopping off the channel bits that remain to the left.
000010E8                           147      
000010E8  2400                     148      move.l d0, d2   ; Green
000010EA  E08A                     149      lsr.l #8, d2    ; Green is the 2nd element, so we shift it 1 byte.
000010EC  C4BC 000000FF            150      and.l #$FF, d2  ; Chopping off the channel bits that remain to the left.
000010F2                           151          
000010F2  2600                     152      move.l d0, d3   ; Blue
000010F4  C6BC 000000FF            153      and.l #$FF, d3  ; Chopping off the channel bits that remain to the left.
000010FA                           154          
000010FA                           155      ; Shift these bits to the correct location for when we read it in BGR
000010FA  E18B                     156      lsl.l #8, d3    ; Blue is first, so we're shifting it to the 3rd byte
000010FC  E18B                     157      lsl.l #8, d3
000010FE                           158        
000010FE  E18A                     159      lsl.l #8, d2    ; Green is next, which goes to the 2nd byte.
00001100                           160          
00001100                           161      ; Red stays in place, now we merge the three variables into one
00001100  C0BC FF000000            162      and.l #$FF000000, d0
00001106  8081                     163      or.l d1, d0
00001108  8082                     164      or.l d2, d0
0000110A  8083                     165      or.l d3, d0
0000110C                           166          
0000110C                           167      ; Push to BitmapChunk location
0000110C  2280                     168      move.l d0, (a1)
0000110E                           169          
0000110E                           170      ; Move Bitmap Chunk Pointer to next pixel
0000110E  5889                     171      add.l #4, a1
00001110                           172          
00001110                           173      ; Move Pixel Array Pointer to the next pixel
00001110  5888                     174      add.l #4, a0            ; Move over 1 pixel
00001112  B5C8                     175      cmp.l a0, a2            ; Is current Pixel Array Pointer past End of Row?
00001114  6E00 FFBC                176      bgt.l GetSinglePixel    ; If not, continue the loop 
00001118                           177          
00001118                           178      ; If so, let's move the End of Row to the next row (backwards)
00001118  2005                     179      move.l d5, d0
0000111A  E588                     180      lsl.l #2, d0    ; Multiply by size of each index
0000111C  95C0                     181      sub.l d0, a2
0000111E                           182          
0000111E                           183      ; Let's also move the Current Pixel Address to the start of the next row.
0000111E  2005                     184      move.l d5, d0           ; Move pointer back by 2xImageWidth
00001120  D085                     185      add.l d5, d0
00001122  E588                     186      lsl.l #2, d0
00001124  91C0                     187      sub.l d0, a0
00001126                           188          
00001126                           189      ; Have we passed the end of the chunk?
00001126  B7C8                     190      cmp.l a0, a3            ; Is Current Pixel Address past the index of End of Chunk index?
00001128  6F00 FFA8                191      ble.l GetSinglePixel    ; If not, continue the loop
0000112C                           192          
0000112C                           193      ; If so, we've finished sorting.
0000112C  4CDF 7FFF                194      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001130                           195  
00001130  4E75                     196      rts
00001132                           197  
00001132                           198  ParseLittleEndianLong:  ; Simple function to convert d1 LW from Little Endian to Big Endian
00001132  E159                     199      rol.w #8, d1
00001134  4841                     200      swap d1
00001136  E159                     201      rol.w #8, d1
00001138                           202          
00001138  4E75                     203      rts
0000113A                           204  
0000113A                           205  fl_LoadCollisionMap:
0000113A  207C 0012D222            206      move.l #RoadCollisionFile, a0
00001140  227C 002ADF6C            207      move.l #cm_Road, a1 ; Start of array
00001146                           208  
00001146  7000                     209      move.l #0, d0       ; Current index in array
00001148                           210  
00001148                           211  .GetPixelMat:           ; Get pixel material
00001148  1210                     212      move.b (a0), d1 
0000114A                           213      
0000114A                           214  .OffRoad:
0000114A  B23C 0030                215      cmp.b #$30, d1      ; Is material offroad?
0000114E  6600 000A                216      bne.l .OnRoad       ; Move to next case
00001152                           217  
00001152  12BC 0000                218      move.b #0, (a1)
00001156  5280                     219      add.l #1, d0
00001158  5289                     220      add.l #1, a1
0000115A                           221  
0000115A                           222  .OnRoad:
0000115A  B23C 0031                223      cmp.b #$31, d1      ; Is material onroad?
0000115E  6600 000A                224      bne.l .Lap          ; Move to next case
00001162                           225  
00001162  12BC 0001                226      move.b #1, (a1)
00001166  5280                     227      add.l #1, d0
00001168  5289                     228      add.l #1, a1
0000116A                           229  
0000116A                           230  .Lap:
0000116A  B23C 0032                231      cmp.b #$32, d1      ; Is material lap?
0000116E  6600 000A                232      bne.l .MidLap       ; Move to next case
00001172                           233  
00001172  12BC 0002                234      move.b #2, (a1)
00001176  5280                     235      add.l #1, d0
00001178  5289                     236      add.l #1, a1
0000117A                           237  
0000117A                           238  .MidLap:
0000117A  B23C 0033                239      cmp.b #$33, d1      ; Is material mid-lap?
0000117E  6600 000A                240      bne.l .End          ; Move to next case
00001182                           241  
00001182  12BC 0003                242      move.b #3, (a1)
00001186  5280                     243      add.l #1, d0
00001188  5289                     244      add.l #1, a1
0000118A                           245  
0000118A                           246  .End:
0000118A  5288                     247      add.l #1, a0
0000118C                           248  
0000118C  B0BC 0004B000            249      cmp.l #307200, d0   ; Are we at end of array?
00001192  6D00 FFB4                250      blt.l .GetPixelMat  ; Otherwise, let's start it all over again
00001196                           251  
00001196                           252  .Return:
00001196  4E75                     253      rts
00001198                           254  
00001198                           255  
00001198                           256  
00001198                           257  BackgroundBmpFile   INCBIN "../resources/background.bmp"
0012D222                           258  RoadCollisionFile   INCBIN "../resources/collision_map.txt"
001785E2                           259  
001785E2                           260  ShipBmpFiles        INCBIN "../resources/ship_rotations/Ship_R0.bmp"
00178A6C                           261                      INCBIN "../resources/ship_rotations/Ship_R22.5.bmp"
00178EF6                           262                      INCBIN "../resources/ship_rotations/Ship_R45.bmp"
00179380                           263                      INCBIN "../resources/ship_rotations/Ship_R67.5.bmp"
0017980A                           264                      INCBIN "../resources/ship_rotations/Ship_R90.bmp"
00179C94                           265                      INCBIN "../resources/ship_rotations/Ship_R112.5.bmp"
0017A11E                           266                      INCBIN "../resources/ship_rotations/Ship_R135.bmp"
0017A5A8                           267                      INCBIN "../resources/ship_rotations/Ship_R157.5.bmp"
0017AA32                           268                      INCBIN "../resources/ship_rotations/Ship_R180.bmp"
0017AEBC                           269                      INCBIN "../resources/ship_rotations/Ship_R202.5.bmp"
0017B346                           270                      INCBIN "../resources/ship_rotations/Ship_R225.bmp"
0017B7D0                           271                      INCBIN "../resources/ship_rotations/Ship_R247.5.bmp"
0017BC5A                           272                      INCBIN "../resources/ship_rotations/Ship_R270.bmp"
0017C0E4                           273                      INCBIN "../resources/ship_rotations/Ship_R292.5.bmp"
0017C56E                           274                      INCBIN "../resources/ship_rotations/Ship_R315.bmp"
0017C9F8                           275                      INCBIN "../resources/ship_rotations/Ship_R337.5.bmp"
0017CE82                           276  EndShipBmpFiles
0017CE82                           277  
0017CE82                           278  -------------------- end include --------------------
0017CE82                           279      INCLUDE "./renderer.x68"      ; Handles printing sprites & affine transformations.
0017CE82                           280  
0017CE82                           281  r_PrintImage: 
0017CE82  48E7 FFFE                282      movem.l ALL_REG, -(sp)  *| Push registers to stack
0017CE86                           283  
0017CE86                           284      *| Move starting variables to non-volatile positions
0017CE86  2400                     285      move.l d0, d2           ; offset: vec2
0017CE88  2010                     286      move.l (a0), d0         ; Image dimensions
0017CE8A                           287  
0017CE8A  B2BC 00000000            288      cmp.l #0, d1    ; Is this a sprite?
0017CE90  6700 0014                289      beq.l .LoadVarsToRegisters            ; If not, let's skip this step.
0017CE94                           290      *| We need to store the offset: vec2 and image dimensions: vec2
0017CE94                           291      *| for clearing next frame's data.
0017CE94                           292      
0017CE94  2279 0017D042            293      move.l pixel_clear_length, a1
0017CE9A  2282                     294      move.l d2, (a1)  ; Move image offset to pixel_clear_zones
0017CE9C  5889                     295      add.l #4, a1     ; Move to next word
0017CE9E  2280                     296      move.l d0, (a1)  ; Move image dimensions to pixel_clear_zones
0017CEA0  50B9 0017D042            297      add.l #8, pixel_clear_length     ; Move to next word
0017CEA6                           298  
0017CEA6                           299  .LoadVarsToRegisters:
0017CEA6                           300  
0017CEA6                           301      *| Set up the starting variables for printing pixels
0017CEA6  2602                     302      move.l d2, d3
0017CEA8  E08B                     303      lsr.l #8, d3            ; Offset X
0017CEAA  E08B                     304      lsr.l #8, d3
0017CEAC  C4BC 0000FFFF            305      and.l #$0000FFFF, d2    ; Offset Y
0017CEB2                           306         
0017CEB2  2200                     307      move.l d0, d1
0017CEB4  E088                     308      lsr.l #8, d0            ; Image Width (left word)
0017CEB6  E088                     309      lsr.l #8, d0
0017CEB8  2800                     310      move.l d0, d4           ; Store width in d4 to prevent destruction
0017CEBA  C2BC 0000FFFF            311      and.l #$0000FFFF, d1    ; Image Height (right word)
0017CEC0                           312          
0017CEC0  2A03                     313      move.l d3, d5           ; Start X Position
0017CEC2                           314      
0017CEC2  4286                     315      clr.l d6
0017CEC4  3C03                     316      move.w d3, d6           ; End X Position
0017CEC6  DC80                     317      add.l d0, d6
0017CEC8  5386                     318      sub.l #1, d6
0017CECA                           319          
0017CECA  4287                     320      clr.l d7
0017CECC  3E02                     321      move.w d2, d7           ; End Y Position
0017CECE  DE81                     322      add.l d1, d7
0017CED0  5387                     323      sub.l #1, d7
0017CED2                           324      
0017CED2  5888                     325      add.l #4, a0
0017CED4                           326          
0017CED4                           327  .PrintPixel:
0017CED4  2210                     328      move.l (a0), d1             ; Get current pixel color
0017CED6                           329  
0017CED6  B2BC 00FFFFFF            330      cmp.l #$00FFFFFF, d1        ; Is pixel color transparent?
0017CEDC  6300 0012                331      bls.l .NoPrint              ; If so, let's skip printing
0017CEE0                           332      
0017CEE0  7050                     333      move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
0017CEE2                           334  
0017CEE2  C2BC 00FFFFFF            335      and.l #$00FFFFFF, d1        ; Chop off alpha
0017CEE8                           336          
0017CEE8  4E4F                     337      TRAP #15
0017CEEA                           338                 
0017CEEA  7052                     339      move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
0017CEEC  2203                     340      move.l d3, d1               ; Pixel X location must be extracted 
0017CEEE                           341     
0017CEEE  4E4F                     342      TRAP #15
0017CEF0                           343        
0017CEF0                           344  .NoPrint:
0017CEF0                           345      ; Calculate the next target pixel.
0017CEF0  5888                     346      add.l #4, a0            ; Move pointer to next color pixel
0017CEF2                           347          
0017CEF2  5283                     348      add.l #1, d3            ; Move X to the next column
0017CEF4  B686                     349      cmp.l d6, d3            ; Is X past End X Position?
0017CEF6  6300 FFDC                350      bls.l .PrintPixel        ; If not, keep on printing
0017CEFA                           351          
0017CEFA                           352      ; Otherwise, we move to the next row
0017CEFA  9684                     353      sub.l d4, d3            ; Move X back to the starting column
0017CEFC  5282                     354      add.l #1, d2            ; Move Y down a row
0017CEFE                           355          
0017CEFE  B487                     356      cmp.l d7, d2            ; Is Y past End Y Position?
0017CF00  6F00 FFD2                357      ble.l .PrintPixel         ; If not, keep printing.
0017CF04                           358  
0017CF04                           359  .Return:
0017CF04                           360  
0017CF04  4CDF 7FFF                361      movem.l (sp)+, ALL_REG  *| Pull registers from stack
0017CF08                           362  
0017CF08  4E75                     363      rts
0017CF0A                           364  
0017CF0A                           365  
0017CF0A                           366  r_ClearSprites:
0017CF0A  48E7 FFFE                367      movem.l ALL_REG, -(sp) *| Push registers to stack
0017CF0E                           368  
0017CF0E                           369  .LoadRegister:
0017CF0E  207C 0017CFA2            370      move.l #pixel_clear_zones, a0    ; Current sprite index
0017CF14  2279 0017D042            371      move.l (pixel_clear_length), a1   ; End sprite index
0017CF1A  247C 0017D046            372      move.l #pg_Background, a2        ; Background
0017CF20                           373  
0017CF20                           374      ; Is pixel clear zones empty?
0017CF20  B3C8                     375      cmp.l a0, a1
0017CF22  6700 006E                376      beq.l .Return                ; If list is empty, simply return.
0017CF26                           377  
0017CF26                           378  .GetSprite:
0017CF26                           379      *| Extracting offset into registers for processing.
0017CF26  2610                     380      move.l (a0), d3                 ; offset: vec2
0017CF28                           381      
0017CF28  2403                     382      move.l d3, d2                   ; Separate into two registers
0017CF2A                           383  
0017CF2A  E08B                     384      lsr.l #8, d3                    ; Offset X: int
0017CF2C  E08B                     385      lsr.l #8, d3                    ; Will be used as Current X for loop
0017CF2E                           386  
0017CF2E  C4BC 0000FFFF            387      and.l #$0000FFFF, d2            ; Offset Y: int
0017CF34                           388                                      ; Will be used as Current Y for loop
0017CF34                           389  
0017CF34                           390      *| Extracting dimensions to registers for processing
0017CF34  5888                     391      add.l #4, a0                    ; Push to next long
0017CF36  2810                     392      move.l (a0), d4                 ; dimensions: vec2
0017CF38  2A04                     393      move.l d4, d5                   ; Separate into two registers
0017CF3A                           394  
0017CF3A  E08C                     395      lsr.l #8, d4                    ; Width: int
0017CF3C  E08C                     396      lsr.l #8, d4
0017CF3E                           397  
0017CF3E  CABC 0000FFFF            398      and.l #$0000FFFF, d5            ; Height: int
0017CF44                           399  
0017CF44                           400      *| Get ending x and y positions
0017CF44  2C03                     401      move.l d3, d6                   ; X Offset
0017CF46  DC84                     402      add.l d4, d6                    ; Plus Width
0017CF48                           403                                      ; = End X Pos
0017CF48                           404      
0017CF48  2E02                     405      move.l d2, d7                   ; Y Offset
0017CF4A  DE85                     406      add.l d5, d7                    ; Plus Height
0017CF4C                           407                                      ; = End Y Pos
0017CF4C                           408  
0017CF4C                           409  .ClearSprite:
0017CF4C                           410      *,__________________________________________________,
0017CF4C                           411      *| For Loop: for x = Offset X, x < Offset X + Width, x++
0017CF4C                           412  .ClearPixel:
0017CF4C                           413              *| Get Background Pixel
0017CF4C  2202                     414              move.l d2, d1   ; Get offset to pixel address of background.
0017CF4E  C2FC 0280                415              mulu.w #SCREEN_WIDTH, d1   ; multiplied by width
0017CF52  D283                     416              add.l d3, d1    ; plus X offset
0017CF54                           417              
0017CF54  5281                     418              add.l #1, d1    ; + 1 to account for dimension data in Pixel Grid 
0017CF56  E589                     419              lsl.l #2, d1    ; Multiplied by size of Long
0017CF58                           420  
0017CF58  264A                     421              move.l a2, a3   ; Add this to the address of the pixel grid
0017CF5A  D7C1                     422              add.l d1, a3    ; Shifting offset to the desired pixel
0017CF5C  2213                     423              move.l (a3), d1 ; Overwrite d1 to save register space
0017CF5E                           424                              ; d1 now stores the hex color of the pixel
0017CF5E                           425              
0017CF5E                           426  .PrintBgPixel:
0017CF5E                           427              *| Note that we set up the previous registers so all data
0017CF5E                           428              *| is in the right location. X is in d3 but will be moved to d1
0017CF5E                           429              *| once the first trap is done.
0017CF5E  7050                     430              move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
0017CF60                           431                  
0017CF60                           432              ; TODO: Make backround have no alpha so we can remove this line
0017CF60  C2BC 00FFFFFF            433              and.l #$00FFFFFF, d1        ; Chop off alpha
0017CF66                           434  
0017CF66  4E4F                     435              TRAP #15
0017CF68                           436  
0017CF68  2203                     437              move.l d3, d1               ; Move X pos to correct register
0017CF6A                           438                                          ; Y pos is already in correct register.   
0017CF6A                           439                      
0017CF6A  7052                     440              move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
0017CF6C                           441          
0017CF6C  4E4F                     442              TRAP #15
0017CF6E                           443  
0017CF6E  5283                     444              add.l #1, d3    ; x += 1
0017CF70  B686                     445              cmp.l d6, d3    ; is x past end x pos?
0017CF72  6F00 FFD8                446              ble.l .ClearPixel ; if not, continue parsing pixels
0017CF76                           447      *| End For Loop
0017CF76                           448  
0017CF76  9684                     449      sub.l d4, d3    ; Move x back to start location
0017CF78  5383                     450      sub.l #1, d3    ; - 1 for extra space moved past width.
0017CF7A                           451  
0017CF7A  5282                     452      add.l #1, d2    ; y += 1
0017CF7C  B487                     453      cmp.l d7, d2    ; Is y past end Y pos?
0017CF7E  6300 FFCC                454      bls.l .ClearSprite  ; If not, continue to next loop
0017CF82                           455  
0017CF82                           456  .CheckEndOfSprites:
0017CF82  B3C8                     457      cmp.l a0, a1                    ; Is current sprite index at or past end sprite index?
0017CF84  6D00 FFA0                458      blt.l .GetSprite                ; If not, let's keep on going.
0017CF88                           459  
0017CF88                           460      ; If we're done, we reset the clear zones as we have emptied it out
0017CF88  23FC 0017CFA2 0017D042   461      move.l #pixel_clear_zones, pixel_clear_length
0017CF92                           462  
0017CF92                           463  .Return:
0017CF92                           464  
0017CF92  4CDF 7FFF                465      movem.l (sp)+, ALL_REG  *| Pull registers from stack
0017CF96                           466  
0017CF96  4E75                     467      rts
0017CF98                           468  
0017CF98                           469  SwapBuffer:
0017CF98  2F00                     470      move.l d0, -(sp)
0017CF9A                           471      
0017CF9A  705E                     472      move.l #SWAP_BUFFER, d0
0017CF9C                           473      
0017CF9C  4E4F                     474      TRAP #15
0017CF9E                           475  
0017CF9E  201F                     476      move.l (sp)+, d0
0017CFA0                           477  
0017CFA0  4E75                     478      rts
0017CFA2                           479  
0017CFA2                           480  
0017CFA2                           481  pixel_clear_zones   ds.l 40     ; Max of 20 zones to clear at any given time
0017D042                           482  pixel_clear_length  ds.l 1      ; Pointer to the last empty address
0017D046                           483  
0017D046                           484  pg_Background   ds.l 307201     ; 1 + 640x480
002A904A                           485  pg_ShipRotations        ds.l 4112   ; (1 + 16x16) x 16 for 16 unique sprites
002AD08A                           486  pg_Debris       ds.l 257        ; 1 + 16x16
002AD48E                           487  
002AD48E                           488  -------------------- end include --------------------
002AD48E                           489      INCLUDE "./inputs.x68"        ; Handles player inputs for processing
002AD48E                           490  
002AD48E  =0000000D                491  ENTER               EQU $D
002AD48E  =0000001B                492  ESC                 EQU $1B
002AD48E  =00000010                493  SHIFT               EQU $10
002AD48E  =00000020                494  SPACE               EQU $20
002AD48E                           495  
002AD48E                           496  i_CaptureInputs:
002AD48E  48E7 C0E0                497      movem.l TRAP_REG, -(sp) *| Push registers to stack
002AD492                           498  
002AD492  7013                     499      move.l #GET_KEY_INPUT_COMMAND, d0
002AD494  223C 57415344            500      move.l #'W'<<24+'A'<<16+'S'<<8+'D', d1   ; WASD Inputs
002AD49A                           501      
002AD49A  4E4F                     502      TRAP #15
002AD49C                           503      
002AD49C  2601                     504      move.l d1, d3   ; d3 stores WASD Inputs for later processing
002AD49E                           505      
002AD49E  223C 0D1B1020            506      move.l #ENTER<<24+ESC<<16+SHIFT<<8+SPACE, d1   ; Enter, Esc, Shift, and Space Inputs
002AD4A4                           507      
002AD4A4  4E4F                     508      TRAP #15
002AD4A6                           509      
002AD4A6  2801                     510      move.l d1, d4   ; d4 stores other Inputs for later processing
002AD4A8                           511      
002AD4A8                           512  .Return:
002AD4A8  4CDF 0703                513      movem.l (sp)+, TRAP_REG *| Pull registers from stack
002AD4AC                           514  
002AD4AC  4E75                     515      rts
002AD4AC  4E75                     516  -------------------- end include --------------------
002AD4AE                           517  * INCLUDE "./gameplay.x68"        ; Handles in-game timer, lap counter, and game states
002AD4AE                           518      INCLUDE "./physics.x68"       ; Calculates player acceleration, velocity, and collisions.
002AD4AE                           519  
002AD4AE  =00030000                520  MAX_VELOCITY        EQU $00030000
002AD4AE  =01680000                521  FP_360              EQU $01680000   ; Hex value for 360 degrees in 16.16 fixed point
002AD4AE  =00168000                522  FP_22P5             EQU $00168000   ; Hex value for 22.5 degrees in 16.16 fixed point
002AD4AE  =000B4000                523  FP_11P25            EQU $000B4000   ; Hex value for 11.25 degrees in 16.16 fixed point
002AD4AE                           524  
002AD4AE  =00000100                525  ACCEL_AMOUNT        EQU $00000100   ; Increases speed at 0.125 pixels per frame 
002AD4AE  =00000100                526  DECEL_AMOUNT        EQU $00000100   ; Increases speed at 0.0625 pixels per frame 
002AD4AE                           527  
002AD4AE  =00001000                528  MAX_SPEED           EQU $00001000
002AD4AE                           529  
002AD4AE                           530  ph_CalculateRotation:
002AD4AE  48E7 C0E0                531      movem.l TRAP_REG, -(sp)  *| Push registers to stack
002AD4B2                           532  
002AD4B2  2003                     533      move.l d3, d0   ; Copying WASD inputs to extract A & D
002AD4B4  2200                     534      move.l d0, d1
002AD4B6                           535  
002AD4B6  E088                     536      lsr.l #8, d0            ; A key input
002AD4B8  E088                     537      lsr.l #8, d0
002AD4BA  C0BC 000000FF            538      and.l #$000000FF, d0    ; Chopping off W input
002AD4C0                           539  
002AD4C0  C2BC 000000FF            540      and.l #$000000FF, d1    ; D key input
002AD4C6                           541  
002AD4C6  B280                     542      cmp.l d0, d1            ; Are A & D both pressed or not pressed?
002AD4C8  6700 004A                543      beq.l .Return           ; If so, let's skip to the end.
002AD4CC                           544  
002AD4CC                           545  .TurnLeft:
002AD4CC  B0BC 00000000            546      cmp.l #0, d0
002AD4D2  6700 000E                547      beq.l .TurnRight
002AD4D6                           548  
002AD4D6  0482 00013880            549      sub.l #00080000, d2
002AD4DC                           550  
002AD4DC  4EF9 002AD4E8            551      jmp .FixAngle
002AD4E2                           552  
002AD4E2                           553  .TurnRight:
002AD4E2  0682 00013880            554      add.l #00080000, d2
002AD4E8                           555      
002AD4E8                           556  .FixAngle:
002AD4E8  B4BC 01680000            557      cmp.l #FP_360, d2       ; Is d2 greater than 360?
002AD4EE  6E00 0012                558      bgt.l .AngleOver
002AD4F2  B4BC 00000000            559      cmp.l #0, d2            ; Is d2 negative?
002AD4F8  6D00 0014                560      blt.l .AngleUnder
002AD4FC                           561  
002AD4FC  4EF9 002AD514            562      jmp .Return
002AD502                           563  
002AD502                           564  .AngleOver:
002AD502  0482 01680000            565      sub.l #FP_360, d2          
002AD508                           566  
002AD508  4EF9 002AD514            567      jmp .Return
002AD50E                           568  
002AD50E                           569  .AngleUnder:
002AD50E  0682 01680000            570      add.l #FP_360, d2
002AD514                           571  
002AD514                           572  .Return
002AD514  4CDF 0703                573      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
002AD518                           574  
002AD518  4E75                     575      rts
002AD51A                           576  
002AD51A                           577  ph_SelectShipRotation:
002AD51A  48E7 C0E0                578      movem.l TRAP_REG, -(sp)  *| Push registers to stack
002AD51E                           579  
002AD51E  2002                     580      move.l d2, d0   ; Take angle to temporary variable
002AD520  7200                     581      move.l #0, d1   ; d1 stores ship index
002AD522  0480 000B4000            582      sub.l #FP_11P25, d0 ; Subtract angle by 11.25
002AD528                           583  
002AD528                           584  .NextRot:
002AD528  5281                     585      add.l #1, d1        
002AD52A                           586  
002AD52A  0480 00168000            587      sub.l #FP_22P5, d0  ; Subtract angle by 11.25
002AD530  B0BC 00000000            588      cmp.l #0, d0        ; Is angle under 0?
002AD536  6C00 FFF0                589      bge.l .NextRot      ; If not, get next rotation
002AD53A                           590  
002AD53A                           591      ; We de-increment by 1 to go back to the desired index
002AD53A  5381                     592      sub.l #1, d1
002AD53C                           593  
002AD53C  B2BC 00000010            594      cmp.l #16, d1       ; Is d1 greater than 15?
002AD542  6D00 0004                595      blt.l .GetFile      ; If not, we ignore the next step
002AD546                           596  
002AD546  7200                     597      move.l #0, d1       ; If we went past 15, we reset back to the first index
002AD548                           598  
002AD548                           599  .GetFile:
002AD548  C2FC 0404                600      mulu.w #1028, d1     ; Multiply by size of ship's pixel grid
002AD54C  0681 002A904A            601      add.l #pg_ShipRotations, d1
002AD552  2641                     602      move.l d1, a3
002AD554                           603  
002AD554                           604  .Return
002AD554  4CDF 0703                605      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
002AD558                           606  
002AD558  4E75                     607      rts
002AD55A                           608  
002AD55A                           609  ph_CalcVelMagnitude:
002AD55A  48E7 C0E0                610      movem.l TRAP_REG, -(sp)  *| Push registers to stack
002AD55E                           611  
002AD55E  2003                     612      move.l d3, d0           ; Copying WASD inputs to extract A & D
002AD560  2200                     613      move.l d0, d1
002AD562                           614  
002AD562  E088                     615      lsr.l #8, d0            ; W key input
002AD564  E088                     616      lsr.l #8, d0
002AD566  E088                     617      lsr.l #8, d0
002AD568                           618  
002AD568  E089                     619      lsr.l #8, d1            ; S key input
002AD56A  C2BC 000000FF            620      and.l #$000000FF, d1    
002AD570                           621  
002AD570  B280                     622      cmp.l d0, d1            ; Are S & S both pressed or not pressed?
002AD572  6700 0046                623      beq.l .Fric             ; If so, let's apply friction.
002AD576                           624  
002AD576  B0BC 00000000            625      cmp.l #0, d0            ; Are we accelerating?
002AD57C  6700 000E                626      beq.l .Decel            ; If not, then we must be decelerating. 
002AD580                           627  
002AD580                           628  .Accel: ; Move forwards
002AD580  0687 00000100            629      add.l #ACCEL_AMOUNT, d7 
002AD586                           630  
002AD586                           631      ; if boosting, add more?
002AD586                           632  
002AD586  4EF9 002AD592            633      jmp .Clamp
002AD58C                           634  
002AD58C                           635  .Decel: ; Move backwards
002AD58C  0487 00000100            636      sub.l #DECEL_AMOUNT, d7 
002AD592                           637  
002AD592                           638  .Clamp:
002AD592                           639  .ClampMin:
002AD592  BEBC 00000000            640      cmp.l #0, d7    
002AD598  6C00 000A                641      bge.l .ClampMax
002AD59C                           642  
002AD59C  7E00                     643      move.l #0, d7
002AD59E                           644  
002AD59E  4EF9 002AD5BA            645      jmp .Return
002AD5A4                           646  
002AD5A4                           647  .ClampMax:
002AD5A4  BEBC 00001000            648      cmp.l #MAX_SPEED, d7
002AD5AA  6F00 000E                649      ble.l .Return
002AD5AE                           650  
002AD5AE  2E3C 00001000            651      move.l #MAX_SPEED, d7
002AD5B4                           652  
002AD5B4  4EF9 002AD5BA            653      jmp .Return
002AD5BA                           654  
002AD5BA                           655  .Fric:  ; Return to 0 over time while not boosting
002AD5BA                           656      ; asl.l #1, d7
002AD5BA                           657      ; cmp.l #$FFFFFFFF, d7    ; Is d7 at its lowest possible value?
002AD5BA                           658      ; bne.l .Return           ; If not, skip this next step
002AD5BA                           659  
002AD5BA                           660      ; move.l #0, d7           ; Return to 0 rather than being stuck at almost -0
002AD5BA                           661  
002AD5BA                           662  .Return:
002AD5BA  4CDF 0703                663      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
002AD5BE                           664  
002AD5BE  4E75                     665      rts
002AD5C0                           666  
002AD5C0                           667  ph_CalcVelDir:
002AD5C0  48E7 C0E0                668      movem.l TRAP_REG, -(sp)  *| Push registers to stack
002AD5C4                           669  
002AD5C4  2002                     670      move.l d2, d0           ; Move angle to register for processing
002AD5C6  E088                     671      lsr.l #8, d0
002AD5C8  E088                     672      lsr.l #8, d0
002AD5CA  80FC 0168                673      divu.w #360, d0         ; Modulo to keep within 360 degrees
002AD5CE  C0BC FFFF0000            674      and.l #$FFFF0000, d0
002AD5D4                           675      
002AD5D4  4EB9 002AD70C            676      jsr ph_Sine             ; sin
002AD5DA                           677  
002AD5DA                           678      ; We're done with WASD inputs so we can now use d3 for operations
002AD5DA  2600                     679      move.l d0, d3           ; Storing sin(theta)
002AD5DC  2002                     680      move.l d2, d0           ; Move angle to d0 again    
002AD5DE  0680 005A0000            681      add.l #$005A0000, d0    ; Add pi / 2 to get cosine
002AD5E4  E088                     682      lsr.l #8, d0
002AD5E6  E088                     683      lsr.l #8, d0
002AD5E8  80FC 0168                684      divu.w #360, d0         ; Modulo to keep within 360 degrees
002AD5EC  C0BC FFFF0000            685      and.l #$FFFF0000, d0
002AD5F2                           686  
002AD5F2  4EB9 002AD70C            687      jsr ph_Sine             ;cos
002AD5F8                           688  
002AD5F8                           689      ; Now d3 holds sin(theta) and d0 holds cos(theta)
002AD5F8                           690  
002AD5F8                           691      ; Multiply velocity magnitude by x component
002AD5F8  2C07                     692      move.l d7, d6
002AD5FA  E08E                     693      lsr.l #8, d6
002AD5FC  CCBC 0000FFFF            694      and.l #$0000FFFF, d6
002AD602                           695  
002AD602  CDC3                     696      muls.w d3, d6   ; d6 now holds 8.8 x component
002AD604  E08E                     697      lsr.l #8, d6
002AD606  CCBC 0000FFFF            698      and.l #$0000FFFF, d6 ; Reduce to 4.4
002AD60C  2606                     699      move.l d6, d3   ; Store x component in d3
002AD60E  E18B                     700      lsl.l #8, d3
002AD610  E18B                     701      lsl.l #8, d3    ; Move over to left side for eventual merge
002AD612                           702  
002AD612                           703      ; Multiply velocity magnitude by y component    
002AD612  2C07                     704      move.l d7, d6
002AD614  E08E                     705      lsr.l #8, d6
002AD616  CCBC 0000FFFF            706      and.l #$0000FFFF, d6
002AD61C                           707      
002AD61C  CDC0                     708      muls.w d0, d6   ; d5 now holds 8.8 y component
002AD61E  E08E                     709      lsr.l #8, d6
002AD620  CCBC 0000FFFF            710      and.l #$0000FFFF, d6 ; Reduce to 4x4
002AD626  2006                     711      move.l d6, d0   ; Store y component in d0
002AD628                           712      
002AD628  8083                     713      or.l d3, d0 ; Merge x and y to form final vector
002AD62A                           714  
002AD62A  2C00                     715      move.l d0, d6   ; Move final result to final location for processing
002AD62C                           716  
002AD62C                           717  .Return:
002AD62C  4CDF 0703                718      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
002AD630                           719  
002AD630  4E75                     720      rts
002AD632                           721  
002AD632                           722  ph_CalculatePosition:
002AD632  48E7 C0E0                723      movem.l TRAP_REG, -(sp)  *| Push registers to stack
002AD636                           724  
002AD636  2006                     725      move.l d6, d0
002AD638  2200                     726      move.l d0, d1
002AD63A                           727  
002AD63A  E088                     728      lsr.l #8, d0
002AD63C  E088                     729      lsr.l #8, d0
002AD63E  C2BC 0000FFFF            730      and.l #$0000FFFF, d1
002AD644                           731  
002AD644                           732  .negX:
002AD644  B07C 0000                733      cmp.w #0, d0    ; Is d0 less than zero?
002AD648  6C00 000E                734      bge.l .posX 
002AD64C                           735  
002AD64C  4440                     736      neg.w d0
002AD64E                           737  
002AD64E                           738      ; If so, let's transform to 16.16 
002AD64E  E188                     739      lsl.l #8, d0
002AD650  4480                     740      neg.l d0
002AD652                           741  
002AD652  4EF9 002AD65A            742      jmp .negY
002AD658                           743  
002AD658                           744  .posX:
002AD658  E188                     745      lsl.l #8, d0
002AD65A                           746  
002AD65A                           747  .negY:
002AD65A  B07C 0000                748      cmp.w #0, d0    ; Is d0 less than zero?
002AD65E  6C00 000E                749      bge.l .posY
002AD662                           750  
002AD662  4441                     751      neg.w d1
002AD664                           752  
002AD664                           753      ; If so, let's transform to 16.16 
002AD664  E189                     754      lsl.l #8, d1
002AD666  4481                     755      neg.l d1
002AD668                           756  
002AD668  4EF9 002AD670            757      jmp .updatePos
002AD66E                           758  
002AD66E                           759  .posY:
002AD66E  E189                     760      lsl.l #8, d1
002AD670                           761  
002AD670                           762  .updatePos:
002AD670                           763      ; Update precise ship position
002AD670  287C 002AD850            764      move.l #ShipPosition, a4
002AD676                           765  
002AD676  D094                     766      add.l (a4), d0  ; Ship X Position 
002AD678  588C                     767      add.l #4, a4
002AD67A  D294                     768      add.l (a4), d1  ; Ship Y Position
002AD67C                           769  
002AD67C  2881                     770      move.l d1, (a4)
002AD67E  598C                     771      sub.l #4, a4
002AD680  2880                     772      move.l d0, (a4)
002AD682                           773  
002AD682                           774      ; Now, update integer ship position (pixel)
002AD682                           775  
002AD682  C0BC FFFF0000            776      and.l #$FFFF0000, d0    ; X is already in position
002AD688  E089                     777      lsr.l #8, d1            ; Y is shifted right, for once.
002AD68A  E089                     778      lsr.l #8, d1
002AD68C                           779  
002AD68C  8280                     780      or.l d0, d1
002AD68E                           781  
002AD68E  2A01                     782      move.l d1, d5
002AD690                           783  
002AD690                           784  .Return:
002AD690  4CDF 0703                785      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
002AD694                           786  
002AD694  4E75                     787      rts
002AD696                           788  
002AD696                           789  ph_ClampNumber:
002AD696  2F02                     790      move.l d2, -(sp) ; Temporarily move d2 out of the way
002AD698                           791  
002AD698  2401                     792      move.l d1, d2
002AD69A  E089                     793      lsr.l #8, d1
002AD69C  E089                     794      lsr.l #8, d1
002AD69E  C4BC 0000FFFF            795      and.l #$0000FFFF, d2
002AD6A4                           796  
002AD6A4                           797      *| Compare by word here because it is signed 
002AD6A4  B041                     798      cmp.w d1, d0    ; Is value less than min?
002AD6A6  6D00 000E                799      blt .Under    
002AD6AA                           800      
002AD6AA  B042                     801      cmp.w d2, d0    ; Is value greater than max?
002AD6AC  6E00 0010                802      bgt.l .Over
002AD6B0                           803  
002AD6B0  4EF9 002AD6C6            804      jmp .Return     ; Within range, do nothing
002AD6B6                           805  
002AD6B6                           806  .Under:     ; We need to clamp value to min
002AD6B6  2001                     807      move.l d1, d0
002AD6B8                           808  
002AD6B8  4EF9 002AD6C6            809      jmp .Return
002AD6BE                           810  
002AD6BE                           811  .Over:      ; We need to clamp value to max
002AD6BE  2002                     812      move.l d2, d0
002AD6C0                           813  
002AD6C0  4EF9 002AD6C6            814      jmp .Return
002AD6C6                           815  
002AD6C6                           816  .Return:
002AD6C6  241F                     817      move.l (sp)+, d2
002AD6C8                           818  
002AD6C8  4E75                     819      rts
002AD6CA                           820  
002AD6CA                           821  ph_ClampVector:
002AD6CA  2F02                     822      move.l d2, -(sp)    ; Temporarily move d2 out of the way
002AD6CC  2F03                     823      move.l d3, -(sp)    ; Temporarily move d3 out of the way
002AD6CE                           824  
002AD6CE  2401                     825      move.l d1, d2       ; Extract X & Y value of vector
002AD6D0  2602                     826      move.l d2, d3
002AD6D2  E08A                     827      lsr.l #8, d2
002AD6D4  E08A                     828      lsr.l #8, d2
002AD6D6  C6BC 0000FFFF            829      and.l #$0000FFFF, d3
002AD6DC                           830  
002AD6DC  C5C2                     831      muls.w d2, d2   ; x ^ 2
002AD6DE  C7C3                     832      muls.w d3, d3   ; y ^ 2
002AD6E0  D682                     833      add.l d2, d3    ; x ^ 2 + y ^ 2 = c ^ 2
002AD6E2                           834  
002AD6E2                           835      ; (x ^ 2) + (y ^ 2) must be converted from 16.16 to 8.8
002AD6E2  E08B                     836      lsr.l #8, d3
002AD6E4  C6BC 0000FFFF            837      and.l #$0000FFFF, d3
002AD6EA                           838  
002AD6EA  B680                     839      cmp.l d0, d3    ; Is magnitude greater than max?
002AD6EC  6F00 0018                840      ble.l .Return   ; If not, carry on as usual
002AD6F0                           841  
002AD6F0                           842      ; If so, let's CUT IT IN HALF muahahaha
002AD6F0  2401                     843      move.l d1, d2
002AD6F2                           844  
002AD6F2  E08A                     845      lsr.l #8, d2
002AD6F4  E08A                     846      lsr.l #8, d2
002AD6F6  C2BC 0000FFFF            847      and.l #$0000FFFF, d1
002AD6FC                           848      
002AD6FC  E242                     849      asr.w #1, d2            ; X
002AD6FE  E241                     850      asr.w #1, d1            ; Y
002AD700                           851      
002AD700  E18A                     852      lsl.l #8, d2
002AD702  E18A                     853      lsl.l #8, d2
002AD704                           854  
002AD704  8282                     855      or.l d2, d1
002AD706                           856  
002AD706                           857  .Return:
002AD706  261F                     858      move.l (sp)+, d3
002AD708  241F                     859      move.l (sp)+, d2
002AD70A                           860  
002AD70A  4E75                     861      rts
002AD70C                           862  
002AD70C                           863  ph_Sine:
002AD70C  E088                     864      lsr.l #8, d0
002AD70E  E088                     865      lsr.l #8, d0        ; Chopping off fractional
002AD710                           866  
002AD710  B0BC 0000005A            867      cmp.l #90, d0       ; Is the angle greater than 90?
002AD716  6D00 001C                868      blt.l .Q1           ; If not, we're in quadrant 1
002AD71A                           869      
002AD71A  B0BC 000000B4            870      cmp.l #180, d0      ; Is the angle greater than 180?
002AD720  6D00 0024                871      blt.l .Q2           ; If not, we're in quadrant 2
002AD724                           872  
002AD724  B0BC 0000010E            873      cmp.l #270, d0      ; Is the angle greater than 270?
002AD72A  6D00 0038                874      blt.l .Q3           ; If not, we're in quadrant 3
002AD72E                           875      
002AD72E  4EF9 002AD77E            876      jmp .Q4             ; We are in quadrant 4 by process of elimination
002AD734                           877  
002AD734                           878  .Q1:    ; Quadrant 1
002AD734  E388                     879      lsl.l #1, d0        ; Multiply by 2 (length of word)
002AD736                           880  
002AD736  207C 002AD79A            881      move.l #sinTable, a0
002AD73C  D1C0                     882      add.l d0, a0        ; Offset to desired index of sin table
002AD73E                           883  
002AD73E  3010                     884      move.w (a0), d0     ; Extract fractional
002AD740                           885  
002AD740  4EF9 002AD798            886      jmp .Return
002AD746                           887  
002AD746                           888  .Q2:    ; Quadrant 2
002AD746  0480 0000005A            889      sub.l #90, d0       ; Start at 90 degrees
002AD74C  E388                     890      lsl.l #1, d0        ; Multiply by 2 (length of word)
002AD74E                           891  
002AD74E  207C 002AD79A            892      move.l #sinTable, a0
002AD754  D1FC 000000B4            893      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
002AD75A  91C0                     894      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
002AD75C                           895  
002AD75C  3010                     896      move.w (a0), d0     ; Extract fractional
002AD75E                           897  
002AD75E  4EF9 002AD798            898      jmp .Return
002AD764                           899  
002AD764                           900  .Q3:    ; Quadrant 3
002AD764  0480 000000B4            901      sub.l #180, d0       ; Start at 180 degrees
002AD76A  E388                     902      lsl.l #1, d0        ; Multiply by 2 (length of word)
002AD76C                           903  
002AD76C  207C 002AD79A            904      move.l #sinTable, a0
002AD772  D1C0                     905      add.l d0, a0        ; Offset to desired index of sin table
002AD774                           906  
002AD774  3010                     907      move.w (a0), d0     ; Extract fractional
002AD776  4440                     908      neg.w d0            ; Flip to negative
002AD778                           909  
002AD778  4EF9 002AD798            910      jmp .Return
002AD77E                           911  
002AD77E                           912  .Q4:    ; Quadrant 4
002AD77E  0480 0000010E            913      sub.l #270, d0       ; Start at 90 degrees
002AD784  E388                     914      lsl.l #1, d0         ; Multiply by 2 (length of word)
002AD786                           915  
002AD786  207C 002AD79A            916      move.l #sinTable, a0
002AD78C  D1FC 000000B4            917      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
002AD792  91C0                     918      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
002AD794                           919  
002AD794  3010                     920      move.w (a0), d0     ; Extract fractional
002AD796                           921  
002AD796  4440                     922      neg.w d0            ; Flip to negative
002AD798                           923  
002AD798                           924  .Return:
002AD798                           925  
002AD798  4E75                     926      rts
002AD79A                           927  
002AD79A= 0000 0047 008E 0...      928  sinTable        dc.w    $0,$47,$8E,$D6,$11D,$164,$1AC,$1F3,$23A,$280,$2C7
002AD7B0= 030D 0353 0399 0...      929                  dc.w    $30D,$353,$399,$3DE,$424,$469,$4AD,$4F1,$535
002AD7C2= 0578 05BB 05FE 0...      930                  dc.w    $578,$5BB,$5FE,$640,$681,$6C3,$703,$743,$782
002AD7D4= 07C1 07FF 083D 0...      931                  dc.w    $7C1,$7FF,$83D,$87A,$8B6,$8F2,$92D,$967,$9A1
002AD7E6= 09D9 0A11 0A48 0...      932                  dc.w    $9D9,$A11,$A48,$A7F,$AB4,$AE9,$B1D,$B50,$B82
002AD7F8= 0BB3 0BE3 0C13 0...      933                  dc.w    $BB3,$BE3,$C13,$C41,$C6F,$C9B,$CC7,$CF1,$D1B
002AD80A= 0D43 0D6B 0D91 0...      934                  dc.w    $D43,$D6B,$D91,$DB6,$DDB,$DFE,$E20,$E41,$E61
002AD81C= 0E80 0E9D 0EBA 0...      935                  dc.w    $E80,$E9D,$EBA,$ED5,$EEF,$F08,$F20,$F37,$F4D
002AD82E= 0F61 0F74 0F86 0...      936                  dc.w    $F61,$F74,$F86,$F97,$FA6,$FB4,$FC1,$FCD,$FD8
002AD840= 0FE1 0FE9 0FF0 0...      937                  dc.w    $FE1,$FE9,$FF0,$FF6,$FFA,$FFD,$FFF,$FFF
002AD850                           938  
002AD850  =000000B4                939  SINTABLESIZE            EQU 180 ; 90 * 2 (word size)
002AD850                           940  
002AD850= 02210000 012C0000        941  ShipPosition        dc.l $02210000,$012C0000  ; Position in 16.16 fixed point
002AD858                           942  
002AD858                           943  -------------------- end include --------------------
002AD858                           944      INCLUDE "./display.x68"       ; Displays a 7-segment LED with the given parameters.
002AD858                           945  
002AD858  =0012001F                946  SEVEN_SEG_DIMENSIONS    EQU $0012001F
002AD858                           947  
002AD858  =02540014                948  LAP_DISPLAY_OFFSET          EQU $02540014
002AD858                           949  
002AD858  =00050014                950  TIMER_1_DISPLAY_OFFSET      EQU $00050014
002AD858  =001A0014                951  TIMER_2_DISPLAY_OFFSET      EQU $001A0014
002AD858  =00370014                952  TIMER_3_DISPLAY_OFFSET      EQU $00370014
002AD858  =004C0014                953  TIMER_4_DISPLAY_OFFSET      EQU $004C0014
002AD858                           954  
002AD858                           955  ss_InitDisplays:
002AD858  48E7 FFFE                956      movem.l ALL_REG, -(sp) *| Push registers to stack
002AD85C                           957  
002AD85C                           958      *| Setting up lap counter
002AD85C  207C 002ADC54            959      move.l #ssd_Lap, a0
002AD862  20BC 02540014            960      move.l #LAP_DISPLAY_OFFSET, (a0)
002AD868  7001                     961      move.l #1, d0
002AD86A                           962  
002AD86A  4EB9 002AD8BC            963      jsr ss_SevenSegUpdate
002AD870                           964  
002AD870                           965      *| Setting up timer counters, from leftmost to rightmost
002AD870  207C 002ADC5C            966      move.l #ssd_Timer, a0
002AD876  20BC 00050014            967      move.l #TIMER_1_DISPLAY_OFFSET, (a0)
002AD87C  5C88                     968      add.l #6, a0
002AD87E  30BC 0001                969      move.w #1, (a0)     ; Lap counter starts at 1
002AD882  5D88                     970      sub.l #6, a0
002AD884                           971  
002AD884  4EB9 002AD8BC            972      jsr ss_SevenSegUpdate
002AD88A                           973  
002AD88A  5088                     974      add.l #8, a0    ; Move a0 to next display in timer
002AD88C  7000                     975      move.l #0, d0   ; Timer displays all start at 0
002AD88E                           976  
002AD88E  20BC 001A0014            977      move.l #TIMER_2_DISPLAY_OFFSET, (a0)
002AD894                           978  
002AD894  4EB9 002AD8BC            979      jsr ss_SevenSegUpdate
002AD89A                           980          
002AD89A  5088                     981      add.l #8, a0    ; Move a0 to next display in timer
002AD89C                           982  
002AD89C  20BC 00370014            983      move.l #TIMER_3_DISPLAY_OFFSET, (a0)
002AD8A2                           984  
002AD8A2  4EB9 002AD8BC            985      jsr ss_SevenSegUpdate
002AD8A8                           986  
002AD8A8  5088                     987      add.l #8, a0    ; Move a0 to next display in timer
002AD8AA                           988  
002AD8AA  20BC 004C0014            989      move.l #TIMER_4_DISPLAY_OFFSET, (a0)
002AD8B0                           990  
002AD8B0  4EB9 002AD8BC            991      jsr ss_SevenSegUpdate
002AD8B6                           992  .Return:
002AD8B6  4CDF 7FFF                993      movem.l (sp)+, ALL_REG  *| Pull registers from stack
002AD8BA                           994  
002AD8BA  4E75                     995      rts
002AD8BC                           996  
002AD8BC                           997  ss_SevenSegUpdate:
002AD8BC  48E7 FFFE                998      movem.l ALL_REG, -(sp) *| Push registers to stack
002AD8C0                           999  
002AD8C0                          1000      ; Get table value
002AD8C0  227C 002ADC4A           1001      move.l #SevenSegTable, a1
002AD8C6  D3C0                    1002      add.l d0, a1            ; Offset to bitmask
002AD8C8  1411                    1003      move.b (a1), d2
002AD8CA                          1004  
002AD8CA                          1005      ; Update bitmask
002AD8CA  2248                    1006      move.l a0, a1
002AD8CC  5889                    1007      add.l #4, a1            ; Move to next long
002AD8CE  3282                    1008      move.w d2, (a1)         ; Move by word to prevent misalignment
002AD8D0  5489                    1009      add.l #2, a1            ; Move to next word
002AD8D2  3280                    1010      move.w d0, (a1)         ; Put the actual number in for reference
002AD8D4                          1011  
002AD8D4                          1012      ; Wipe other old sprites because sprite clearing only works one image at a time (needs fixing!)
002AD8D4  4EB9 0017CF0A           1013      jsr r_ClearSprites
002AD8DA                          1014  
002AD8DA                          1015      ; Mark new clear zone
002AD8DA  2610                    1016      move.l (a0), d3
002AD8DC                          1017      
002AD8DC  2279 0017D042           1018      move.l pixel_clear_length, a1
002AD8E2  2283                    1019      move.l d3, (a1)                     ; Move image offset to pixel_clear_zones
002AD8E4  5889                    1020      add.l #4, a1                        ; Move to next word
002AD8E6  22BC 0012001F           1021      move.l #SEVEN_SEG_DIMENSIONS, (a1)  ; Move image dimensions to pixel_clear_zones
002AD8EC  50B9 0017D042           1022      add.l #8, pixel_clear_length        ; Move to next word
002AD8F2                          1023  
002AD8F2                          1024      ; Call an early sprite clear
002AD8F2  4EB9 0017CF0A           1025      jsr r_ClearSprites
002AD8F8                          1026  
002AD8F8                          1027      ; Print new display value
002AD8F8                          1028      *| Note: A lot of this is necessary boilerplate, 
002AD8F8                          1029      *| but also consistent across all 7-seg displays.
002AD8F8                          1030  .PrintSegments:
002AD8F8  283C 00000080           1031      move.l #%10000000, d4   ; Starting bit to check
002AD8FE  7200                    1032      move.l #0, d1           ; Are not immediately removed
002AD900                          1033  .First:
002AD900  2002                    1034      move.l d2, d0
002AD902  C084                    1035      and.l d4, d0
002AD904  B084                    1036      cmp.l d4, d0
002AD906  6600 0016               1037      bne.l .Second           ; Skip to second
002AD90A                          1038      
002AD90A  2003                    1039      move.l d3, d0
002AD90C  0680 00030000           1040      add.l #$00030000, d0    ; + Local Position
002AD912  207C 002ADD80           1041      move.l #pg_7SegHorizontal, a0
002AD918  4EB9 0017CE82           1042      jsr r_PrintImage
002AD91E                          1043  
002AD91E                          1044  .Second:    
002AD91E  E28C                    1045      lsr.l #1, d4            ; Get next bit to check
002AD920  2002                    1046      move.l d2, d0
002AD922  C084                    1047      and.l d4, d0
002AD924  B084                    1048      cmp.l d4, d0 
002AD926  6600 0012               1049      bne.l .Third            ; Skip to third
002AD92A                          1050         
002AD92A  2003                    1051      move.l d3, d0
002AD92C  5680                    1052      add.l #$00000003, d0    ; + Local Position
002AD92E  207C 002ADC7C           1053      move.l #pg_7SegVertical, a0
002AD934  4EB9 0017CE82           1054      jsr r_PrintImage
002AD93A                          1055  
002AD93A                          1056  .Third:
002AD93A  E28C                    1057      lsr.l #1, d4            ; Get next bit to check
002AD93C  2002                    1058      move.l d2, d0
002AD93E  C084                    1059      and.l d4, d0
002AD940  B084                    1060      cmp.l d4, d0 
002AD942  6600 0016               1061      bne.l .Fourth           ; Skip to fourth
002AD946                          1062  
002AD946  2003                    1063      move.l d3, d0
002AD948  0680 000F0003           1064      add.l #$000F0003, d0    ; + Local Position
002AD94E  207C 002ADC7C           1065      move.l #pg_7SegVertical, a0
002AD954  4EB9 0017CE82           1066      jsr r_PrintImage
002AD95A                          1067  
002AD95A                          1068  .Fourth:
002AD95A  E28C                    1069      lsr.l #1, d4            ; Get next bit to check
002AD95C  2002                    1070      move.l d2, d0
002AD95E  C084                    1071      and.l d4, d0
002AD960  B084                    1072      cmp.l d4, d0 
002AD962  6600 0016               1073      bne.l .Fifth            ; Skip to fifth
002AD966                          1074  
002AD966  2003                    1075      move.l d3, d0
002AD968  0680 0003000E           1076      add.l #$0003000E, d0    ; + Local Position
002AD96E  207C 002ADD80           1077      move.l #pg_7SegHorizontal, a0
002AD974  4EB9 0017CE82           1078      jsr r_PrintImage
002AD97A                          1079  
002AD97A                          1080  .Fifth:
002AD97A  E28C                    1081      lsr.l #1, d4            ; Get next bit to check
002AD97C  2002                    1082      move.l d2, d0
002AD97E  C084                    1083      and.l d4, d0
002AD980  B084                    1084      cmp.l d4, d0 
002AD982  6600 0016               1085      bne.l .Sixth            ; Skip to sixth
002AD986                          1086  
002AD986  2003                    1087      move.l d3, d0
002AD988  0680 00000010           1088      add.l #$00000010, d0    ; + Local Position
002AD98E  207C 002ADC7C           1089      move.l #pg_7SegVertical, a0
002AD994  4EB9 0017CE82           1090      jsr r_PrintImage
002AD99A                          1091  
002AD99A                          1092  .Sixth:
002AD99A  E28C                    1093      lsr.l #1, d4            ; Get next bit to check
002AD99C  2002                    1094      move.l d2, d0
002AD99E  C084                    1095      and.l d4, d0
002AD9A0  B084                    1096      cmp.l d4, d0 
002AD9A2  6600 0016               1097      bne.l .Seventh          ; Skip to seventh
002AD9A6                          1098  
002AD9A6  2003                    1099      move.l d3, d0
002AD9A8  0680 000F0010           1100      add.l #$000F0010, d0    ; + Local Position
002AD9AE  207C 002ADC7C           1101      move.l #pg_7SegVertical, a0
002AD9B4  4EB9 0017CE82           1102      jsr r_PrintImage
002AD9BA                          1103  
002AD9BA                          1104  .Seventh:
002AD9BA  E28C                    1105      lsr.l #1, d4
002AD9BC  2002                    1106      move.l d2, d0
002AD9BE  C084                    1107      and.l d4, d0
002AD9C0  B084                    1108      cmp.l d4, d0 
002AD9C2  6600 0016               1109      bne.l .Return           ; Skip to end
002AD9C6                          1110  
002AD9C6  2003                    1111      move.l d3, d0
002AD9C8  0680 0003001C           1112      add.l #$0003001C, d0    ; + Local Position
002AD9CE  207C 002ADD80           1113      move.l #pg_7SegHorizontal, a0
002AD9D4  4EB9 0017CE82           1114      jsr r_PrintImage
002AD9DA                          1115  
002AD9DA                          1116  .Return:
002AD9DA  4CDF 7FFF               1117      movem.l (sp)+, ALL_REG  *| Pull registers from stack
002AD9DE                          1118  
002AD9DE  4E75                    1119      rts
002AD9E0                          1120  
002AD9E0                          1121  ss_IncrementLap:
002AD9E0  48E7 C0E0               1122      movem.l TRAP_REG, -(sp) *| Push registers to stack
002AD9E4                          1123  
002AD9E4  207C 002ADC54           1124      move.l #ssd_Lap, a0
002AD9EA  5C88                    1125      add.l #6, a0            ; Offset to actual number
002AD9EC  3010                    1126      move.w (a0), d0         ; Grab number
002AD9EE  5280                    1127      add.l #1, d0            ; Increment by 1
002AD9F0  B0BC 00000003           1128      cmp.l #3, d0            ; Has its number gone over 3?
002AD9F6  6E00 0010               1129      bgt.l .EndGame          ; If so, game over.
002AD9FA                          1130  
002AD9FA                          1131      ; Otherwise, let's increment and update
002AD9FA  5D88                    1132      sub.l #6, a0            ; offset to start of current display
002AD9FC  4EB9 002AD8BC           1133      jsr ss_SevenSegUpdate
002ADA02                          1134  
002ADA02  4EF9 002ADA10           1135      jmp .Return
002ADA08                          1136  
002ADA08                          1137  .EndGame:
002ADA08  33FC 0001 00002240      1138      move.w #1, flag_IsDead  ; Game is over!
002ADA10                          1139  
002ADA10                          1140  .Return:
002ADA10  4CDF 0703               1141      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
002ADA14                          1142      
002ADA14  4E75                    1143      rts
002ADA16                          1144  
002ADA16                          1145  SevenSegVerticalBmpFile     INCBIN "../resources/7SegVertical.bmp"
002ADB30                          1146  SevenSegHorizontalBmpFile   INCBIN "../resources/7SegHorizontal.bmp"
002ADC4A                          1147  
002ADC4A                          1148  ; A table containing bytes where each bit represents on or off
002ADC4A                          1149  ; for a segment on the display. Table starts at 0 and ends at 9
002ADC4A= EE 24 BA                1150  SevenSegTable       dc.b %11101110,%00100100,%10111010
002ADC4D= B6 74 D6                1151                      dc.b %10110110,%01110100,%11010110
002ADC50= DE A4 FE F4             1152                      dc.b %11011110,%10100100,%11111110,%11110100
002ADC54                          1153  
002ADC54                          1154  ssd_Lap         ds.l 2
002ADC5C                          1155  ssd_Timer       ds.l 8
002ADC7C                          1156  
002ADC7C                          1157  pg_7SegVertical     ds.l 65     ; 1 + 16x4
002ADD80                          1158  pg_7SegHorizontal   ds.l 65     ; 1 + 16x4
002ADD80                          1159  -------------------- end include --------------------
002ADE84                          1160      INCLUDE "./collider.x68"      ; Handles the materials the ship is currently on
002ADE84                          1161  
002ADE84                          1162  cl_CheckCollisions:
002ADE84                          1163      ; Check root of ship location
002ADE84  2005                    1164      move.l d5, d0
002ADE86  4EB9 002ADED0           1165      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
002ADE8C  4EB9 002ADEF4           1166      jsr cl_ProcessMaterial
002ADE92                          1167  
002ADE92                          1168      ; Check top right corner
002ADE92  2005                    1169      move.l d5, d0
002ADE94  0680 000F0000           1170      add.l #$000F0000, d0
002ADE9A  4EB9 002ADED0           1171      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
002ADEA0  4EB9 002ADEF4           1172      jsr cl_ProcessMaterial
002ADEA6                          1173  
002ADEA6                          1174      ; Check bottom left corner
002ADEA6  2005                    1175      move.l d5, d0
002ADEA8  0680 0000000F           1176      add.l #$0000000F, d0
002ADEAE  4EB9 002ADED0           1177      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
002ADEB4  4EB9 002ADEF4           1178      jsr cl_ProcessMaterial
002ADEBA                          1179  
002ADEBA                          1180      ; Check bottom right corner
002ADEBA  2005                    1181      move.l d5, d0
002ADEBC  0680 000F000F           1182      add.l #$000F000F, d0
002ADEC2  4EB9 002ADED0           1183      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
002ADEC8  4EB9 002ADEF4           1184      jsr cl_ProcessMaterial
002ADECE                          1185  
002ADECE                          1186  .Return:
002ADECE                          1187  
002ADECE  4E75                    1188      rts
002ADED0                          1189  
002ADED0                          1190  cl_GetCollisionMaterial:
002ADED0  2200                    1191      move.l d0, d1
002ADED2  E088                    1192      lsr.l #8, d0            ; X
002ADED4  E088                    1193      lsr.l #8, d0
002ADED6  C2BC 0000FFFF           1194      and.l #$0000FFFF, d1    ; Y
002ADEDC                          1195  
002ADEDC  C2FC 0280               1196      mulu.w #SCREEN_WIDTH, d1    ; Y * Screen Width
002ADEE0  D280                    1197      add.l d0, d1                ; + X = Index
002ADEE2                          1198  
002ADEE2  207C 002ADF6C           1199      move.l #cm_Road, a0
002ADEE8  D1C1                    1200      add.l d1, a0                ; Offset to material
002ADEEA                          1201  
002ADEEA  1010                    1202      move.b (a0), d0             ; Grab material
002ADEEC  C0BC 000000FF           1203      and.l #$000000FF, d0            ; Cut off leftmost bits
002ADEF2                          1204  
002ADEF2                          1205  .Return:
002ADEF2                          1206  
002ADEF2  4E75                    1207      rts
002ADEF4                          1208  
002ADEF4                          1209  cl_ProcessMaterial:
002ADEF4                          1210  .Offroad:
002ADEF4  B0BC 00000000           1211      cmp.l #0, d0    ; Offroad?
002ADEFA  6600 0010               1212      bne.l .Lap
002ADEFE                          1213  
002ADEFE  33FC 0001 00002240      1214      move.w #1, flag_IsDead  ; You're dead!
002ADF06  4EF9 002ADF6A           1215      jmp .Return
002ADF0C                          1216  
002ADF0C                          1217  .Lap:
002ADF0C  B0BC 00000002           1218      cmp.l #2, d0    ; On the lap?
002ADF12  6600 0028               1219      bne.l .MidLap
002ADF16                          1220  
002ADF16  0C79 0000 00002244      1221      cmp.w #0, flag_CanLap   ; Are we in a valid lap state?
002ADF1E  6700 004A               1222      beq.l .Return           ; If not, invalid
002ADF22                          1223  
002ADF22  4EB9 002AD9E0           1224      jsr ss_IncrementLap
002ADF28  33FC 0000 00002244      1225      move.w #0, flag_CanLap  ; CanLap = false
002ADF30                          1226  
002ADF30  4EB9 00002122           1227      jsr pwr_SpawnPowerup    ; New powerup
002ADF36                          1228  
002ADF36  4EF9 002ADF6A           1229      jmp .Return
002ADF3C                          1230  
002ADF3C                          1231  .MidLap:
002ADF3C  B0BC 00000003           1232      cmp.l #3, d0    ; On the mid-lap?
002ADF42  6600 0016               1233      bne.l .Powerup
002ADF46                          1234  
002ADF46  0C79 0000 00002244      1235      cmp.w #0, flag_CanLap   ; Are we in a valid lap state?
002ADF4E  6600 001A               1236      bne.l .Return           ; If not, invalid
002ADF52                          1237  
002ADF52  33FC 0001 00002244      1238      move.w #1, flag_CanLap  ; CanLap = true
002ADF5A                          1239  
002ADF5A                          1240  .Powerup:
002ADF5A  B0BC 00000003           1241      cmp.l #3, d0    ; On powerup?
002ADF60  6600 0008               1242      bne.l .Return   ; End of custom materials
002ADF64                          1243  
002ADF64  4EB9 0000222A           1244      jsr pwr_FuelUp
002ADF6A                          1245  
002ADF6A                          1246  .Return:
002ADF6A                          1247      ; No special state for any other material
002ADF6A                          1248  
002ADF6A  4E75                    1249      rts
002ADF6C                          1250  
002ADF6C                          1251  cm_Road         ds.b 307200 ; 640 x 480
002ADF6C                          1252  -------------------- end include --------------------
002F8F6C                          1253  
002F8F6C                          1254  *,__________________________________________________,
002F8F6C                          1255  *| fn Main
002F8F6C                          1256  *| Description: Loads files, sets game state, begins
002F8F6C                          1257  *|              game loop, and handles quit state
00002000                          1258  START ORG $2000
00002000                          1259  Main:
00002000                          1260      ; Initialize pixel_clear_length
00002000  23FC 0017CFA2 0017D042  1261      move.l #pixel_clear_zones, pixel_clear_length
0000200A                          1262  
0000200A  705C                    1263      move.l #92, d0
0000200C  7211                    1264      move.l #17, d1
0000200E                          1265      
0000200E  4E4F                    1266      TRAP #15
00002010                          1267  
00002010  4EB8 1000               1268      jsr fl_LoadFiles
00002014                          1269      
00002014  7000                    1270      move.l #$00000000, d0   ; Position has no offset
00002016  7200                    1271      move.l #$00000000, d1   ; This is not a sprite, it's the background
00002018  7400                    1272      move.l #$00000000, d2
0000201A  207C 0017D046           1273      move.l #pg_Background, a0
00002020  4EB9 0017CE82           1274      jsr r_PrintImage
00002026                          1275      
00002026  4EB9 002AD858           1276      jsr ss_InitDisplays
0000202C                          1277      
0000202C                          1278      ; Set up start variables for game loop
0000202C  2A3C 0221012C           1279      move.l #$0221012C, d5   ; Start position of ship
00002032                          1280  
00002032  7008                    1281      move.l #GET_TIME, d0    ; Get current time (start of game time)
00002034  4E4F                    1282      TRAP #15
00002036                          1283  
00002036  23C1 0000223C           1284      move.l d1, LastSecond    ; This time is the start of the game
0000203C                          1285  
0000203C  4EB9 00002046           1286      jsr GameLoop
00002042                          1287  
00002042  4E72 3000               1288      STOP #$3000
00002046                          1289  *| [End of Function] Main
00002046                          1290  *|__________________________________________________
00002046                          1291  *`                                                  `
00002046                          1292  
00002046                          1293  *,__________________________________________________,
00002046                          1294  *| fn GameLoop
00002046                          1295  *| Description: Perpetually runs game until the quit 
00002046                          1296  *| command is given.
00002046                          1297  *| Persistent Variables:
00002046                          1298  *| d2: Rotation, DeltaTime 
00002046                          1299  *| d3: WASD Inputs, d4: Enter, Esc, Shift, and Space Inputs
00002046                          1300  *| d5: Position, d6: Velocity, d7: Acceleration
00002046                          1301  *| a3: Ship model to use
00002046                          1302  GameLoop:
00002046  7008                    1303      move.l #8, d0  ; Time Code - maybe reuse later?
00002048                          1304  
00002048  4E4F                    1305      TRAP #15
0000204A                          1306  
0000204A  4EB9 000020CA           1307      jsr UpdateTimer         ; Updates the in-game timer if a second has passed
00002050                          1308  
00002050  2001                    1309      move.l d1, d0
00002052  90B9 00002238           1310      sub.l LastTime, d0
00002058  B0BC 00000005           1311      cmp.l #5, d0            ; Is time elapsed less than 5/100ths of a second?
0000205E  6300 FFE6               1312      bls.l GameLoop          ; If not, wait
00002062  23C1 00002238           1313      move.l d1, LastTime     ; Otherwise, this is the new last time
00002068                          1314  
00002068                          1315      *,___________________________,
00002068                          1316      *| STAGE ONE: Capture Inputs |
00002068                          1317      *|___________________________|
00002068                          1318      *`                           ` 
00002068  4EB9 002AD48E           1319      jsr i_CaptureInputs   ; Fills registers d3-d4 (destructively) with player inputs
0000206E                          1320  
0000206E                          1321      *,___________________________,
0000206E                          1322      *| STAGE TWO: Physics Pass   |
0000206E                          1323      *|___________________________|
0000206E                          1324      *`                           `
0000206E  4EB9 002AD4AE           1325      jsr ph_CalculateRotation
00002074  4EB9 002AD51A           1326      jsr ph_SelectShipRotation
0000207A                          1327  
0000207A  4EB9 002AD55A           1328      jsr ph_CalcVelMagnitude
00002080  4EB9 002AD5C0           1329      jsr ph_CalcVelDir
00002086  4EB9 002AD632           1330      jsr ph_CalculatePosition
0000208C                          1331  
0000208C  4EB9 002ADE84           1332      jsr cl_CheckCollisions
00002092                          1333  
00002092                          1334      *,___________________________,
00002092                          1335      *| STAGE THREE: Rendering    |
00002092                          1336      *|___________________________|
00002092                          1337      *`                           `
00002092                          1338      ; Clear old sprites from screen
00002092  4EB9 0017CF0A           1339      jsr r_ClearSprites ; Wipe sprites from screen
00002098                          1340  
00002098                          1341      ; Render ship
00002098                          1342      ; move.l #pg_Ship, a0
00002098  204B                    1343      move.l a3, a0   ; Move ship image address to the correct location
0000209A  2005                    1344      move.l d5, d0   ; Move position to offset
0000209C  4EB9 0017CE82           1345      jsr r_PrintImage
000020A2                          1346  
000020A2                          1347      ; Swap Buffer
000020A2  4EB9 0017CF98           1348      jsr SwapBuffer
000020A8                          1349  
000020A8  0C79 0001 00002240      1350      cmp.w #1, flag_IsDead   ; did player die?
000020B0  6700 0016               1351      beq.l .Return  ; If so, end loop
000020B4                          1352  
000020B4  C8BC 00FF0000           1353      and.l #$00FF0000, d4
000020BA  B8BC 00FF0000           1354      cmp.l #$00FF0000, d4    ; Did player press ESC?
000020C0  6700 0006               1355      beq.l .Return  ; If so, continue loop
000020C4                          1356  
000020C4  4EF8 2046               1357      jmp GameLoop
000020C8                          1358  
000020C8                          1359  .Return:
000020C8                          1360  
000020C8  4E75                    1361      rts
000020CA                          1362  *| [End of Function] GameLoop
000020CA                          1363  *|__________________________________________________
000020CA                          1364  *`                                                  `
000020CA                          1365  
000020CA                          1366  *,__________________________________________________,
000020CA                          1367  *| fn UpdateTimer
000020CA                          1368  *| Description: Checks if a second has passed to update
000020CA                          1369  *| the timer
000020CA                          1370  *| Inputs: d1: Current Time
000020CA                          1371  UpdateTimer:
000020CA  48E7 FFFE               1372      movem.l ALL_REG, -(sp)  *| Push registers to stack
000020CE                          1373  
000020CE  2001                    1374      move.l d1, d0
000020D0  90B9 0000223C           1375      sub.l LastSecond, d0
000020D6  B0BC 00000064           1376      cmp.l #100, d0          ; Is time elapsed 1 second?
000020DC  6300 003E               1377      bls.l .Return            ; If not, carry on as normal
000020E0                          1378  
000020E0  23C1 0000223C           1379      move.l d1, LastSecond   ; Otherwise, we're now in the next second
000020E6                          1380  
000020E6  4280                    1381      clr.l d0                ; clear d0 for next step
000020E8                          1382  
000020E8  207C 002ADC5C           1383      move.l #ssd_Timer, a0   ; Let's now update the timer
000020EE  D1FC 00000018           1384      add.l #24, a0           ; Offset to 4th display (00:0X)
000020F4                          1385  
000020F4                          1386  .AddSecond:
000020F4  5C88                    1387      add.l #6, a0            ; Offset to actual number
000020F6  3010                    1388      move.w (a0), d0         ; Grab number
000020F8  5280                    1389      add.l #1, d0            ; Increment by 1
000020FA  B0BC 00000009           1390      cmp.l #9, d0            ; Has its number gone over 9?
00002100  6F00 0012               1391      ble.l .EndOverflow      ; If not, we're done.
00002104                          1392  
00002104                          1393      ; Otherwise, we overflow to the next display
00002104  5D88                    1394      sub.l #6, a0            ; offset to start of current display
00002106  7000                    1395      move.l #0, d0           ; New number in display must be 0
00002108  4EB9 002AD8BC           1396      jsr ss_SevenSegUpdate
0000210E                          1397  
0000210E  5188                    1398      sub.l #8, a0            ; offset to start of last display
00002110  4EF8 20F4               1399      jmp .AddSecond          ; Continue loop
00002114                          1400  
00002114                          1401  .EndOverflow:
00002114  5D88                    1402      sub.l #6, a0            ; Offset back to start of display addr
00002116  4EB9 002AD8BC           1403      jsr ss_SevenSegUpdate   ; Print this display's new number
0000211C                          1404  
0000211C                          1405  .Return:
0000211C  4CDF 7FFF               1406      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00002120                          1407  
00002120  4E75                    1408      rts
00002122                          1409  *| [End of Function] UpdateTimer
00002122                          1410  *|__________________________________________________
00002122                          1411  *`                                                  `
00002122                          1412  
00002122  =00100010               1413  POWERUP_DIMENSIONS      EQU $00100010
00002122                          1414  
00002122                          1415  *,__________________________________________________,
00002122                          1416  *| [Powerup] SpawnPowerup
00002122                          1417  *| Description: Randomly spawns a new powerup on the map
00002122                          1418  pwr_SpawnPowerup:
00002122  48E7 FFFE               1419      movem.l ALL_REG, -(sp)  *| Push registers to stack
00002126                          1420  
00002126  7008                    1421      move.l #GET_TIME, d0
00002128  4E4F                    1422      TRAP #15
0000212A                          1423  
0000212A  2001                    1424      move.l d1, d0
0000212C  72AF                    1425      moveq #$AF-$100, d1
0000212E  7412                    1426      moveq #18, d2
00002130                          1427  
00002130                          1428  .Ninc0:
00002130  D080                    1429      add.l d0, d0
Line 1430 ERROR: Undefined symbol
00002132  6400 9BE2               1430      bcc Ninc1
00002136  B300                    1431      eor.b d1, d0
00002138                          1432  
00002138                          1433  .Ninc1:
00002138  51CA FFF6               1434      dbf d2, .Ninc0
0000213C                          1435  
0000213C                          1436      ; d0 stores final random number
0000213C  80FC 0005               1437      divu.w #5, d0   ; Find rand % 5
00002140  E088                    1438      lsr.l #8, d0    ; Only want remainder
00002142  E088                    1439      lsr.l #8, d0
00002144                          1440  
00002144                          1441      ; d0 now stores the index of the spawn location
00002144                          1442  .GetLoc: ; Get spawn location
00002144  207C 0000224A           1443      move.l #arr_PowerupLocations, a0
0000214A  E988                    1444      lsl.l #4, d0    ; Multiply index by length of element (Long)
0000214C  D1C0                    1445      add.l d0, a0
0000214E                          1446  
0000214E  2210                    1447      move.l (a0), d1 ; d1 holds offset to new pickup location
00002150                          1448  
00002150  23C1 00002246           1449      move.l d1, CurrentPowerupLoc
00002156                          1450  
00002156                          1451  .ClearLast: ; Clears last powerup    
00002156  4EB9 000021B0           1452      jsr pwr_ClearPowerup
0000215C                          1453  
0000215C                          1454  .PrintNew:
0000215C  2001                    1455      move.l d1, d0
0000215E  E088                    1456      lsr.l #8, d0            ; Current X
00002160  E088                    1457      lsr.l #8, d0    
00002162  C2BC 0000FFFF           1458      and.l #$0000FFFF, d1    ; Current Y
00002168                          1459  
00002168  2C3C 00100010           1460      move.l #POWERUP_DIMENSIONS, d6
0000216E  2E06                    1461      move.l d6, d7
00002170  E08E                    1462      lsr.l #8, d6            ; W
00002172  E08E                    1463      lsr.l #8, d6
00002174  CEBC 0000FFFF           1464      and.l #$0000FFFF, d7    ; H
0000217A                          1465  
0000217A  2400                    1466      move.l d0, d2
0000217C  D486                    1467      add.l d6, d2            ; End X
0000217E                          1468  
0000217E  2601                    1469      move.l d1, d3
00002180  D687                    1470      add.l d7, d3            ; End Y
00002182                          1471  
00002182  207C 002ADF6C           1472      move.l #cm_Road, a0
00002188                          1473  
00002188                          1474      *,__________________________________________________,
00002188                          1475      *| For Loop: for y = Offset Y, y < Offset Y + Height, y++ 
00002188                          1476  .MarkRow:
00002188  2801                    1477          move.l d1, d4
0000218A  C8FC 0280               1478          mulu.w #SCREEN_WIDTH, d4    ; Current Y times Screen Width (width of collision map)
0000218E  D880                    1479          add.l d0, d4                ; Then, add x offset
00002190                          1480  
00002190                          1481          *,__________________________________________________,
00002190                          1482          *| For Loop: for x = Offset X, x < Offset X + Width, x++
00002190                          1483  .MarkPixel:
00002190  2248                    1484              move.l a0, a1   ; Get location in collision map
00002192  D3C4                    1485              add.l d4, a1    ; Stored in bytes
00002194                          1486  
00002194  12BC 0004               1487              move.b #4, (a1) ; Replace old material with Road
00002198                          1488  
00002198  5280                    1489              add.l #1, d0
0000219A                          1490  
0000219A  B082                    1491              cmp.l d2, d0        ; Are we at end of row?
0000219C  6D00 FFF2               1492              blt.l .MarkPixel    ; If not, continue
000021A0                          1493          *| End For Loop
000021A0                          1494          
000021A0                          1495          ; Let's rewind x back to the start
000021A0  9086                    1496          sub.l d6, d0
000021A2                          1497  
000021A2                          1498          ; Let's push y to the next index
000021A2  5281                    1499          add.l #1, d1
000021A4  B283                    1500          cmp.l d3, d1    ; Are we at the end of the chunk?
000021A6  6D00 FFE0               1501          blt.l .MarkRow  ; Nope, let's keep on moving
000021AA                          1502  
000021AA                          1503      *| End For Loop
000021AA                          1504  
000021AA                          1505  .Return:
000021AA  4CDF 7FFF               1506      movem.l (sp)+, ALL_REG  *| Pull registers from stack
000021AE                          1507  
000021AE  4E75                    1508      rts
000021B0                          1509  *| [End of Function] SpawnPowerup
000021B0                          1510  *|__________________________________________________
000021B0                          1511  *`                                                  `
000021B0                          1512  
000021B0                          1513  *,__________________________________________________,
000021B0                          1514  *| [Powerup] ClearPowerup
000021B0                          1515  *| Description: Removes the current powerup from the screen
000021B0                          1516  pwr_ClearPowerup:
000021B0  48E7 FFFE               1517      movem.l ALL_REG, -(sp)  *| Push registers to stack
000021B4                          1518  
000021B4  2039 00002246           1519      move.l CurrentPowerupLoc, d0
000021BA  2279 0017D042           1520      move.l pixel_clear_length, a1
000021C0  2280                    1521      move.l d0, (a1)                     ; Move image offset to pixel_clear_zones
000021C2  5889                    1522      add.l #4, a1                        ; Move to next word
000021C4  22BC 00100010           1523      move.l #POWERUP_DIMENSIONS, (a1)    ; Move image dimensions to pixel_clear_zones
000021CA  50B9 0017D042           1524      add.l #8, pixel_clear_length        ; Move to next word
000021D0                          1525  
000021D0                          1526      ; Call an early sprite clear
000021D0  4EB9 0017CF0A           1527      jsr r_ClearSprites
000021D6                          1528  
000021D6                          1529      ; Let's also do the same for the material on the area it was on
000021D6                          1530  .WipeMat:
000021D6  2200                    1531      move.l d0, d1
000021D8  E088                    1532      lsr.l #8, d0            ; Current X
000021DA  E088                    1533      lsr.l #8, d0    
000021DC  C2BC 0000FFFF           1534      and.l #$0000FFFF, d1    ; Current Y
000021E2                          1535  
000021E2  2C3C 00100010           1536      move.l #POWERUP_DIMENSIONS, d6
000021E8  2E06                    1537      move.l d6, d7
000021EA  E08E                    1538      lsr.l #8, d6            ; W
000021EC  E08E                    1539      lsr.l #8, d6
000021EE  CEBC 0000FFFF           1540      and.l #$0000FFFF, d7    ; H
000021F4                          1541  
000021F4  2400                    1542      move.l d0, d2
000021F6  D486                    1543      add.l d6, d2            ; End X
000021F8                          1544  
000021F8  2601                    1545      move.l d1, d3
000021FA  D687                    1546      add.l d7, d3            ; End Y
000021FC                          1547  
000021FC  207C 002ADF6C           1548      move.l #cm_Road, a0
00002202                          1549  
00002202                          1550      *,__________________________________________________,
00002202                          1551      *| For Loop: for y = Offset Y, y < Offset Y + Height, y++ 
00002202                          1552  .WipeRow:
00002202  2801                    1553          move.l d1, d4
00002204  C8FC 0280               1554          mulu.w #SCREEN_WIDTH, d4    ; Current Y times Screen Width (width of collision map)
00002208  D880                    1555          add.l d0, d4                ; Then, add x offset
0000220A                          1556  
0000220A                          1557          *,__________________________________________________,
0000220A                          1558          *| For Loop: for x = Offset X, x < Offset X + Width, x++
0000220A                          1559  .WipePixel:
0000220A  2248                    1560              move.l a0, a1   ; Get location in collision map
0000220C  D3C4                    1561              add.l d4, a1    ; Stored in bytes
0000220E                          1562  
0000220E  12BC 0001               1563              move.b #1, (a1) ; Replace old material with Road
00002212                          1564  
00002212  5280                    1565              add.l #1, d0
00002214                          1566  
00002214  B082                    1567              cmp.l d2, d0        ; Are we at end of row?
00002216  6D00 FFF2               1568              blt.l .WipePixel    ; If not, continue
0000221A                          1569          *| End For Loop
0000221A                          1570          
0000221A                          1571          ; Let's rewind x back to the start
0000221A  9086                    1572          sub.l d6, d0
0000221C                          1573  
0000221C                          1574          ; Let's push y to the next index
0000221C  5281                    1575          add.l #1, d1
0000221E  B283                    1576          cmp.l d3, d1    ; Are we at the end of the chunk?
00002220  6D00 FFE0               1577          blt.l .WipeRow  ; Nope, let's keep on moving
00002224                          1578  
00002224                          1579      *| End For Loop
00002224                          1580  
00002224                          1581  .Return:
00002224  4CDF 7FFF               1582      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00002228                          1583  
00002228  4E75                    1584      rts
0000222A                          1585  *| [End of Function] ClearPowerup
0000222A                          1586  *|__________________________________________________
0000222A                          1587  *`                                                  `
0000222A                          1588  
0000222A                          1589  *,__________________________________________________,
0000222A                          1590  *| [Powerup] FuelUp
0000222A                          1591  *| Description: Resets fuel to max
0000222A                          1592  pwr_FuelUp:
0000222A  48E7 FFFE               1593      movem.l ALL_REG, -(sp)  *| Push registers to stack
0000222E                          1594  
0000222E  4EB8 21B0               1595      jsr pwr_ClearPowerup    ; Clear texture & material
00002232                          1596  
00002232                          1597  .Return:
00002232  4CDF 7FFF               1598      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00002236                          1599  
00002236  4E75                    1600      rts
00002238                          1601  *| [End of Function] FuelUp
00002238                          1602  *|__________________________________________________
00002238                          1603  *`                                                  `
00002238                          1604  
00002238                          1605  *,__________________________________________________,
00002238                          1606  *| Global Variables
00002238                          1607  LastTime    ds.l 1  ; Stores the last frame's start time
0000223C                          1608  LastSecond   ds.l 1  ; Stores the time the game started
00002240                          1609  
00002240                          1610  *| Flag (0 is false, >0 is true)
00002240= 0000                    1611  flag_IsDead         dc.w $0
00002242= 0000                    1612  flag_IsBoosting     dc.w $0
00002244= 0000                    1613  flag_CanLap         dc.w $0
00002246                          1614      
00002246                          1615  CurrentPowerupLoc  ds.l 1
0000224A= 004B004B 00FA00A0 ...   1616  arr_PowerupLocations  dc.l $004B004B,$00FA00A0,$01540160,$02030118,$022B0046
0000225E                          1617  
0000225E                          1618      END    START

1 error detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACCEL_AMOUNT        100
ALL_REG             7FFF
ARR_POWERUPLOCATIONS  224A
BACKGROUNDBMPFILE   1198
CL_CHECKCOLLISIONS  2ADE84
CL_CHECKCOLLISIONS:RETURN  2ADECE
CL_GETCOLLISIONMATERIAL  2ADED0
CL_GETCOLLISIONMATERIAL:RETURN  2ADEF2
CL_PROCESSMATERIAL  2ADEF4
CL_PROCESSMATERIAL:LAP  2ADF0C
CL_PROCESSMATERIAL:MIDLAP  2ADF3C
CL_PROCESSMATERIAL:OFFROAD  2ADEF4
CL_PROCESSMATERIAL:POWERUP  2ADF5A
CL_PROCESSMATERIAL:RETURN  2ADF6A
CM_ROAD             2ADF6C
CURRENTPOWERUPLOC   2246
DECEL_AMOUNT        100
ENDSHIPBMPFILES     17CE82
ENTER               D
ESC                 1B
FLAG_CANLAP         2244
FLAG_ISBOOSTING     2242
FLAG_ISDEAD         2240
FL_LOADBITMAP       106E
FL_LOADCOLLISIONMAP  113A
FL_LOADCOLLISIONMAP:END  118A
FL_LOADCOLLISIONMAP:GETPIXELMAT  1148
FL_LOADCOLLISIONMAP:LAP  116A
FL_LOADCOLLISIONMAP:MIDLAP  117A
FL_LOADCOLLISIONMAP:OFFROAD  114A
FL_LOADCOLLISIONMAP:ONROAD  115A
FL_LOADCOLLISIONMAP:RETURN  1196
FL_LOADFILES        1000
FL_LOADSHIPROTATIONS  1044
FL_LOADSHIPROTATIONS:LOADBMP  1050
FP_11P25            B4000
FP_22P5             168000
FP_360              1680000
GAMELOOP            2046
GAMELOOP:RETURN     20C8
GETBITMAPCHUNKS     10B8
GETSINGLEPIXEL      10D2
GET_KEY_INPUT_COMMAND  13
GET_TIME            8
I_CAPTUREINPUTS     2AD48E
I_CAPTUREINPUTS:RETURN  2AD4A8
LAP_DISPLAY_OFFSET  2540014
LASTSECOND          223C
LASTTIME            2238
MAIN                2000
MAX_SPEED           1000
MAX_VELOCITY        30000
PARSEBITMAPHEADER   1072
PARSELITTLEENDIANLONG  1132
PG_7SEGHORIZONTAL   2ADD80
PG_7SEGVERTICAL     2ADC7C
PG_BACKGROUND       17D046
PG_DEBRIS           2AD08A
PG_SHIPROTATIONS    2A904A
PH_CALCULATEPOSITION  2AD632
PH_CALCULATEPOSITION:NEGX  2AD644
PH_CALCULATEPOSITION:NEGY  2AD65A
PH_CALCULATEPOSITION:POSX  2AD658
PH_CALCULATEPOSITION:POSY  2AD66E
PH_CALCULATEPOSITION:RETURN  2AD690
PH_CALCULATEPOSITION:UPDATEPOS  2AD670
PH_CALCULATEROTATION  2AD4AE
PH_CALCULATEROTATION:ANGLEOVER  2AD502
PH_CALCULATEROTATION:ANGLEUNDER  2AD50E
PH_CALCULATEROTATION:FIXANGLE  2AD4E8
PH_CALCULATEROTATION:RETURN  2AD514
PH_CALCULATEROTATION:TURNLEFT  2AD4CC
PH_CALCULATEROTATION:TURNRIGHT  2AD4E2
PH_CALCVELDIR       2AD5C0
PH_CALCVELDIR:RETURN  2AD62C
PH_CALCVELMAGNITUDE  2AD55A
PH_CALCVELMAGNITUDE:ACCEL  2AD580
PH_CALCVELMAGNITUDE:CLAMP  2AD592
PH_CALCVELMAGNITUDE:CLAMPMAX  2AD5A4
PH_CALCVELMAGNITUDE:CLAMPMIN  2AD592
PH_CALCVELMAGNITUDE:DECEL  2AD58C
PH_CALCVELMAGNITUDE:FRIC  2AD5BA
PH_CALCVELMAGNITUDE:RETURN  2AD5BA
PH_CLAMPNUMBER      2AD696
PH_CLAMPNUMBER:OVER  2AD6BE
PH_CLAMPNUMBER:RETURN  2AD6C6
PH_CLAMPNUMBER:UNDER  2AD6B6
PH_CLAMPVECTOR      2AD6CA
PH_CLAMPVECTOR:RETURN  2AD706
PH_SELECTSHIPROTATION  2AD51A
PH_SELECTSHIPROTATION:GETFILE  2AD548
PH_SELECTSHIPROTATION:NEXTROT  2AD528
PH_SELECTSHIPROTATION:RETURN  2AD554
PH_SINE             2AD70C
PH_SINE:Q1          2AD734
PH_SINE:Q2          2AD746
PH_SINE:Q3          2AD764
PH_SINE:Q4          2AD77E
PH_SINE:RETURN      2AD798
PIXEL_CLEAR_LENGTH  17D042
PIXEL_CLEAR_ZONES   17CFA2
POWERUP_DIMENSIONS  100010
PRINT_PIXEL         52
PWR_CLEARPOWERUP    21B0
PWR_CLEARPOWERUP:RETURN  2224
PWR_CLEARPOWERUP:WIPEMAT  21D6
PWR_CLEARPOWERUP:WIPEPIXEL  220A
PWR_CLEARPOWERUP:WIPEROW  2202
PWR_FUELUP          222A
PWR_FUELUP:RETURN   2232
PWR_SPAWNPOWERUP    2122
PWR_SPAWNPOWERUP:CLEARLAST  2156
PWR_SPAWNPOWERUP:GETLOC  2144
PWR_SPAWNPOWERUP:MARKPIXEL  2190
PWR_SPAWNPOWERUP:MARKROW  2188
PWR_SPAWNPOWERUP:NINC0  2130
PWR_SPAWNPOWERUP:NINC1  2138
PWR_SPAWNPOWERUP:PRINTNEW  215C
PWR_SPAWNPOWERUP:RETURN  21AA
ROADCOLLISIONFILE   12D222
R_CLEARSPRITES      17CF0A
R_CLEARSPRITES:CHECKENDOFSPRITES  17CF82
R_CLEARSPRITES:CLEARPIXEL  17CF4C
R_CLEARSPRITES:CLEARSPRITE  17CF4C
R_CLEARSPRITES:GETSPRITE  17CF26
R_CLEARSPRITES:LOADREGISTER  17CF0E
R_CLEARSPRITES:PRINTBGPIXEL  17CF5E
R_CLEARSPRITES:RETURN  17CF92
R_PRINTIMAGE        17CE82
R_PRINTIMAGE:LOADVARSTOREGISTERS  17CEA6
R_PRINTIMAGE:NOPRINT  17CEF0
R_PRINTIMAGE:PRINTPIXEL  17CED4
R_PRINTIMAGE:RETURN  17CF04
SCREEN_HEIGHT       1E0
SCREEN_WIDTH        280
SET_PIXEL_COLOR     50
SEVENSEGHORIZONTALBMPFILE  2ADB30
SEVENSEGTABLE       2ADC4A
SEVENSEGVERTICALBMPFILE  2ADA16
SEVEN_SEG_DIMENSIONS  12001F
SHIFT               10
SHIPBMPFILES        1785E2
SHIPPOSITION        2AD850
SHIP_BMP_SIZE       48A
SHIP_PG_SIZE        404
SINTABLE            2AD79A
SINTABLESIZE        B4
SPACE               20
SSD_LAP             2ADC54
SSD_TIMER           2ADC5C
SS_INCREMENTLAP     2AD9E0
SS_INCREMENTLAP:ENDGAME  2ADA08
SS_INCREMENTLAP:RETURN  2ADA10
SS_INITDISPLAYS     2AD858
SS_INITDISPLAYS:RETURN  2AD8B6
SS_SEVENSEGUPDATE   2AD8BC
SS_SEVENSEGUPDATE:FIFTH  2AD97A
SS_SEVENSEGUPDATE:FIRST  2AD900
SS_SEVENSEGUPDATE:FOURTH  2AD95A
SS_SEVENSEGUPDATE:PRINTSEGMENTS  2AD8F8
SS_SEVENSEGUPDATE:RETURN  2AD9DA
SS_SEVENSEGUPDATE:SECOND  2AD91E
SS_SEVENSEGUPDATE:SEVENTH  2AD9BA
SS_SEVENSEGUPDATE:SIXTH  2AD99A
SS_SEVENSEGUPDATE:THIRD  2AD93A
START               2000
SWAPBUFFER          17CF98
SWAP_BUFFER         5E
TIMER_1_DISPLAY_OFFSET  50014
TIMER_2_DISPLAY_OFFSET  1A0014
TIMER_3_DISPLAY_OFFSET  370014
TIMER_4_DISPLAY_OFFSET  4C0014
TRAP_REG            703
UPDATETIMER         20CA
UPDATETIMER:ADDSECOND  20F4
UPDATETIMER:ENDOVERFLOW  2114
UPDATETIMER:RETURN  211C
