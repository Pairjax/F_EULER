00002000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/17/2023 5:09:36 PM

00000000                             1  *,______________________________________________________,
00000000                             2  *|__________  ______________  ________________________  |
00000000                             3  *|___  ____/  ___  ____/_  / / /__  /___  ____/__  __ \ |
00000000                             4  *|__  /_________  __/  _  / / /__  / __  __/  __  /_/ / |
00000000                             5  *|_  __//_____/  /___  / /_/ / _  /___  /___  _  _, _/  |
00000000                             6  *|/_/         /_____/  \____/  /_____/_____/  /_/ |_|   |
00000000                             7  *|                                                      |
00000000                             8  *|            The 68k high-speed racing game            |
00000000                             9  *|                                                      |
00000000                            10  *|  Made By: Austin Smith        Date Started: 10/7/23  |
00000000                            11  *|______________________________________________________|
00000000                            12  *`                                                      `
00000000                            13  
00001000                            14      ORG $1000
00001000                            15  
00001000                            16  *,__________________________________________________,
00001000                            17  *| Constants
00001000                            18  
00001000                            19  ALL_REG             REG D0-D7/A0-A6
00001000                            20  TRAP_REG            REG D0-D1/A0-A2
00001000                            21  
00001000                            22  *| Vectors
00001000  =00000280                 23  SCREEN_WIDTH        EQU 640
00001000  =000001E0                 24  SCREEN_HEIGHT       EQU 480
00001000                            25  
00001000                            26  *| TRAP Codes
00001000  =00000013                 27  GET_KEY_INPUT_COMMAND   EQU 19
00001000                            28  
00001000  =00000050                 29  SET_PIXEL_COLOR     EQU 80
00001000  =00000052                 30  PRINT_PIXEL         EQU 82
00001000                            31  
00001000  =00000008                 32  GET_TIME            EQU 8
00001000                            33  
00001000  =0000005E                 34  SWAP_BUFFER         EQU 94
00001000                            35  
00001000                            36  *| 7 Segment Stuff
00001000  =0012001F                 37  SEVEN_SEG_DIMENSIONS    EQU $0012001F
00001000                            38  
00001000                            39  *,__________________________________________________,
00001000                            40  *| Includes
00001000                            41      INCLUDE "./file_loader.x68"   ; Handles loading of files during preload phase
00001000                            42  
00001000  =0000048A                 43  SHIP_BMP_SIZE       EQU 1162    ; The number of bytes betwen each ship file
00001000  =00000404                 44  SHIP_PG_SIZE        EQU 1028     ; The size of a ship sprite in memory
00001000                            45  
00001000                            46  fl_LoadFiles:
00001000                            47      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001000  207C 000021DC             48      move.l #BackgroundBmpFile, a0   *| file_root
00001006  227C 0017DEC6             49      move.l #pg_Background, a1       *| output_image
0000100C  4EB9 0000106E             50      jsr fl_LoadBitmap
00001012                            51  
00001012                            52      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001012  207C 000017EE             53      move.l #SevenSegVerticalBmpFile, a0   *| file_root
00001018  227C 002F93BA             54      move.l #pg_7SegVertical, a1       *| output_image
0000101E  4EB9 0000106E             55      jsr fl_LoadBitmap
00001024                            56  
00001024                            57      *| LoadBitmap(a0=file_root: bitmap*, a1=output_image: pixel_grid*)
00001024  207C 00001908             58      move.l #SevenSegHorizontalBmpFile, a0   *| file_root
0000102A  227C 002F94BE             59      move.l #pg_7SegHorizontal, a1       *| output_image
00001030  4EB9 0000106E             60      jsr fl_LoadBitmap
00001036                            61  
00001036  4EB9 0000113A             62      jsr fl_LoadCollisionMap     ; No inputs needed because there is only one
0000103C                            63  
0000103C  4EB9 00001044             64      jsr fl_LoadShipRotations
00001042                            65      
00001042  4E75                      66      rts
00001044                            67  
00001044                            68  fl_LoadShipRotations:
00001044  207C 00179626             69      move.l #ShipBmpFiles, a0
0000104A  227C 002A9ECA             70      move.l #pg_ShipRotations, a1
00001050                            71  
00001050                            72  .LoadBmp:
00001050  4EB9 0000106E             73      jsr fl_LoadBitmap
00001056                            74  
00001056  D1FC 0000048A             75      add.l #SHIP_BMP_SIZE, a0
0000105C  D3FC 00000404             76      add.l #SHIP_PG_SIZE, a1
00001062                            77  
00001062  B1FC 0017DEC6             78      cmp.l #EndShipBmpFiles, a0  ; Are we past the end?
00001068  6D00 FFE6                 79      blt.l .LoadBmp              ; If not, keep on loading.
0000106C                            80  
0000106C  4E75                      81      rts
0000106E                            82  
0000106E                            83  fl_LoadBitmap:
0000106E  48E7 FFFE                 84      movem.l ALL_REG, -(sp) *| Push registers to stack
00001072                            85  
00001072                            86  ParseBitmapHeader: ; Gather essential information from the bitmap's header
00001072                            87      ; This will need to be converted to Big Endian later based on the Color Range
00001072  2648                      88      move.l a0, a3
00001074  D7FC 0000000A             89      add.l #$A, a3               ; Offset to pixel array
0000107A  2213                      90      move.l (a3), d1
0000107C                            91          
0000107C  4EB9 00001132             92      jsr ParseLittleEndianLong
00001082                            93          
00001082  D288                      94      add.l a0, d1
00001084  2801                      95      move.l d1, d4               ; Offset to Pixel Array
00001086                            96          
00001086  2648                      97      move.l a0, a3
00001088  D7FC 00000012             98      add.l #$12, a3              ; Offset to image width
0000108E  2213                      99      move.l (a3), d1             ; Image Width
00001090  4EB9 00001132            100      jsr ParseLittleEndianLong
00001096  2A01                     101      move.l d1, d5
00001098                           102          
00001098  2648                     103      move.l a0, a3
0000109A  D7FC 00000016            104      add.l #$16, a3              ; Offset to image height
000010A0  2213                     105      move.l (a3), d1             ; Image Height
000010A2  4EB9 00001132            106      jsr ParseLittleEndianLong
000010A8  2C01                     107      move.l d1, d6
000010AA                           108      
000010AA  3285                     109      move.w d5, (a1)             ; Push width & height to pixel grid
000010AC  5489                     110      add.l #2, a1
000010AE  3286                     111      move.w d6, (a1)
000010B0  5489                     112      add.l #2, a1                ; Offset to start of pixel data in pixel grid
000010B2                           113          
000010B2  5C8B                     114      add.l #$6, a3
000010B4  3213                     115      move.w (a3), d1             ; ColorRange
000010B6  E159                     116      rol.w #8, d1
000010B8                           117  
000010B8                           118  GetBitmapChunks:                ; Get the desired chunks of the bitmap
000010B8                           119                                  ; Finding starting address
000010B8  2006                     120      move.l d6, d0               ; Height (H)
000010BA  5380                     121      sub.l #1, d0                ; Sub by 1 to get column H - 1
000010BC  2205                     122      move.l d5, d1
000010BE  C0C1                     123      mulu.w d1, d0               ; Multiply by width to get last index of column CY - 1
000010C0                           124          
000010C0  2200                     125      move.l d0, d1               ; Storing in a separate variable so we can keep the index for other calculations
000010C2  E589                     126      lsl.l #2, d1                ; Multiply by size of each pixel (Long Word).
000010C4  D284                     127      add.l d4, d1                ; Beginning of Pixel Array + Offset to Chunk Start
000010C6  2041                     128      move.l d1, a0               ; Current Pixel Address
000010C8                           129          
000010C8                           130      ; Finding end-of-row index
000010C8  D085                     131      add.l d5, d0                ; Add Chunk Width to push it to the end of the desired chunk's first row.
000010CA  E588                     132      lsl.l #2, d0                ; Multiply by size of each pixel (Long Word).
000010CC  D084                     133      add.l d4, d0                ; Beginning of Pixel Array + Offset to End-Of-Row
000010CE  2440                     134      move.l d0, a2               ; End Of Row Pixel Address
000010D0                           135          
000010D0                           136      ; Finding ending address
000010D0  2644                     137      move.l d4, a3   ; Represents the end row of the chunk's Address.
000010D2                           138  
000010D2                           139  GetSinglePixel:
000010D2                           140      ; Get pixel data
000010D2  2210                     141      move.l (a0), d1
000010D4                           142          
000010D4  4EB9 00001132            143      jsr ParseLittleEndianLong ; Convert to big endian
000010DA  2001                     144      move.l d1, d0   ; Move back to d0 after conversion
000010DC                           145         
000010DC  2200                     146      move.l d0, d1   ; Red
000010DE  E089                     147      lsr.l #8, d1    ; Red is the 3rd element, so we shift it 2 bytes over        
000010E0  E089                     148      lsr.l #8, d1    ; Have to cut it in byte increments.
000010E2  C2BC 000000FF            149      and.l #$FF, d1  ; Chopping off the channel bits that remain to the left.
000010E8                           150      
000010E8  2400                     151      move.l d0, d2   ; Green
000010EA  E08A                     152      lsr.l #8, d2    ; Green is the 2nd element, so we shift it 1 byte.
000010EC  C4BC 000000FF            153      and.l #$FF, d2  ; Chopping off the channel bits that remain to the left.
000010F2                           154          
000010F2  2600                     155      move.l d0, d3   ; Blue
000010F4  C6BC 000000FF            156      and.l #$FF, d3  ; Chopping off the channel bits that remain to the left.
000010FA                           157          
000010FA                           158      ; Shift these bits to the correct location for when we read it in BGR
000010FA  E18B                     159      lsl.l #8, d3    ; Blue is first, so we're shifting it to the 3rd byte
000010FC  E18B                     160      lsl.l #8, d3
000010FE                           161        
000010FE  E18A                     162      lsl.l #8, d2    ; Green is next, which goes to the 2nd byte.
00001100                           163          
00001100                           164      ; Red stays in place, now we merge the three variables into one
00001100  C0BC FF000000            165      and.l #$FF000000, d0
00001106  8081                     166      or.l d1, d0
00001108  8082                     167      or.l d2, d0
0000110A  8083                     168      or.l d3, d0
0000110C                           169          
0000110C                           170      ; Push to BitmapChunk location
0000110C  2280                     171      move.l d0, (a1)
0000110E                           172          
0000110E                           173      ; Move Bitmap Chunk Pointer to next pixel
0000110E  5889                     174      add.l #4, a1
00001110                           175          
00001110                           176      ; Move Pixel Array Pointer to the next pixel
00001110  5888                     177      add.l #4, a0            ; Move over 1 pixel
00001112  B5C8                     178      cmp.l a0, a2            ; Is current Pixel Array Pointer past End of Row?
00001114  6E00 FFBC                179      bgt.l GetSinglePixel    ; If not, continue the loop 
00001118                           180          
00001118                           181      ; If so, let's move the End of Row to the next row (backwards)
00001118  2005                     182      move.l d5, d0
0000111A  E588                     183      lsl.l #2, d0    ; Multiply by size of each index
0000111C  95C0                     184      sub.l d0, a2
0000111E                           185          
0000111E                           186      ; Let's also move the Current Pixel Address to the start of the next row.
0000111E  2005                     187      move.l d5, d0           ; Move pointer back by 2xImageWidth
00001120  D085                     188      add.l d5, d0
00001122  E588                     189      lsl.l #2, d0
00001124  91C0                     190      sub.l d0, a0
00001126                           191          
00001126                           192      ; Have we passed the end of the chunk?
00001126  B7C8                     193      cmp.l a0, a3            ; Is Current Pixel Address past the index of End of Chunk index?
00001128  6F00 FFA8                194      ble.l GetSinglePixel    ; If not, continue the loop
0000112C                           195          
0000112C                           196      ; If so, we've finished sorting.
0000112C  4CDF 7FFF                197      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00001130                           198  
00001130  4E75                     199      rts
00001132                           200  
00001132                           201  ParseLittleEndianLong:  ; Simple function to convert d1 LW from Little Endian to Big Endian
00001132  E159                     202      rol.w #8, d1
00001134  4841                     203      swap d1
00001136  E159                     204      rol.w #8, d1
00001138                           205          
00001138  4E75                     206      rts
0000113A                           207  
0000113A                           208  fl_LoadCollisionMap:
0000113A  207C 0012E266            209      move.l #RoadCollisionFile, a0
00001140  227C 002AE30E            210      move.l #cm_Road, a1 ; Start of array
00001146                           211  
00001146  7000                     212      move.l #0, d0       ; Current index in array
00001148                           213  
00001148                           214  .GetPixelMat:           ; Get pixel material
00001148  1210                     215      move.b (a0), d1 
0000114A                           216      
0000114A                           217  .OffRoad:
0000114A  B23C 0030                218      cmp.b #$30, d1      ; Is material offroad?
0000114E  6600 000A                219      bne.l .OnRoad       ; Move to next case
00001152                           220  
00001152  12BC 0000                221      move.b #0, (a1)
00001156  5280                     222      add.l #1, d0
00001158  5289                     223      add.l #1, a1
0000115A                           224  
0000115A                           225  .OnRoad:
0000115A  B23C 0031                226      cmp.b #$31, d1      ; Is material onroad?
0000115E  6600 000A                227      bne.l .Lap          ; Move to next case
00001162                           228  
00001162  12BC 0001                229      move.b #1, (a1)
00001166  5280                     230      add.l #1, d0
00001168  5289                     231      add.l #1, a1
0000116A                           232  
0000116A                           233  .Lap:
0000116A  B23C 0032                234      cmp.b #$32, d1      ; Is material lap?
0000116E  6600 000A                235      bne.l .MidLap       ; Move to next case
00001172                           236  
00001172  12BC 0002                237      move.b #2, (a1)
00001176  5280                     238      add.l #1, d0
00001178  5289                     239      add.l #1, a1
0000117A                           240  
0000117A                           241  .MidLap:
0000117A  B23C 0033                242      cmp.b #$33, d1      ; Is material mid-lap?
0000117E  6600 000A                243      bne.l .End          ; Move to next case
00001182                           244  
00001182  12BC 0003                245      move.b #3, (a1)
00001186  5280                     246      add.l #1, d0
00001188  5289                     247      add.l #1, a1
0000118A                           248  
0000118A                           249  .End:
0000118A  5288                     250      add.l #1, a0
0000118C                           251  
0000118C  B0BC 0004B000            252      cmp.l #307200, d0   ; Are we at end of array?
00001192  6D00 FFB4                253      blt.l .GetPixelMat  ; Otherwise, let's start it all over again
00001196                           254  
00001196                           255  .Return:
00001196  4E75                     256      rts
00001198                           257  
00001198                           258  
00001198                           259  -------------------- end include --------------------
00001198                           260      INCLUDE "./renderer.x68"      ; Handles printing sprites & affine transformations.
00001198                           261  
00001198                           262  r_PrintImage: 
00001198  48E7 FFFE                263      movem.l ALL_REG, -(sp)  *| Push registers to stack
0000119C                           264  
0000119C                           265      *| Move starting variables to non-volatile positions
0000119C  2400                     266      move.l d0, d2           ; offset: vec2
0000119E  2010                     267      move.l (a0), d0         ; Image dimensions
000011A0                           268  
000011A0  B2BC 00000000            269      cmp.l #0, d1    ; Is this a sprite?
000011A6  6700 0014                270      beq.l .LoadVarsToRegisters            ; If not, let's skip this step.
000011AA                           271      *| We need to store the offset: vec2 and image dimensions: vec2
000011AA                           272      *| for clearing next frame's data.
000011AA                           273      
000011AA  2279 002F93AE            274      move.l pixel_clear_length, a1
000011B0  2282                     275      move.l d2, (a1)  ; Move image offset to pixel_clear_zones
000011B2  5889                     276      add.l #4, a1     ; Move to next word
000011B4  2280                     277      move.l d0, (a1)  ; Move image dimensions to pixel_clear_zones
000011B6  50B9 002F93AE            278      add.l #8, pixel_clear_length     ; Move to next word
000011BC                           279  
000011BC                           280  .LoadVarsToRegisters:
000011BC                           281  
000011BC                           282      *| Set up the starting variables for printing pixels
000011BC  2602                     283      move.l d2, d3
000011BE  E08B                     284      lsr.l #8, d3            ; Offset X
000011C0  E08B                     285      lsr.l #8, d3
000011C2  C4BC 0000FFFF            286      and.l #$0000FFFF, d2    ; Offset Y
000011C8                           287         
000011C8  2200                     288      move.l d0, d1
000011CA  E088                     289      lsr.l #8, d0            ; Image Width (left word)
000011CC  E088                     290      lsr.l #8, d0
000011CE  2800                     291      move.l d0, d4           ; Store width in d4 to prevent destruction
000011D0  C2BC 0000FFFF            292      and.l #$0000FFFF, d1    ; Image Height (right word)
000011D6                           293          
000011D6  2A03                     294      move.l d3, d5           ; Start X Position
000011D8                           295      
000011D8  4286                     296      clr.l d6
000011DA  3C03                     297      move.w d3, d6           ; End X Position
000011DC  DC80                     298      add.l d0, d6
000011DE  5386                     299      sub.l #1, d6
000011E0                           300          
000011E0  4287                     301      clr.l d7
000011E2  3E02                     302      move.w d2, d7           ; End Y Position
000011E4  DE81                     303      add.l d1, d7
000011E6  5387                     304      sub.l #1, d7
000011E8                           305      
000011E8  5888                     306      add.l #4, a0
000011EA                           307          
000011EA                           308  .PrintPixel:
000011EA  2210                     309      move.l (a0), d1             ; Get current pixel color
000011EC                           310  
000011EC  B2BC 00FFFFFF            311      cmp.l #$00FFFFFF, d1        ; Is pixel color transparent?
000011F2  6300 0012                312      bls.l .NoPrint              ; If so, let's skip printing
000011F6                           313      
000011F6  7050                     314      move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
000011F8                           315  
000011F8  C2BC 00FFFFFF            316      and.l #$00FFFFFF, d1        ; Chop off alpha
000011FE                           317          
000011FE  4E4F                     318      TRAP #15
00001200                           319                 
00001200  7052                     320      move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
00001202  2203                     321      move.l d3, d1               ; Pixel X location must be extracted 
00001204                           322     
00001204  4E4F                     323      TRAP #15
00001206                           324        
00001206                           325  .NoPrint:
00001206                           326      ; Calculate the next target pixel.
00001206  5888                     327      add.l #4, a0            ; Move pointer to next color pixel
00001208                           328          
00001208  5283                     329      add.l #1, d3            ; Move X to the next column
0000120A  B686                     330      cmp.l d6, d3            ; Is X past End X Position?
0000120C  6300 FFDC                331      bls.l .PrintPixel        ; If not, keep on printing
00001210                           332          
00001210                           333      ; Otherwise, we move to the next row
00001210  9684                     334      sub.l d4, d3            ; Move X back to the starting column
00001212  5282                     335      add.l #1, d2            ; Move Y down a row
00001214                           336          
00001214  B487                     337      cmp.l d7, d2            ; Is Y past End Y Position?
00001216  6F00 FFD2                338      ble.l .PrintPixel         ; If not, keep printing.
0000121A                           339  
0000121A                           340  .Return:
0000121A                           341  
0000121A  4CDF 7FFF                342      movem.l (sp)+, ALL_REG  *| Pull registers from stack
0000121E                           343  
0000121E  4E75                     344      rts
00001220                           345  
00001220                           346  
00001220                           347  r_ClearSprites:
00001220  48E7 FFFE                348      movem.l ALL_REG, -(sp) *| Push registers to stack
00001224                           349  
00001224                           350  .LoadRegister:
00001224  207C 002F930E            351      move.l #pixel_clear_zones, a0    ; Current sprite index
0000122A  2279 002F93AE            352      move.l (pixel_clear_length), a1   ; End sprite index
00001230  247C 0017DEC6            353      move.l #pg_Background, a2        ; Background
00001236                           354  
00001236                           355      ; Is pixel clear zones empty?
00001236  B3C8                     356      cmp.l a0, a1
00001238  6700 006E                357      beq.l .Return                ; If list is empty, simply return.
0000123C                           358  
0000123C                           359  .GetSprite:
0000123C                           360      *| Extracting offset into registers for processing.
0000123C  2610                     361      move.l (a0), d3                 ; offset: vec2
0000123E                           362      
0000123E  2403                     363      move.l d3, d2                   ; Separate into two registers
00001240                           364  
00001240  E08B                     365      lsr.l #8, d3                    ; Offset X: int
00001242  E08B                     366      lsr.l #8, d3                    ; Will be used as Current X for loop
00001244                           367  
00001244  C4BC 0000FFFF            368      and.l #$0000FFFF, d2            ; Offset Y: int
0000124A                           369                                      ; Will be used as Current Y for loop
0000124A                           370  
0000124A                           371      *| Extracting dimensions to registers for processing
0000124A  5888                     372      add.l #4, a0                    ; Push to next long
0000124C  2810                     373      move.l (a0), d4                 ; dimensions: vec2
0000124E  2A04                     374      move.l d4, d5                   ; Separate into two registers
00001250                           375  
00001250  E08C                     376      lsr.l #8, d4                    ; Width: int
00001252  E08C                     377      lsr.l #8, d4
00001254                           378  
00001254  CABC 0000FFFF            379      and.l #$0000FFFF, d5            ; Height: int
0000125A                           380  
0000125A                           381      *| Get ending x and y positions
0000125A  2C03                     382      move.l d3, d6                   ; X Offset
0000125C  DC84                     383      add.l d4, d6                    ; Plus Width
0000125E                           384                                      ; = End X Pos
0000125E                           385      
0000125E  2E02                     386      move.l d2, d7                   ; Y Offset
00001260  DE85                     387      add.l d5, d7                    ; Plus Height
00001262                           388                                      ; = End Y Pos
00001262                           389  
00001262                           390  .ClearSprite:
00001262                           391      *,__________________________________________________,
00001262                           392      *| For Loop: for x = Offset X, x < Offset X + Width, x++
00001262                           393  .ClearPixel:
00001262                           394              *| Get Background Pixel
00001262  2202                     395              move.l d2, d1   ; Get offset to pixel address of background.
00001264  C2FC 0280                396              mulu.w #SCREEN_WIDTH, d1   ; multiplied by width
00001268  D283                     397              add.l d3, d1    ; plus X offset
0000126A                           398              
0000126A  5281                     399              add.l #1, d1    ; + 1 to account for dimension data in Pixel Grid 
0000126C  E589                     400              lsl.l #2, d1    ; Multiplied by size of Long
0000126E                           401  
0000126E  264A                     402              move.l a2, a3   ; Add this to the address of the pixel grid
00001270  D7C1                     403              add.l d1, a3    ; Shifting offset to the desired pixel
00001272  2213                     404              move.l (a3), d1 ; Overwrite d1 to save register space
00001274                           405                              ; d1 now stores the hex color of the pixel
00001274                           406              
00001274                           407  .PrintBgPixel:
00001274                           408              *| Note that we set up the previous registers so all data
00001274                           409              *| is in the right location. X is in d3 but will be moved to d1
00001274                           410              *| once the first trap is done.
00001274  7050                     411              move.l #SET_PIXEL_COLOR, d0 ; TRAP Set Pen Color
00001276                           412                  
00001276                           413              ; TODO: Make backround have no alpha so we can remove this line
00001276  C2BC 00FFFFFF            414              and.l #$00FFFFFF, d1        ; Chop off alpha
0000127C                           415  
0000127C  4E4F                     416              TRAP #15
0000127E                           417  
0000127E  2203                     418              move.l d3, d1               ; Move X pos to correct register
00001280                           419                                          ; Y pos is already in correct register.   
00001280                           420                      
00001280  7052                     421              move.l #PRINT_PIXEL, d0     ; TRAP Draw Pixel
00001282                           422          
00001282  4E4F                     423              TRAP #15
00001284                           424  
00001284  5283                     425              add.l #1, d3    ; x += 1
00001286  B686                     426              cmp.l d6, d3    ; is x past end x pos?
00001288  6F00 FFD8                427              ble.l .ClearPixel ; if not, continue parsing pixels
0000128C                           428      *| End For Loop
0000128C                           429  
0000128C  9684                     430      sub.l d4, d3    ; Move x back to start location
0000128E  5383                     431      sub.l #1, d3    ; - 1 for extra space moved past width.
00001290                           432  
00001290  5282                     433      add.l #1, d2    ; y += 1
00001292  B487                     434      cmp.l d7, d2    ; Is y past end Y pos?
00001294  6300 FFCC                435      bls.l .ClearSprite  ; If not, continue to next loop
00001298                           436  
00001298                           437  .CheckEndOfSprites:
00001298  B3C8                     438      cmp.l a0, a1                    ; Is current sprite index at or past end sprite index?
0000129A  6D00 FFA0                439      blt.l .GetSprite                ; If not, let's keep on going.
0000129E                           440  
0000129E                           441      ; If we're done, we reset the clear zones as we have emptied it out
0000129E  23FC 002F930E 002F93AE   442      move.l #pixel_clear_zones, pixel_clear_length
000012A8                           443  
000012A8                           444  .Return:
000012A8                           445  
000012A8  4CDF 7FFF                446      movem.l (sp)+, ALL_REG  *| Pull registers from stack
000012AC                           447  
000012AC  4E75                     448      rts
000012AE                           449  
000012AE                           450  SwapBuffer:
000012AE  2F00                     451      move.l d0, -(sp)
000012B0                           452      
000012B0  705E                     453      move.l #SWAP_BUFFER, d0
000012B2                           454      
000012B2  4E4F                     455      TRAP #15
000012B4                           456  
000012B4  201F                     457      move.l (sp)+, d0
000012B6                           458  
000012B6  4E75                     459      rts
000012B8                           460  
000012B8                           461  -------------------- end include --------------------
000012B8                           462      INCLUDE "./inputs.x68"        ; Handles player inputs for processing
000012B8                           463  
000012B8  =0000000D                464  ENTER               EQU $D
000012B8  =0000001B                465  ESC                 EQU $1B
000012B8  =00000010                466  SHIFT               EQU $10
000012B8  =00000020                467  SPACE               EQU $20
000012B8                           468  
000012B8                           469  i_CaptureInputs:
000012B8  48E7 C0E0                470      movem.l TRAP_REG, -(sp) *| Push registers to stack
000012BC                           471  
000012BC  7013                     472      move.l #GET_KEY_INPUT_COMMAND, d0
000012BE  223C 57415344            473      move.l #'W'<<24+'A'<<16+'S'<<8+'D', d1   ; WASD Inputs
000012C4                           474      
000012C4  4E4F                     475      TRAP #15
000012C6                           476      
000012C6  2601                     477      move.l d1, d3   ; d3 stores WASD Inputs for later processing
000012C8                           478      
000012C8  223C 0D1B1020            479      move.l #ENTER<<24+ESC<<16+SHIFT<<8+SPACE, d1   ; Enter, Esc, Shift, and Space Inputs
000012CE                           480      
000012CE  4E4F                     481      TRAP #15
000012D0                           482      
000012D0  2801                     483      move.l d1, d4   ; d4 stores other Inputs for later processing
000012D2                           484      
000012D2                           485  .Return:
000012D2  4CDF 0703                486      movem.l (sp)+, TRAP_REG *| Pull registers from stack
000012D6                           487  
000012D6  4E75                     488      rts
000012D6  4E75                     489  -------------------- end include --------------------
000012D8                           490  * INCLUDE "./gameplay.x68"        ; Handles in-game timer, lap counter, and game states
000012D8                           491      INCLUDE "./physics.x68"       ; Calculates player acceleration, velocity, and collisions.
000012D8                           492  
000012D8  =00030000                493  MAX_VELOCITY        EQU $00030000
000012D8  =01680000                494  FP_360              EQU $01680000   ; Hex value for 360 degrees in 16.16 fixed point
000012D8  =00168000                495  FP_22P5             EQU $00168000   ; Hex value for 22.5 degrees in 16.16 fixed point
000012D8  =000B4000                496  FP_11P25            EQU $000B4000   ; Hex value for 11.25 degrees in 16.16 fixed point
000012D8                           497  
000012D8  =00000100                498  ACCEL_AMOUNT        EQU $00000100   ; Increases speed at 0.125 pixels per frame 
000012D8  =00000100                499  DECEL_AMOUNT        EQU $00000100   ; Increases speed at 0.0625 pixels per frame 
000012D8                           500  
000012D8  =00001000                501  MAX_SPEED           EQU $00001000
000012D8                           502  
000012D8                           503  ph_CalculateRotation:
000012D8  48E7 C0E0                504      movem.l TRAP_REG, -(sp)  *| Push registers to stack
000012DC                           505  
000012DC  2003                     506      move.l d3, d0   ; Copying WASD inputs to extract A & D
000012DE  2200                     507      move.l d0, d1
000012E0                           508  
000012E0  E088                     509      lsr.l #8, d0            ; A key input
000012E2  E088                     510      lsr.l #8, d0
000012E4  C0BC 000000FF            511      and.l #$000000FF, d0    ; Chopping off W input
000012EA                           512  
000012EA  C2BC 000000FF            513      and.l #$000000FF, d1    ; D key input
000012F0                           514  
000012F0  B280                     515      cmp.l d0, d1            ; Are A & D both pressed or not pressed?
000012F2  6700 004A                516      beq.l .Return           ; If so, let's skip to the end.
000012F6                           517  
000012F6                           518  .TurnLeft:
000012F6  B0BC 00000000            519      cmp.l #0, d0
000012FC  6700 000E                520      beq.l .TurnRight
00001300                           521  
00001300  0482 00013880            522      sub.l #00080000, d2
00001306                           523  
00001306  4EF9 00001312            524      jmp .FixAngle
0000130C                           525  
0000130C                           526  .TurnRight:
0000130C  0682 00013880            527      add.l #00080000, d2
00001312                           528      
00001312                           529  .FixAngle:
00001312  B4BC 01680000            530      cmp.l #FP_360, d2       ; Is d2 greater than 360?
00001318  6E00 0012                531      bgt.l .AngleOver
0000131C  B4BC 00000000            532      cmp.l #0, d2            ; Is d2 negative?
00001322  6D00 0014                533      blt.l .AngleUnder
00001326                           534  
00001326  4EF9 0000133E            535      jmp .Return
0000132C                           536  
0000132C                           537  .AngleOver:
0000132C  0482 01680000            538      sub.l #FP_360, d2          
00001332                           539  
00001332  4EF9 0000133E            540      jmp .Return
00001338                           541  
00001338                           542  .AngleUnder:
00001338  0682 01680000            543      add.l #FP_360, d2
0000133E                           544  
0000133E                           545  .Return
0000133E  4CDF 0703                546      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
00001342                           547  
00001342  4E75                     548      rts
00001344                           549  
00001344                           550  ph_SelectShipRotation:
00001344  48E7 C0E0                551      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001348                           552  
00001348  2002                     553      move.l d2, d0   ; Take angle to temporary variable
0000134A  7200                     554      move.l #0, d1   ; d1 stores ship index
0000134C  0480 000B4000            555      sub.l #FP_11P25, d0 ; Subtract angle by 11.25
00001352                           556  
00001352                           557  .NextRot:
00001352  5281                     558      add.l #1, d1        
00001354                           559  
00001354  0480 00168000            560      sub.l #FP_22P5, d0  ; Subtract angle by 11.25
0000135A  B0BC 00000000            561      cmp.l #0, d0        ; Is angle under 0?
00001360  6C00 FFF0                562      bge.l .NextRot      ; If not, get next rotation
00001364                           563  
00001364                           564      ; We de-increment by 1 to go back to the desired index
00001364  5381                     565      sub.l #1, d1
00001366                           566  
00001366  B2BC 00000010            567      cmp.l #16, d1       ; Is d1 greater than 15?
0000136C  6D00 0004                568      blt.l .GetFile      ; If not, we ignore the next step
00001370                           569  
00001370  7200                     570      move.l #0, d1       ; If we went past 15, we reset back to the first index
00001372                           571  
00001372                           572  .GetFile:
00001372  C2FC 0404                573      mulu.w #1028, d1     ; Multiply by size of ship's pixel grid
00001376  0681 002A9ECA            574      add.l #pg_ShipRotations, d1
0000137C  2641                     575      move.l d1, a3
0000137E                           576  
0000137E                           577  .Return
0000137E  4CDF 0703                578      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
00001382                           579  
00001382  4E75                     580      rts
00001384                           581  
00001384                           582  ph_CalcVelMagnitude:
00001384  48E7 C0E0                583      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001388                           584  
00001388  2003                     585      move.l d3, d0           ; Copying WASD inputs to extract A & D
0000138A  2200                     586      move.l d0, d1
0000138C                           587  
0000138C  E088                     588      lsr.l #8, d0            ; W key input
0000138E  E088                     589      lsr.l #8, d0
00001390  E088                     590      lsr.l #8, d0
00001392                           591  
00001392  E089                     592      lsr.l #8, d1            ; S key input
00001394  C2BC 000000FF            593      and.l #$000000FF, d1    
0000139A                           594  
0000139A  B280                     595      cmp.l d0, d1            ; Are S & S both pressed or not pressed?
0000139C  6700 0046                596      beq.l .Fric             ; If so, let's apply friction.
000013A0                           597  
000013A0  B0BC 00000000            598      cmp.l #0, d0            ; Are we accelerating?
000013A6  6700 000E                599      beq.l .Decel            ; If not, then we must be decelerating. 
000013AA                           600  
000013AA                           601  .Accel: ; Move forwards
000013AA  0687 00000100            602      add.l #ACCEL_AMOUNT, d7 
000013B0                           603  
000013B0                           604      ; if boosting, add more?
000013B0                           605  
000013B0  4EF9 000013BC            606      jmp .Clamp
000013B6                           607  
000013B6                           608  .Decel: ; Move backwards
000013B6  0487 00000100            609      sub.l #DECEL_AMOUNT, d7 
000013BC                           610  
000013BC                           611  .Clamp:
000013BC                           612  .ClampMin:
000013BC  BEBC 00000000            613      cmp.l #0, d7    
000013C2  6C00 000A                614      bge.l .ClampMax
000013C6                           615  
000013C6  7E00                     616      move.l #0, d7
000013C8                           617  
000013C8  4EF9 000013E4            618      jmp .Return
000013CE                           619  
000013CE                           620  .ClampMax:
000013CE  BEBC 00001000            621      cmp.l #MAX_SPEED, d7
000013D4  6F00 000E                622      ble.l .Return
000013D8                           623  
000013D8  2E3C 00001000            624      move.l #MAX_SPEED, d7
000013DE                           625  
000013DE  4EF9 000013E4            626      jmp .Return
000013E4                           627  
000013E4                           628  .Fric:  ; Return to 0 over time while not boosting
000013E4                           629      ; asl.l #1, d7
000013E4                           630      ; cmp.l #$FFFFFFFF, d7    ; Is d7 at its lowest possible value?
000013E4                           631      ; bne.l .Return           ; If not, skip this next step
000013E4                           632  
000013E4                           633      ; move.l #0, d7           ; Return to 0 rather than being stuck at almost -0
000013E4                           634  
000013E4                           635  .Return:
000013E4  4CDF 0703                636      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000013E8                           637  
000013E8  4E75                     638      rts
000013EA                           639  
000013EA                           640  ph_CalcVelDir:
000013EA  48E7 C0E0                641      movem.l TRAP_REG, -(sp)  *| Push registers to stack
000013EE                           642  
000013EE  2002                     643      move.l d2, d0           ; Move angle to register for processing
000013F0  E088                     644      lsr.l #8, d0
000013F2  E088                     645      lsr.l #8, d0
000013F4  80FC 0168                646      divu.w #360, d0         ; Modulo to keep within 360 degrees
000013F8  C0BC FFFF0000            647      and.l #$FFFF0000, d0
000013FE                           648      
000013FE  4EB9 00001536            649      jsr ph_Sine             ; sin
00001404                           650  
00001404                           651      ; We're done with WASD inputs so we can now use d3 for operations
00001404  2600                     652      move.l d0, d3           ; Storing sin(theta)
00001406  2002                     653      move.l d2, d0           ; Move angle to d0 again    
00001408  0680 005A0000            654      add.l #$005A0000, d0    ; Add pi / 2 to get cosine
0000140E  E088                     655      lsr.l #8, d0
00001410  E088                     656      lsr.l #8, d0
00001412  80FC 0168                657      divu.w #360, d0         ; Modulo to keep within 360 degrees
00001416  C0BC FFFF0000            658      and.l #$FFFF0000, d0
0000141C                           659  
0000141C  4EB9 00001536            660      jsr ph_Sine             ;cos
00001422                           661  
00001422                           662      ; Now d3 holds sin(theta) and d0 holds cos(theta)
00001422                           663  
00001422                           664      ; Multiply velocity magnitude by x component
00001422  2C07                     665      move.l d7, d6
00001424  E08E                     666      lsr.l #8, d6
00001426  CCBC 0000FFFF            667      and.l #$0000FFFF, d6
0000142C                           668  
0000142C  CDC3                     669      muls.w d3, d6   ; d6 now holds 8.8 x component
0000142E  E08E                     670      lsr.l #8, d6
00001430  CCBC 0000FFFF            671      and.l #$0000FFFF, d6 ; Reduce to 4.4
00001436  2606                     672      move.l d6, d3   ; Store x component in d3
00001438  E18B                     673      lsl.l #8, d3
0000143A  E18B                     674      lsl.l #8, d3    ; Move over to left side for eventual merge
0000143C                           675  
0000143C                           676      ; Multiply velocity magnitude by y component    
0000143C  2C07                     677      move.l d7, d6
0000143E  E08E                     678      lsr.l #8, d6
00001440  CCBC 0000FFFF            679      and.l #$0000FFFF, d6
00001446                           680      
00001446  CDC0                     681      muls.w d0, d6   ; d5 now holds 8.8 y component
00001448  E08E                     682      lsr.l #8, d6
0000144A  CCBC 0000FFFF            683      and.l #$0000FFFF, d6 ; Reduce to 4x4
00001450  2006                     684      move.l d6, d0   ; Store y component in d0
00001452                           685      
00001452  8083                     686      or.l d3, d0 ; Merge x and y to form final vector
00001454                           687  
00001454  2C00                     688      move.l d0, d6   ; Move final result to final location for processing
00001456                           689  
00001456                           690  .Return:
00001456  4CDF 0703                691      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
0000145A                           692  
0000145A  4E75                     693      rts
0000145C                           694  
0000145C                           695  ph_CalculatePosition:
0000145C  48E7 C0E0                696      movem.l TRAP_REG, -(sp)  *| Push registers to stack
00001460                           697  
00001460  2006                     698      move.l d6, d0
00001462  2200                     699      move.l d0, d1
00001464                           700  
00001464  E088                     701      lsr.l #8, d0
00001466  E088                     702      lsr.l #8, d0
00001468  C2BC 0000FFFF            703      and.l #$0000FFFF, d1
0000146E                           704  
0000146E                           705  .negX:
0000146E  B07C 0000                706      cmp.w #0, d0    ; Is d0 less than zero?
00001472  6C00 000E                707      bge.l .posX 
00001476                           708  
00001476  4440                     709      neg.w d0
00001478                           710  
00001478                           711      ; If so, let's transform to 16.16 
00001478  E188                     712      lsl.l #8, d0
0000147A  4480                     713      neg.l d0
0000147C                           714  
0000147C  4EF9 00001484            715      jmp .negY
00001482                           716  
00001482                           717  .posX:
00001482  E188                     718      lsl.l #8, d0
00001484                           719  
00001484                           720  .negY:
00001484  B07C 0000                721      cmp.w #0, d0    ; Is d0 less than zero?
00001488  6C00 000E                722      bge.l .posY
0000148C                           723  
0000148C  4441                     724      neg.w d1
0000148E                           725  
0000148E                           726      ; If so, let's transform to 16.16 
0000148E  E189                     727      lsl.l #8, d1
00001490  4481                     728      neg.l d1
00001492                           729  
00001492  4EF9 0000149A            730      jmp .updatePos
00001498                           731  
00001498                           732  .posY:
00001498  E189                     733      lsl.l #8, d1
0000149A                           734  
0000149A                           735  .updatePos:
0000149A                           736      ; Update precise ship position
0000149A  287C 0000167A            737      move.l #ShipPosition, a4
000014A0                           738  
000014A0  D094                     739      add.l (a4), d0  ; Ship X Position 
000014A2  588C                     740      add.l #4, a4
000014A4  D294                     741      add.l (a4), d1  ; Ship Y Position
000014A6                           742  
000014A6  2881                     743      move.l d1, (a4)
000014A8  598C                     744      sub.l #4, a4
000014AA  2880                     745      move.l d0, (a4)
000014AC                           746  
000014AC                           747      ; Now, update integer ship position (pixel)
000014AC                           748  
000014AC  C0BC FFFF0000            749      and.l #$FFFF0000, d0    ; X is already in position
000014B2  E089                     750      lsr.l #8, d1            ; Y is shifted right, for once.
000014B4  E089                     751      lsr.l #8, d1
000014B6                           752  
000014B6  8280                     753      or.l d0, d1
000014B8                           754  
000014B8  2A01                     755      move.l d1, d5
000014BA                           756  
000014BA                           757  .Return:
000014BA  4CDF 0703                758      movem.l (sp)+, TRAP_REG  *| Pull registers from stack
000014BE                           759  
000014BE  4E75                     760      rts
000014C0                           761  
000014C0                           762  ph_ClampNumber:
000014C0  2F02                     763      move.l d2, -(sp) ; Temporarily move d2 out of the way
000014C2                           764  
000014C2  2401                     765      move.l d1, d2
000014C4  E089                     766      lsr.l #8, d1
000014C6  E089                     767      lsr.l #8, d1
000014C8  C4BC 0000FFFF            768      and.l #$0000FFFF, d2
000014CE                           769  
000014CE                           770      *| Compare by word here because it is signed 
000014CE  B041                     771      cmp.w d1, d0    ; Is value less than min?
000014D0  6D00 000E                772      blt .Under    
000014D4                           773      
000014D4  B042                     774      cmp.w d2, d0    ; Is value greater than max?
000014D6  6E00 0010                775      bgt.l .Over
000014DA                           776  
000014DA  4EF9 000014F0            777      jmp .Return     ; Within range, do nothing
000014E0                           778  
000014E0                           779  .Under:     ; We need to clamp value to min
000014E0  2001                     780      move.l d1, d0
000014E2                           781  
000014E2  4EF9 000014F0            782      jmp .Return
000014E8                           783  
000014E8                           784  .Over:      ; We need to clamp value to max
000014E8  2002                     785      move.l d2, d0
000014EA                           786  
000014EA  4EF9 000014F0            787      jmp .Return
000014F0                           788  
000014F0                           789  .Return:
000014F0  241F                     790      move.l (sp)+, d2
000014F2                           791  
000014F2  4E75                     792      rts
000014F4                           793  
000014F4                           794  ph_ClampVector:
000014F4  2F02                     795      move.l d2, -(sp)    ; Temporarily move d2 out of the way
000014F6  2F03                     796      move.l d3, -(sp)    ; Temporarily move d3 out of the way
000014F8                           797  
000014F8  2401                     798      move.l d1, d2       ; Extract X & Y value of vector
000014FA  2602                     799      move.l d2, d3
000014FC  E08A                     800      lsr.l #8, d2
000014FE  E08A                     801      lsr.l #8, d2
00001500  C6BC 0000FFFF            802      and.l #$0000FFFF, d3
00001506                           803  
00001506  C5C2                     804      muls.w d2, d2   ; x ^ 2
00001508  C7C3                     805      muls.w d3, d3   ; y ^ 2
0000150A  D682                     806      add.l d2, d3    ; x ^ 2 + y ^ 2 = c ^ 2
0000150C                           807  
0000150C                           808      ; (x ^ 2) + (y ^ 2) must be converted from 16.16 to 8.8
0000150C  E08B                     809      lsr.l #8, d3
0000150E  C6BC 0000FFFF            810      and.l #$0000FFFF, d3
00001514                           811  
00001514  B680                     812      cmp.l d0, d3    ; Is magnitude greater than max?
00001516  6F00 0018                813      ble.l .Return   ; If not, carry on as usual
0000151A                           814  
0000151A                           815      ; If so, let's CUT IT IN HALF muahahaha
0000151A  2401                     816      move.l d1, d2
0000151C                           817  
0000151C  E08A                     818      lsr.l #8, d2
0000151E  E08A                     819      lsr.l #8, d2
00001520  C2BC 0000FFFF            820      and.l #$0000FFFF, d1
00001526                           821      
00001526  E242                     822      asr.w #1, d2            ; X
00001528  E241                     823      asr.w #1, d1            ; Y
0000152A                           824      
0000152A  E18A                     825      lsl.l #8, d2
0000152C  E18A                     826      lsl.l #8, d2
0000152E                           827  
0000152E  8282                     828      or.l d2, d1
00001530                           829  
00001530                           830  .Return:
00001530  261F                     831      move.l (sp)+, d3
00001532  241F                     832      move.l (sp)+, d2
00001534                           833  
00001534  4E75                     834      rts
00001536                           835  
00001536                           836  ph_Sine:
00001536  E088                     837      lsr.l #8, d0
00001538  E088                     838      lsr.l #8, d0        ; Chopping off fractional
0000153A                           839  
0000153A  B0BC 0000005A            840      cmp.l #90, d0       ; Is the angle greater than 90?
00001540  6D00 001C                841      blt.l .Q1           ; If not, we're in quadrant 1
00001544                           842      
00001544  B0BC 000000B4            843      cmp.l #180, d0      ; Is the angle greater than 180?
0000154A  6D00 0024                844      blt.l .Q2           ; If not, we're in quadrant 2
0000154E                           845  
0000154E  B0BC 0000010E            846      cmp.l #270, d0      ; Is the angle greater than 270?
00001554  6D00 0038                847      blt.l .Q3           ; If not, we're in quadrant 3
00001558                           848      
00001558  4EF9 000015A8            849      jmp .Q4             ; We are in quadrant 4 by process of elimination
0000155E                           850  
0000155E                           851  .Q1:    ; Quadrant 1
0000155E  E388                     852      lsl.l #1, d0        ; Multiply by 2 (length of word)
00001560                           853  
00001560  207C 000015C4            854      move.l #sinTable, a0
00001566  D1C0                     855      add.l d0, a0        ; Offset to desired index of sin table
00001568                           856  
00001568  3010                     857      move.w (a0), d0     ; Extract fractional
0000156A                           858  
0000156A  4EF9 000015C2            859      jmp .Return
00001570                           860  
00001570                           861  .Q2:    ; Quadrant 2
00001570  0480 0000005A            862      sub.l #90, d0       ; Start at 90 degrees
00001576  E388                     863      lsl.l #1, d0        ; Multiply by 2 (length of word)
00001578                           864  
00001578  207C 000015C4            865      move.l #sinTable, a0
0000157E  D1FC 000000B4            866      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
00001584  91C0                     867      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
00001586                           868  
00001586  3010                     869      move.w (a0), d0     ; Extract fractional
00001588                           870  
00001588  4EF9 000015C2            871      jmp .Return
0000158E                           872  
0000158E                           873  .Q3:    ; Quadrant 3
0000158E  0480 000000B4            874      sub.l #180, d0       ; Start at 180 degrees
00001594  E388                     875      lsl.l #1, d0        ; Multiply by 2 (length of word)
00001596                           876  
00001596  207C 000015C4            877      move.l #sinTable, a0
0000159C  D1C0                     878      add.l d0, a0        ; Offset to desired index of sin table
0000159E                           879  
0000159E  3010                     880      move.w (a0), d0     ; Extract fractional
000015A0  4440                     881      neg.w d0            ; Flip to negative
000015A2                           882  
000015A2  4EF9 000015C2            883      jmp .Return
000015A8                           884  
000015A8                           885  .Q4:    ; Quadrant 4
000015A8  0480 0000010E            886      sub.l #270, d0       ; Start at 90 degrees
000015AE  E388                     887      lsl.l #1, d0         ; Multiply by 2 (length of word)
000015B0                           888  
000015B0  207C 000015C4            889      move.l #sinTable, a0
000015B6  D1FC 000000B4            890      add.l #SINTABLESIZE, a0 ; Moving index to end of array since we're working backwards
000015BC  91C0                     891      sub.l d0, a0        ; Offset to desired index of sin table (backwards)
000015BE                           892  
000015BE  3010                     893      move.w (a0), d0     ; Extract fractional
000015C0                           894  
000015C0  4440                     895      neg.w d0            ; Flip to negative
000015C2                           896  
000015C2                           897  .Return:
000015C2                           898  
000015C2  4E75                     899      rts
000015C4                           900  
000015C4= 0000 0047 008E 0...      901  sinTable        dc.w    $0,$47,$8E,$D6,$11D,$164,$1AC,$1F3,$23A,$280,$2C7
000015DA= 030D 0353 0399 0...      902                  dc.w    $30D,$353,$399,$3DE,$424,$469,$4AD,$4F1,$535
000015EC= 0578 05BB 05FE 0...      903                  dc.w    $578,$5BB,$5FE,$640,$681,$6C3,$703,$743,$782
000015FE= 07C1 07FF 083D 0...      904                  dc.w    $7C1,$7FF,$83D,$87A,$8B6,$8F2,$92D,$967,$9A1
00001610= 09D9 0A11 0A48 0...      905                  dc.w    $9D9,$A11,$A48,$A7F,$AB4,$AE9,$B1D,$B50,$B82
00001622= 0BB3 0BE3 0C13 0...      906                  dc.w    $BB3,$BE3,$C13,$C41,$C6F,$C9B,$CC7,$CF1,$D1B
00001634= 0D43 0D6B 0D91 0...      907                  dc.w    $D43,$D6B,$D91,$DB6,$DDB,$DFE,$E20,$E41,$E61
00001646= 0E80 0E9D 0EBA 0...      908                  dc.w    $E80,$E9D,$EBA,$ED5,$EEF,$F08,$F20,$F37,$F4D
00001658= 0F61 0F74 0F86 0...      909                  dc.w    $F61,$F74,$F86,$F97,$FA6,$FB4,$FC1,$FCD,$FD8
0000166A= 0FE1 0FE9 0FF0 0...      910                  dc.w    $FE1,$FE9,$FF0,$FF6,$FFA,$FFD,$FFF,$FFF
0000167A                           911  
0000167A  =000000B4                912  SINTABLESIZE            EQU 180 ; 90 * 2 (word size)
0000167A                           913  
0000167A= 02210000 012C0000        914  ShipPosition        dc.l $02210000,$012C0000  ; Position in 16.16 fixed point
00001682                           915  
00001682                           916  -------------------- end include --------------------
00001682                           917      INCLUDE "./display.x68"       ; Displays a 7-segment LED with the given parameters.
00001682                           918  
00001682  =02540014                919  LAP_DISPLAY_OFFSET          EQU $02540014
00001682  =00050014                920  TIMER_1_DISPLAY_OFFSET      EQU $00050014
00001682  =001A0014                921  TIMER_2_DISPLAY_OFFSET      EQU $001A0014
00001682  =00370014                922  TIMER_3_DISPLAY_OFFSET      EQU $00370014
00001682  =004C0014                923  TIMER_4_DISPLAY_OFFSET      EQU $004C0014
00001682                           924  
00001682                           925  ss_InitDisplays:
00001682  48E7 FFFE                926      movem.l ALL_REG, -(sp) *| Push registers to stack
00001686                           927  
00001686                           928      *| Setting up lap counter
00001686  207C 00001A2C            929      move.l #ssd_Lap, a0
0000168C  20BC 02540014            930      move.l #LAP_DISPLAY_OFFSET, (a0)
00001692  7000                     931      move.l #0, d0
00001694                           932  
00001694  4EB9 000016DC            933      jsr ss_SevenSegUpdate
0000169A                           934  
0000169A                           935      *| Setting up timer counters, from leftmost to rightmost
0000169A  207C 00001A34            936      move.l #ssd_Timer, a0
000016A0  20BC 00050014            937      move.l #TIMER_1_DISPLAY_OFFSET, (a0)
000016A6                           938  
000016A6  4EB9 000016DC            939      jsr ss_SevenSegUpdate
000016AC                           940  
000016AC  5088                     941      add.l #8, a0    ; Move a0 to next display in timer
000016AE                           942  
000016AE  20BC 001A0014            943      move.l #TIMER_2_DISPLAY_OFFSET, (a0)
000016B4                           944  
000016B4  4EB9 000016DC            945      jsr ss_SevenSegUpdate
000016BA                           946          
000016BA  5088                     947      add.l #8, a0    ; Move a0 to next display in timer
000016BC                           948  
000016BC  20BC 00370014            949      move.l #TIMER_3_DISPLAY_OFFSET, (a0)
000016C2                           950  
000016C2  4EB9 000016DC            951      jsr ss_SevenSegUpdate
000016C8                           952  
000016C8  5088                     953      add.l #8, a0    ; Move a0 to next display in timer
000016CA                           954  
000016CA  20BC 004C0014            955      move.l #TIMER_4_DISPLAY_OFFSET, (a0)
000016D0                           956  
000016D0  4EB9 000016DC            957      jsr ss_SevenSegUpdate
000016D6                           958  .Return:
000016D6  4CDF 7FFF                959      movem.l (sp)+, ALL_REG  *| Pull registers from stack
000016DA                           960  
000016DA  4E75                     961      rts
000016DC                           962  
000016DC                           963  ss_SevenSegUpdate:
000016DC  48E7 FFFE                964      movem.l ALL_REG, -(sp) *| Push registers to stack
000016E0                           965  
000016E0                           966      ; Get table value
000016E0  227C 00001A22            967      move.l #SevenSegTable, a1
000016E6  D3C0                     968      add.l d0, a1            ; Offset to bitmask
000016E8  1411                     969      move.b (a1), d2
000016EA                           970  
000016EA                           971      ; Update bitmask
000016EA  2248                     972      move.l a0, a1
000016EC  5889                     973      add.l #4, a1            ; Move to next long
000016EE  3282                     974      move.w d2, (a1)         ; Move by word to prevent misalignment
000016F0  5489                     975      add.l #2, a1            ; Move to next word
000016F2  3280                     976      move.w d0, (a1)         ; Put the actual number in for reference
000016F4                           977  
000016F4                           978      ; Wipe other old sprites because sprite clearing only works one image at a time (needs fixing!)
000016F4  4EB8 1220                979      jsr r_ClearSprites
000016F8                           980  
000016F8                           981      ; Mark new clear zone
000016F8  2610                     982      move.l (a0), d3
000016FA                           983      
000016FA  2279 002F93AE            984      move.l pixel_clear_length, a1
00001700  2283                     985      move.l d3, (a1)                     ; Move image offset to pixel_clear_zones
00001702  5889                     986      add.l #4, a1                        ; Move to next word
00001704  22BC 0012001F            987      move.l #SEVEN_SEG_DIMENSIONS, (a1)  ; Move image dimensions to pixel_clear_zones
0000170A  50B9 002F93AE            988      add.l #8, pixel_clear_length        ; Move to next word
00001710                           989  
00001710                           990      ; Call an early sprite clear
00001710  4EB8 1220                991      jsr r_ClearSprites
00001714                           992  
00001714                           993      ; Print new display value
00001714                           994      *| Note: A lot of this is necessary boilerplate, 
00001714                           995      *| but also consistent across all 7-seg displays.
00001714                           996  .PrintSegments:
00001714  283C 00000080            997      move.l #%10000000, d4   ; Starting bit to check
0000171A  7200                     998      move.l #0, d1           ; Are not immediately removed
0000171C                           999  .First:
0000171C  2002                    1000      move.l d2, d0
0000171E  C084                    1001      and.l d4, d0
00001720  B084                    1002      cmp.l d4, d0
00001722  6600 0014               1003      bne.l .Second           ; Skip to second
00001726                          1004      
00001726  2003                    1005      move.l d3, d0
00001728  0680 00030000           1006      add.l #$00030000, d0    ; + Local Position
0000172E  207C 002F94BE           1007      move.l #pg_7SegHorizontal, a0
00001734  4EB8 1198               1008      jsr r_PrintImage
00001738                          1009  
00001738                          1010  .Second:    
00001738  E28C                    1011      lsr.l #1, d4            ; Get next bit to check
0000173A  2002                    1012      move.l d2, d0
0000173C  C084                    1013      and.l d4, d0
0000173E  B084                    1014      cmp.l d4, d0 
00001740  6600 0010               1015      bne.l .Third            ; Skip to third
00001744                          1016         
00001744  2003                    1017      move.l d3, d0
00001746  5680                    1018      add.l #$00000003, d0    ; + Local Position
00001748  207C 002F93BA           1019      move.l #pg_7SegVertical, a0
0000174E  4EB8 1198               1020      jsr r_PrintImage
00001752                          1021  
00001752                          1022  .Third:
00001752  E28C                    1023      lsr.l #1, d4            ; Get next bit to check
00001754  2002                    1024      move.l d2, d0
00001756  C084                    1025      and.l d4, d0
00001758  B084                    1026      cmp.l d4, d0 
0000175A  6600 0014               1027      bne.l .Fourth           ; Skip to fourth
0000175E                          1028  
0000175E  2003                    1029      move.l d3, d0
00001760  0680 000F0003           1030      add.l #$000F0003, d0    ; + Local Position
00001766  207C 002F93BA           1031      move.l #pg_7SegVertical, a0
0000176C  4EB8 1198               1032      jsr r_PrintImage
00001770                          1033  
00001770                          1034  .Fourth:
00001770  E28C                    1035      lsr.l #1, d4            ; Get next bit to check
00001772  2002                    1036      move.l d2, d0
00001774  C084                    1037      and.l d4, d0
00001776  B084                    1038      cmp.l d4, d0 
00001778  6600 0014               1039      bne.l .Fifth            ; Skip to fifth
0000177C                          1040  
0000177C  2003                    1041      move.l d3, d0
0000177E  0680 0003000E           1042      add.l #$0003000E, d0    ; + Local Position
00001784  207C 002F94BE           1043      move.l #pg_7SegHorizontal, a0
0000178A  4EB8 1198               1044      jsr r_PrintImage
0000178E                          1045  
0000178E                          1046  .Fifth:
0000178E  E28C                    1047      lsr.l #1, d4            ; Get next bit to check
00001790  2002                    1048      move.l d2, d0
00001792  C084                    1049      and.l d4, d0
00001794  B084                    1050      cmp.l d4, d0 
00001796  6600 0014               1051      bne.l .Sixth            ; Skip to sixth
0000179A                          1052  
0000179A  2003                    1053      move.l d3, d0
0000179C  0680 00000010           1054      add.l #$00000010, d0    ; + Local Position
000017A2  207C 002F93BA           1055      move.l #pg_7SegVertical, a0
000017A8  4EB8 1198               1056      jsr r_PrintImage
000017AC                          1057  
000017AC                          1058  .Sixth:
000017AC  E28C                    1059      lsr.l #1, d4            ; Get next bit to check
000017AE  2002                    1060      move.l d2, d0
000017B0  C084                    1061      and.l d4, d0
000017B2  B084                    1062      cmp.l d4, d0 
000017B4  6600 0014               1063      bne.l .Seventh          ; Skip to seventh
000017B8                          1064  
000017B8  2003                    1065      move.l d3, d0
000017BA  0680 000F0010           1066      add.l #$000F0010, d0    ; + Local Position
000017C0  207C 002F93BA           1067      move.l #pg_7SegVertical, a0
000017C6  4EB8 1198               1068      jsr r_PrintImage
000017CA                          1069  
000017CA                          1070  .Seventh:
000017CA  E28C                    1071      lsr.l #1, d4
000017CC  2002                    1072      move.l d2, d0
000017CE  C084                    1073      and.l d4, d0
000017D0  B084                    1074      cmp.l d4, d0 
000017D2  6600 0014               1075      bne.l .Return           ; Skip to end
000017D6                          1076  
000017D6  2003                    1077      move.l d3, d0
000017D8  0680 0003001C           1078      add.l #$0003001C, d0    ; + Local Position
000017DE  207C 002F94BE           1079      move.l #pg_7SegHorizontal, a0
000017E4  4EB8 1198               1080      jsr r_PrintImage
000017E8                          1081  
000017E8                          1082  .Return:
000017E8  4CDF 7FFF               1083      movem.l (sp)+, ALL_REG  *| Pull registers from stack
000017EC                          1084  
000017EC  4E75                    1085      rts
000017EE                          1086  
000017EE                          1087  SevenSegVerticalBmpFile     INCBIN "../resources/7SegVertical.bmp"
00001908                          1088  SevenSegHorizontalBmpFile   INCBIN "../resources/7SegHorizontal.bmp"
00001A22                          1089  
00001A22                          1090  ; A table containing bytes where each bit represents on or off
00001A22                          1091  ; for a segment on the display. Table starts at 0 and ends at 9
00001A22= EE 24 BA                1092  SevenSegTable       dc.b %11101110,%00100100,%10111010
00001A25= B6 74 D6                1093                      dc.b %10110110,%01110100,%11010110
00001A28= DE A4 FE F4             1094                      dc.b %11011110,%10100100,%11111110,%11110100
00001A2C                          1095  
00001A2C                          1096  ssd_Lap         ds.l 2
00001A34                          1097  ssd_Timer       ds.l 8
00001A34                          1098  -------------------- end include --------------------
00001A54                          1099  
00001A54                          1100  *,__________________________________________________,
00001A54                          1101  *| fn Main
00001A54                          1102  *| Description: Loads files, sets game state, begins
00001A54                          1103  *|              game loop, and handles quit state
00002000                          1104  START ORG $2000
00002000                          1105  Main:
00002000                          1106      ; Initialize pixel_clear_length
00002000  23FC 002F930E 002F93AE  1107      move.l #pixel_clear_zones, pixel_clear_length
0000200A                          1108  
0000200A  705C                    1109      move.l #92, d0
0000200C  7211                    1110      move.l #17, d1
0000200E                          1111      
0000200E  4E4F                    1112      TRAP #15
00002010                          1113  
00002010  4EB8 1000               1114      jsr fl_LoadFiles
00002014                          1115      
00002014  7000                    1116      move.l #$00000000, d0   ; Position has no offset
00002016  7200                    1117      move.l #$00000000, d1   ; This is not a sprite, it's the background
00002018  7400                    1118      move.l #$00000000, d2
0000201A  207C 0017DEC6           1119      move.l #pg_Background, a0
00002020  4EB8 1198               1120      jsr r_PrintImage
00002024                          1121      
00002024  4EB8 1682               1122      jsr ss_InitDisplays
00002028                          1123      
00002028                          1124      ; Set up start variables for game loop
00002028  2A3C 0221012C           1125      move.l #$0221012C, d5   ; Start position of ship
0000202E                          1126  
0000202E  7008                    1127      move.l #GET_TIME, d0    ; Get current time (start of game time)
00002030  4E4F                    1128      TRAP #15
00002032                          1129  
00002032  23C1 000021D8           1130      move.l d1, LastSecond    ; This time is the start of the game
00002038                          1131  
00002038  4EB9 00002042           1132      jsr GameLoop
0000203E                          1133  
0000203E  4E72 3000               1134      STOP #$3000
00002042                          1135  *| [End of Function] Main
00002042                          1136  *|__________________________________________________
00002042                          1137  *`                                                  `
00002042                          1138  
00002042                          1139  *,__________________________________________________,
00002042                          1140  *| fn GameLoop
00002042                          1141  *| Description: Perpetually runs game until the quit 
00002042                          1142  *| command is given.
00002042                          1143  *| Persistent Variables:
00002042                          1144  *| d2: Rotation, DeltaTime 
00002042                          1145  *| d3: WASD Inputs, d4: Enter, Esc, Shift, and Space Inputs
00002042                          1146  *| d5: Position, d6: Velocity, d7: Acceleration
00002042                          1147  *| a3: Ship model to use
00002042                          1148  GameLoop:
00002042  7008                    1149      move.l #8, d0  ; Time Code - maybe reuse later?
00002044                          1150  
00002044  4E4F                    1151      TRAP #15
00002046                          1152  
00002046  4EB9 000020B4           1153      jsr UpdateTimer         ; Updates the in-game timer if a second has passed
0000204C                          1154  
0000204C  2001                    1155      move.l d1, d0
0000204E  90B9 000021D4           1156      sub.l LastTime, d0
00002054  B0BC 00000005           1157      cmp.l #5, d0            ; Is time elapsed less than 5/100ths of a second?
0000205A  6300 FFE6               1158      bls.l GameLoop          ; If not, wait
0000205E  23C1 000021D4           1159      move.l d1, LastTime     ; Otherwise, this is the new last time
00002064                          1160  
00002064                          1161      *,___________________________,
00002064                          1162      *| STAGE ONE: Capture Inputs |
00002064                          1163      *|___________________________|
00002064                          1164      *`                           ` 
00002064  4EB8 12B8               1165      jsr i_CaptureInputs   ; Fills registers d3-d4 (destructively) with player inputs
00002068                          1166  
00002068                          1167      *,___________________________,
00002068                          1168      *| STAGE TWO: Physics Pass   |
00002068                          1169      *|___________________________|
00002068                          1170      *`                           `
00002068  4EB8 12D8               1171      jsr ph_CalculateRotation
0000206C  4EB8 1344               1172      jsr ph_SelectShipRotation
00002070                          1173  
00002070  4EB8 1384               1174      jsr ph_CalcVelMagnitude
00002074  4EB8 13EA               1175      jsr ph_CalcVelDir
00002078  4EB8 145C               1176      jsr ph_CalculatePosition
0000207C                          1177  
0000207C  4EB9 00002108           1178      jsr cl_CheckCollisions
00002082                          1179  
00002082                          1180      *,___________________________,
00002082                          1181      *| STAGE THREE: Rendering    |
00002082                          1182      *|___________________________|
00002082                          1183      *`                           `
00002082                          1184      ; Clear old sprites from screen
00002082  4EB8 1220               1185      jsr r_ClearSprites ; Wipe sprites from screen
00002086                          1186  
00002086                          1187      ; Render ship
00002086                          1188      ; move.l #pg_Ship, a0
00002086  204B                    1189      move.l a3, a0   ; Move ship image address to the correct location
00002088  2005                    1190      move.l d5, d0   ; Move position to offset
0000208A  4EB8 1198               1191      jsr r_PrintImage
0000208E                          1192  
0000208E                          1193      ; Swap Buffer
0000208E  4EB8 12AE               1194      jsr SwapBuffer
00002092                          1195  
00002092  0C79 0001 002F93B2      1196      cmp.w #1, flag_IsDead   ; did player die?
0000209A  6700 0016               1197      beq.l .Return  ; If so, end loop
0000209E                          1198  
0000209E  C8BC 00FF0000           1199      and.l #$00FF0000, d4
000020A4  B8BC 00FF0000           1200      cmp.l #$00FF0000, d4    ; Did player press ESC?
000020AA  6700 0006               1201      beq.l .Return  ; If so, continue loop
000020AE                          1202  
000020AE  4EF8 2042               1203      jmp GameLoop
000020B2                          1204  
000020B2                          1205  .Return:
000020B2                          1206  
000020B2  4E75                    1207      rts
000020B4                          1208  *| [End of Function] GameLoop
000020B4                          1209  *|__________________________________________________
000020B4                          1210  *`                                                  `
000020B4                          1211  
000020B4                          1212  *,__________________________________________________,
000020B4                          1213  *| fn UpdateTimer
000020B4                          1214  *| Description: Checks if a second has passed to update
000020B4                          1215  *| the timer
000020B4                          1216  *| Inputs: d1: Current Time
000020B4                          1217  UpdateTimer:
000020B4  48E7 FFFE               1218      movem.l ALL_REG, -(sp)  *| Push registers to stack
000020B8                          1219  
000020B8  2001                    1220      move.l d1, d0
000020BA  90B9 000021D8           1221      sub.l LastSecond, d0
000020C0  B0BC 00000064           1222      cmp.l #100, d0          ; Is time elapsed 1 second?
000020C6  6300 003A               1223      bls.l .Return            ; If not, carry on as normal
000020CA                          1224  
000020CA  23C1 000021D8           1225      move.l d1, LastSecond   ; Otherwise, we're now in the next second
000020D0                          1226  
000020D0  4280                    1227      clr.l d0                ; clear d0 for next step
000020D2                          1228  
000020D2  207C 00001A34           1229      move.l #ssd_Timer, a0   ; Let's now update the timer
000020D8  D1FC 00000018           1230      add.l #24, a0           ; Offset to 4th display (00:0X)
000020DE                          1231  
000020DE                          1232  .AddSecond:
000020DE  5C88                    1233      add.l #6, a0            ; Offset to actual number
000020E0  3010                    1234      move.w (a0), d0         ; Grab number
000020E2  5280                    1235      add.l #1, d0            ; Increment by 1
000020E4  B0BC 00000009           1236      cmp.l #9, d0            ; Has its number gone over 9?
000020EA  6F00 0010               1237      ble.l .EndOverflow      ; If not, we're done.
000020EE                          1238  
000020EE                          1239      ; Otherwise, we overflow to the next display
000020EE  5D88                    1240      sub.l #6, a0            ; offset to start of current display
000020F0  7000                    1241      move.l #0, d0           ; New number in display must be 0
000020F2  4EB8 16DC               1242      jsr ss_SevenSegUpdate
000020F6                          1243  
000020F6  5188                    1244      sub.l #8, a0            ; offset to start of last display
000020F8  4EF8 20DE               1245      jmp .AddSecond          ; Continue loop
000020FC                          1246  
000020FC                          1247  .EndOverflow:
000020FC  5D88                    1248      sub.l #6, a0            ; Offset back to start of display addr
000020FE  4EB8 16DC               1249      jsr ss_SevenSegUpdate   ; Print this display's new number
00002102                          1250  
00002102                          1251  .Return:
00002102  4CDF 7FFF               1252      movem.l (sp)+, ALL_REG  *| Pull registers from stack
00002106                          1253  
00002106  4E75                    1254      rts
00002108                          1255  *| [End of Function] UpdateTimer
00002108                          1256  *|__________________________________________________
00002108                          1257  *`                                                  `
00002108                          1258  
00002108                          1259  *,__________________________________________________,
00002108                          1260  *| [Collisions] fn CheckCollisions
00002108                          1261  *| Description: Checks what material the player is on
00002108                          1262  cl_CheckCollisions:
00002108                          1263      ; Check root of ship location
00002108  2005                    1264      move.l d5, d0
0000210A  4EB9 00002154           1265      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
00002110  4EB9 00002178           1266      jsr cl_ProcessMaterial
00002116                          1267  
00002116                          1268      ; Check top right corner
00002116  2005                    1269      move.l d5, d0
00002118  0680 000F0000           1270      add.l #$000F0000, d0
0000211E  4EB9 00002154           1271      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
00002124  4EB9 00002178           1272      jsr cl_ProcessMaterial
0000212A                          1273  
0000212A                          1274      ; Check bottom left corner
0000212A  2005                    1275      move.l d5, d0
0000212C  0680 0000000F           1276      add.l #$0000000F, d0
00002132  4EB9 00002154           1277      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
00002138  4EB9 00002178           1278      jsr cl_ProcessMaterial
0000213E                          1279  
0000213E                          1280      ; Check bottom right corner
0000213E  2005                    1281      move.l d5, d0
00002140  0680 000F000F           1282      add.l #$000F000F, d0
00002146  4EB9 00002154           1283      jsr cl_GetCollisionMaterial     ; d0 is now filled with material
0000214C  4EB9 00002178           1284      jsr cl_ProcessMaterial
00002152                          1285  
00002152                          1286  .Return:
00002152                          1287  
00002152  4E75                    1288      rts
00002154                          1289  *| [End of Function] CheckCollisions
00002154                          1290  *|__________________________________________________
00002154                          1291  *`                                                  `
00002154                          1292  
00002154                          1293  *,__________________________________________________,
00002154                          1294  *| [Collisions] fn GetCollisionMaterial
00002154                          1295  *| Description: Check what material is at a particular pixel address
00002154                          1296  *| Input: d0: coordintaes (w1: x, w2: y)
00002154                          1297  cl_GetCollisionMaterial:
00002154  2200                    1298      move.l d0, d1
00002156  E088                    1299      lsr.l #8, d0            ; X
00002158  E088                    1300      lsr.l #8, d0
0000215A  C2BC 0000FFFF           1301      and.l #$0000FFFF, d1    ; Y
00002160                          1302  
00002160  C2FC 0280               1303      mulu.w #SCREEN_WIDTH, d1    ; Y * Screen Width
00002164  D280                    1304      add.l d0, d1                ; + X = Index
00002166                          1305  
00002166  207C 002AE30E           1306      move.l #cm_Road, a0
0000216C  D1C1                    1307      add.l d1, a0                ; Offset to material
0000216E                          1308  
0000216E  1010                    1309      move.b (a0), d0             ; Grab material
00002170  C0BC 000000FF           1310      and.l #$000000FF, d0            ; Cut off leftmost bits
00002176                          1311  
00002176                          1312  .Return:
00002176                          1313  
00002176  4E75                    1314      rts
00002178                          1315  *| [End of Function] GetCollisionMaterial
00002178                          1316  *|__________________________________________________
00002178                          1317  *`                                                  `
00002178                          1318  
00002178                          1319  *,__________________________________________________,
00002178                          1320  *| [Collisions] fn ProcessMaterial
00002178                          1321  *| Description: Check what material is at a particular pixel address
00002178                          1322  *| Input: d0: material
00002178                          1323  cl_ProcessMaterial:
00002178                          1324  .Offroad:
00002178  B0BC 00000000           1325      cmp.l #0, d0    ; Offroad?
0000217E  6600 0010               1326      bne.l .Lap
00002182                          1327  
00002182  33FC 0001 002F93B2      1328      move.w #1, flag_IsDead  ; You're dead!
0000218A  4EF9 000021D2           1329      jmp .Return
00002190                          1330  
00002190                          1331  .Lap:
00002190  B0BC 00000002           1332      cmp.l #2, d0    ; On the lap?
00002196  6600 001C               1333      bne.l .MidLap
0000219A                          1334  
0000219A  0C79 0000 002F93B6      1335      cmp.w #0, flag_CanLap   ; Are we in a valid lap state?
000021A2  6700 002E               1336      beq.l .Return           ; If not, invalid
000021A6                          1337  
000021A6  52B9 002F93B8           1338      add.l #1, i_CurrentLap  ; Lap += 1 (TODO: Update lap UI)
000021AC  33FC 0000 002F93B6      1339      move.w #0, flag_CanLap  ; CanLap = false
000021B4                          1340  
000021B4                          1341  .MidLap:
000021B4  B0BC 00000003           1342      cmp.l #3, d0    ; On the mid-lap?
000021BA  6600 0016               1343      bne.l .Powerup
000021BE                          1344  
000021BE  0C79 0000 002F93B6      1345      cmp.w #0, flag_CanLap   ; Are we in a valid lap state?
000021C6  6600 000A               1346      bne.l .Return           ; If not, invalid
000021CA                          1347  
000021CA  33FC 0001 002F93B6      1348      move.w #1, flag_CanLap  ; CanLap = true
000021D2                          1349  
000021D2                          1350  .Powerup:
000021D2                          1351      ; TODO: Whatever poewrups do
000021D2                          1352  
000021D2                          1353  .Return:
000021D2                          1354      ; No special state for any other material
000021D2                          1355  
000021D2  4E75                    1356      rts
000021D4                          1357  *| [End of Function] ProcessMaterial
000021D4                          1358  *|__________________________________________________
000021D4                          1359  *`                                                  `
000021D4                          1360  
000021D4                          1361  *,__________________________________________________,
000021D4                          1362  *| Input Variables
000021D4                          1363  LastTime    ds.l 1  ; Stores the last frame's start time
000021D8                          1364  LastSecond   ds.l 1  ; Stores the time the game started
000021DC                          1365  
000021DC                          1366  BackgroundBmpFile   INCBIN "../resources/background.bmp"
0012E266                          1367  RoadCollisionFile   INCBIN "../resources/collision_map.txt"
00179626                          1368  
00179626                          1369  *| Ship Rotations
00179626                          1370  ShipBmpFiles        INCBIN "../resources/ship_rotations/Ship_R0.bmp"
00179AB0                          1371                      INCBIN "../resources/ship_rotations/Ship_R22.5.bmp"
00179F3A                          1372                      INCBIN "../resources/ship_rotations/Ship_R45.bmp"
0017A3C4                          1373                      INCBIN "../resources/ship_rotations/Ship_R67.5.bmp"
0017A84E                          1374                      INCBIN "../resources/ship_rotations/Ship_R90.bmp"
0017ACD8                          1375                      INCBIN "../resources/ship_rotations/Ship_R112.5.bmp"
0017B162                          1376                      INCBIN "../resources/ship_rotations/Ship_R135.bmp"
0017B5EC                          1377                      INCBIN "../resources/ship_rotations/Ship_R157.5.bmp"
0017BA76                          1378                      INCBIN "../resources/ship_rotations/Ship_R180.bmp"
0017BF00                          1379                      INCBIN "../resources/ship_rotations/Ship_R202.5.bmp"
0017C38A                          1380                      INCBIN "../resources/ship_rotations/Ship_R225.bmp"
0017C814                          1381                      INCBIN "../resources/ship_rotations/Ship_R247.5.bmp"
0017CC9E                          1382                      INCBIN "../resources/ship_rotations/Ship_R270.bmp"
0017D128                          1383                      INCBIN "../resources/ship_rotations/Ship_R292.5.bmp"
0017D5B2                          1384                      INCBIN "../resources/ship_rotations/Ship_R315.bmp"
0017DA3C                          1385                      INCBIN "../resources/ship_rotations/Ship_R337.5.bmp"
0017DEC6                          1386  EndShipBmpFiles
0017DEC6                          1387  
0017DEC6                          1388  
0017DEC6                          1389  ; DebrisBmpFile       INCBIN "../resources/debris.bmp"
0017DEC6                          1390  
0017DEC6                          1391  *,__________________________________________________,
0017DEC6                          1392  *| Global Variables
0017DEC6                          1393  
0017DEC6                          1394  *| Data Type: Pixel Grid (pg)
0017DEC6                          1395  *| $0 = Width
0017DEC6                          1396  *| $2 = Height
0017DEC6                          1397  *| $4 = ABGR Pixels (List, length x * y)
0017DEC6                          1398  *>Renderer
0017DEC6                          1399  pg_Background   ds.l 307201     ; 1 + 640x480
002A9ECA                          1400  
002A9ECA                          1401  pg_ShipRotations        ds.l 4112   ; (1 + 16x16) x 16 for 16 unique sprites
002ADF0A                          1402  
002ADF0A                          1403  pg_Debris       ds.l 257        ; 1 + 16x16
002AE30E                          1404  
002AE30E                          1405  *| Data Type: Collision Map
002AE30E                          1406  *| Each byte represents a single pixel on the screen.
002AE30E                          1407  *| Dimension is assumed to be the dimensions of the screen.
002AE30E                          1408  *| 0 = off the road, 1 = on the road, 
002AE30E                          1409  *| 2 = lap, 3 = mid_lap, 4 = power_up
002AE30E                          1410  cm_Road         ds.b 307200 ; 640 x 480
002F930E                          1411  
002F930E                          1412  *| Data Type: Pixel Clear Zones -> List<vec2, vec2>
002F930E                          1413  *| An array storing the zones that need to be cleared of pixels
002F930E                          1414  *| Long 1: Stores a vec2 representing the offset in x, y
002F930E                          1415  *| Long 2: Stores a vec2 representing the width and height
002F930E                          1416  pixel_clear_zones   ds.l 40     ; Max of 20 zones to clear at any given time
002F93AE                          1417  pixel_clear_length  ds.l 1      ; Pointer to the last empty address
002F93B2                          1418  
002F93B2= 0000                    1419  flag_IsDead         dc.w $0
002F93B4= 0000                    1420  flag_IsBoosting     dc.w $0
002F93B6= 0000                    1421  flag_CanLap         dc.w $0
002F93B8                          1422  
002F93B8= 0001                    1423  i_CurrentLap        dc.w $1
002F93BA                          1424  
002F93BA                          1425  *>7-Segment LED
002F93BA                          1426  pg_7SegVertical     ds.l 65     ; 1 + 16x4
002F94BE                          1427  pg_7SegHorizontal   ds.l 65     ; 1 + 16x4
002F95C2                          1428      
002F95C2                          1429      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACCEL_AMOUNT        100
ALL_REG             7FFF
BACKGROUNDBMPFILE   21DC
CL_CHECKCOLLISIONS  2108
CL_CHECKCOLLISIONS:RETURN  2152
CL_GETCOLLISIONMATERIAL  2154
CL_GETCOLLISIONMATERIAL:RETURN  2176
CL_PROCESSMATERIAL  2178
CL_PROCESSMATERIAL:LAP  2190
CL_PROCESSMATERIAL:MIDLAP  21B4
CL_PROCESSMATERIAL:OFFROAD  2178
CL_PROCESSMATERIAL:POWERUP  21D2
CL_PROCESSMATERIAL:RETURN  21D2
CM_ROAD             2AE30E
DECEL_AMOUNT        100
ENDSHIPBMPFILES     17DEC6
ENTER               D
ESC                 1B
FLAG_CANLAP         2F93B6
FLAG_ISBOOSTING     2F93B4
FLAG_ISDEAD         2F93B2
FL_LOADBITMAP       106E
FL_LOADCOLLISIONMAP  113A
FL_LOADCOLLISIONMAP:END  118A
FL_LOADCOLLISIONMAP:GETPIXELMAT  1148
FL_LOADCOLLISIONMAP:LAP  116A
FL_LOADCOLLISIONMAP:MIDLAP  117A
FL_LOADCOLLISIONMAP:OFFROAD  114A
FL_LOADCOLLISIONMAP:ONROAD  115A
FL_LOADCOLLISIONMAP:RETURN  1196
FL_LOADFILES        1000
FL_LOADSHIPROTATIONS  1044
FL_LOADSHIPROTATIONS:LOADBMP  1050
FP_11P25            B4000
FP_22P5             168000
FP_360              1680000
GAMELOOP            2042
GAMELOOP:RETURN     20B2
GETBITMAPCHUNKS     10B8
GETSINGLEPIXEL      10D2
GET_KEY_INPUT_COMMAND  13
GET_TIME            8
I_CAPTUREINPUTS     12B8
I_CAPTUREINPUTS:RETURN  12D2
I_CURRENTLAP        2F93B8
LAP_DISPLAY_OFFSET  2540014
LASTSECOND          21D8
LASTTIME            21D4
MAIN                2000
MAX_SPEED           1000
MAX_VELOCITY        30000
PARSEBITMAPHEADER   1072
PARSELITTLEENDIANLONG  1132
PG_7SEGHORIZONTAL   2F94BE
PG_7SEGVERTICAL     2F93BA
PG_BACKGROUND       17DEC6
PG_DEBRIS           2ADF0A
PG_SHIPROTATIONS    2A9ECA
PH_CALCULATEPOSITION  145C
PH_CALCULATEPOSITION:NEGX  146E
PH_CALCULATEPOSITION:NEGY  1484
PH_CALCULATEPOSITION:POSX  1482
PH_CALCULATEPOSITION:POSY  1498
PH_CALCULATEPOSITION:RETURN  14BA
PH_CALCULATEPOSITION:UPDATEPOS  149A
PH_CALCULATEROTATION  12D8
PH_CALCULATEROTATION:ANGLEOVER  132C
PH_CALCULATEROTATION:ANGLEUNDER  1338
PH_CALCULATEROTATION:FIXANGLE  1312
PH_CALCULATEROTATION:RETURN  133E
PH_CALCULATEROTATION:TURNLEFT  12F6
PH_CALCULATEROTATION:TURNRIGHT  130C
PH_CALCVELDIR       13EA
PH_CALCVELDIR:RETURN  1456
PH_CALCVELMAGNITUDE  1384
PH_CALCVELMAGNITUDE:ACCEL  13AA
PH_CALCVELMAGNITUDE:CLAMP  13BC
PH_CALCVELMAGNITUDE:CLAMPMAX  13CE
PH_CALCVELMAGNITUDE:CLAMPMIN  13BC
PH_CALCVELMAGNITUDE:DECEL  13B6
PH_CALCVELMAGNITUDE:FRIC  13E4
PH_CALCVELMAGNITUDE:RETURN  13E4
PH_CLAMPNUMBER      14C0
PH_CLAMPNUMBER:OVER  14E8
PH_CLAMPNUMBER:RETURN  14F0
PH_CLAMPNUMBER:UNDER  14E0
PH_CLAMPVECTOR      14F4
PH_CLAMPVECTOR:RETURN  1530
PH_SELECTSHIPROTATION  1344
PH_SELECTSHIPROTATION:GETFILE  1372
PH_SELECTSHIPROTATION:NEXTROT  1352
PH_SELECTSHIPROTATION:RETURN  137E
PH_SINE             1536
PH_SINE:Q1          155E
PH_SINE:Q2          1570
PH_SINE:Q3          158E
PH_SINE:Q4          15A8
PH_SINE:RETURN      15C2
PIXEL_CLEAR_LENGTH  2F93AE
PIXEL_CLEAR_ZONES   2F930E
PRINT_PIXEL         52
ROADCOLLISIONFILE   12E266
R_CLEARSPRITES      1220
R_CLEARSPRITES:CHECKENDOFSPRITES  1298
R_CLEARSPRITES:CLEARPIXEL  1262
R_CLEARSPRITES:CLEARSPRITE  1262
R_CLEARSPRITES:GETSPRITE  123C
R_CLEARSPRITES:LOADREGISTER  1224
R_CLEARSPRITES:PRINTBGPIXEL  1274
R_CLEARSPRITES:RETURN  12A8
R_PRINTIMAGE        1198
R_PRINTIMAGE:LOADVARSTOREGISTERS  11BC
R_PRINTIMAGE:NOPRINT  1206
R_PRINTIMAGE:PRINTPIXEL  11EA
R_PRINTIMAGE:RETURN  121A
SCREEN_HEIGHT       1E0
SCREEN_WIDTH        280
SET_PIXEL_COLOR     50
SEVENSEGHORIZONTALBMPFILE  1908
SEVENSEGTABLE       1A22
SEVENSEGVERTICALBMPFILE  17EE
SEVEN_SEG_DIMENSIONS  12001F
SHIFT               10
SHIPBMPFILES        179626
SHIPPOSITION        167A
SHIP_BMP_SIZE       48A
SHIP_PG_SIZE        404
SINTABLE            15C4
SINTABLESIZE        B4
SPACE               20
SSD_LAP             1A2C
SSD_TIMER           1A34
SS_INITDISPLAYS     1682
SS_INITDISPLAYS:RETURN  16D6
SS_SEVENSEGUPDATE   16DC
SS_SEVENSEGUPDATE:FIFTH  178E
SS_SEVENSEGUPDATE:FIRST  171C
SS_SEVENSEGUPDATE:FOURTH  1770
SS_SEVENSEGUPDATE:PRINTSEGMENTS  1714
SS_SEVENSEGUPDATE:RETURN  17E8
SS_SEVENSEGUPDATE:SECOND  1738
SS_SEVENSEGUPDATE:SEVENTH  17CA
SS_SEVENSEGUPDATE:SIXTH  17AC
SS_SEVENSEGUPDATE:THIRD  1752
START               2000
SWAPBUFFER          12AE
SWAP_BUFFER         5E
TIMER_1_DISPLAY_OFFSET  50014
TIMER_2_DISPLAY_OFFSET  1A0014
TIMER_3_DISPLAY_OFFSET  370014
TIMER_4_DISPLAY_OFFSET  4C0014
TRAP_REG            703
UPDATETIMER         20B4
UPDATETIMER:ADDSECOND  20DE
UPDATETIMER:ENDOVERFLOW  20FC
UPDATETIMER:RETURN  2102
